<!DOCTYPE html><html lang="ch" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Linux epoll模型详解及源码分析 ( 转) | 现役程序员skykens的博客</title><meta name="author" content="Skykens,bohemia0508@gmail.com"><meta name="copyright" content="Skykens"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="转载自 CSDN Linux epoll模型详解及源码分析  epoll简介epoll是当前在Linux下开发大规模并发网络程序的热门选择，epoll在Linux2.6内核中正式引入，和select相似，都是IO多路复用（IO multiplexing）技术。 EPOLL 特点支持一个进程打开较大数目的文件描述符（fd）select模型对一个进程所打开的文件描述符是有一定限制的，其由FD_SET">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux epoll模型详解及源码分析 ( 转)">
<meta property="og:url" content="https://skykens.github.io/linuxepoll-mo-xing-xiang-jie-ji-yuan-ma-fen-xi-zhuan/index.html">
<meta property="og:site_name" content="现役程序员skykens的博客">
<meta property="og:description" content="转载自 CSDN Linux epoll模型详解及源码分析  epoll简介epoll是当前在Linux下开发大规模并发网络程序的热门选择，epoll在Linux2.6内核中正式引入，和select相似，都是IO多路复用（IO multiplexing）技术。 EPOLL 特点支持一个进程打开较大数目的文件描述符（fd）select模型对一个进程所打开的文件描述符是有一定限制的，其由FD_SET">
<meta property="og:locale">
<meta property="og:image" content="https://raw.githubusercontent.com/skykens/pubPhotos/main/wallhaven-ox2dg7.jpg">
<meta property="article:published_time" content="2020-02-02T10:56:00.000Z">
<meta property="article:modified_time" content="2020-03-10T14:31:26.000Z">
<meta property="article:author" content="Skykens">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/skykens/pubPhotos/main/wallhaven-ox2dg7.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://skykens.github.io/linuxepoll-mo-xing-xiang-jie-ji-yuan-ma-fen-xi-zhuan/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: Skykens","link":"Link: ","source":"Source: 现役程序员skykens的博客","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux epoll模型详解及源码分析 ( 转)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-03-10 14:31:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="现役程序员skykens的博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">99</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目錄</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/skykens/pubPhotos/main/wallhaven-ox2dg7.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">现役程序员skykens的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目錄</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux epoll模型详解及源码分析 ( 转)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-02-02T10:56:00.000Z" title="Created 2020-02-02 10:56:00">2020-02-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-03-10T14:31:26.000Z" title="Updated 2020-03-10 14:31:26">2020-03-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux epoll模型详解及源码分析 ( 转)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>转载自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaobryant/article/details/80557262">CSDN Linux epoll模型详解及源码分析</a></p>
</blockquote>
<h1 id="epoll简介"><a href="#epoll简介" class="headerlink" title="epoll简介"></a>epoll简介</h1><p>epoll是当前在Linux下开发大规模并发网络程序的热门选择，epoll在Linux2.6内核中正式引入，和select相似，都是IO多路复用（IO multiplexing）技术。</p>
<h1 id="EPOLL-特点"><a href="#EPOLL-特点" class="headerlink" title="EPOLL 特点"></a>EPOLL 特点</h1><h2 id="支持一个进程打开较大数目的文件描述符（fd）"><a href="#支持一个进程打开较大数目的文件描述符（fd）" class="headerlink" title="支持一个进程打开较大数目的文件描述符（fd）"></a>支持一个进程打开较大数目的文件描述符（fd）</h2><p>select模型对一个进程所打开的文件描述符是有一定限制的，其由FD_SETSIZE设置，默认为1024/2048。这对于那些需要支持上万连接数目的高并发服务器来说显然太少了，这个时候，可以选择两种方案：一是可以选择修改FD_SETSIZE宏然后重新编译内核，不过这样做也会带来网络效率的下降；二是可以选择多进程的解决方案（传统的Apache方案），不过虽然Linux中创建线程的代价比较小，但仍然是不可忽视的，加上进程间数据同步远不及线程间同步的高效，所以也不是一种完美的方案。</p>
<p>但是，epoll则没有对描述符数目的限制，它所支持的文件描述符上限是整个系统最大可以打开的文件数目，例如，在1GB内存的机器上，这个限制大概为10万左右。</p>
<h2 id="IO效率不会随文件描述符（fd）的增加而线性下降"><a href="#IO效率不会随文件描述符（fd）的增加而线性下降" class="headerlink" title="IO效率不会随文件描述符（fd）的增加而线性下降"></a>IO效率不会随文件描述符（fd）的增加而线性下降</h2><p>传统的select/poll的一个致命弱点就是当你拥有一个很大的socket集合时，不过任一时间只有部分socket是活跃的，select/poll每次调用都会线性扫描整个socket集合，这将导致IO处理效率呈现线性下降。</p>
<p>但是，epoll不存在这个问题，它只会对活跃的socket进行操作，这是因为在内核实现中，epoll是根据每个fd上面的callback函数实现的。因此，只有活跃的socket才会主动去调用callback函数，其他idle状态socket则不会。在这一点上，epoll实现了一个伪AIO，其内部推动力在内核。</p>
<p>在一些benchmark中，如果所有的socket基本上都是活跃的，如高速LAN环境，epoll并不比select/poll效率高，相反，过多使用epoll_ctl，其效率反而还有稍微下降。但是，一旦使用idle connections模拟WAN环境，epoll的效率就远在select/poll之上了。</p>
<h2 id="使用mmap加速内核与用户空间的消息传递"><a href="#使用mmap加速内核与用户空间的消息传递" class="headerlink" title="使用mmap加速内核与用户空间的消息传递"></a>使用mmap加速内核与用户空间的消息传递</h2><p>无论是select，poll还是epoll，它们都需要内核把fd消息通知给用户空间。因此，如何避免不必要的内存拷贝就很重要了。对于该问题，epoll通过内核与用户空间mmap(映射)同一块内存来实现。</p>
<h2 id="内核微调"><a href="#内核微调" class="headerlink" title="内核微调"></a>内核微调</h2><p>这一点其实不算epoll的优点了，而是整个Linux平台的优点，Linux赋予开发者微调内核的能力。比如，内核TCP/IP协议栈使用内存池管理sk_buff结构，那么，可以在运行期间动态调整这个内存池大小（skb_head_pool）来提高性能，该参数可以通过使用echo xxxx &gt; /proc/sys/net/core/hot_list_length来完成。再如，可以尝试使用最新的NAPI网卡驱动架构来处理数据包数量巨大但数据包本身很小的特殊场景。</p>
<h1 id="epoll-API"><a href="#epoll-API" class="headerlink" title="epoll API"></a>epoll API</h1><p>epoll只有epoll_create、epoll_ctl和epoll_wait这三个系统调用。其定义如下：</p>
<pre class="line-numbers language-none"><code class="language-none"># include &lt;sys/epoll.h&gt;

int epoll_create(int size);

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);

int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h2><p>int epoll_create(int size);</p>
<p>可以调用epoll_create方法创建一个epoll的句柄。</p>
<p>需要注意的是，当创建好epoll句柄后，它就会占用一个fd值。在使用完epoll后，必须调用close函数进行关闭，否则可能导致fd被耗尽。</p>
<h2 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h2><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p>
<p>epoll的事件注册函数，它不同于select是在监听事件时告诉内核要监听什么类型的事件，而是通过epoll_ctl注册要监听的事件类型。</p>
<p>第一个参数epfd：epoll_create函数的返回值。</p>
<p>第二个参数events：表示动作类型。有三个宏来表示：</p>
<ul>
<li>EPOLL_CTL_ADD：注册新的fd到epfd中；</li>
<li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</li>
<li>EPOLL_CTL_DEL：从epfd中删除一个fd。</li>
</ul>
<p>第三个参数fd：需要监听的fd。</p>
<p>第四个参数event：告诉内核需要监听什么事件。</p>
<p>struct epoll_event结构如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none">// 保存触发事件的某个文件描述符相关的数据
typedef union epoll_data {
    void *ptr;
    int fd;
    __uint32_t u32;
    __uint64_t u64;
} epoll_data_t;


// 感兴趣的事件和被触发的事件
struct epoll_event {
    __uint32_t events; // Epoll events
    epoll_data_t data; // User data variable
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>如上所示，对于Epoll Events，其可以是以下几个宏的集合：</p>
<p>EPOLLIN：表示对应的文件描述符可读（包括对端Socket）；</p>
<p>EPOLLOUT：表示对应的文件描述符可写；</p>
<p>EPOLLPRI：表示对应的文件描述符有紧急数据可读（带外数据）；</p>
<p>EPOLLERR：表示对应的文件描述符发生错误；</p>
<p>EPOLLHUP：表示对应的文件描述符被挂断；</p>
<p>EPOLLET：将EPOLL设为边缘触发（Edge Triggered），这是相对于水平触发（Level Triggered）而言的。</p>
<p>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket，需要再次</p>
<h1 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h1><p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</p>
<p>收集在epoll监控的事件中已经发生的事件。参数events是分配好的epoll_event结构体数组，epoll将会把发生的事件赋值到events数组中（events不可以是空指针，内核只负责把数据赋值到这个event数组中，不会去帮助我们在用户态分配内存）。maxevents告诉内核这个events数组有多大，这个maxevents的值不能大于创建epoll_create时的size。参数timeout是超时时间（毫秒）。如果函数调用成功，则返回对应IO上已准备好的文件描述符数目，如果返回0则表示已经超时。</p>
<h1 id="epoll工作模式"><a href="#epoll工作模式" class="headerlink" title="epoll工作模式"></a>epoll工作模式</h1><h2 id="LT模式（Level-Triggered，水平触发）"><a href="#LT模式（Level-Triggered，水平触发）" class="headerlink" title="LT模式（Level Triggered，水平触发）"></a>LT模式（Level Triggered，水平触发）</h2><p>该模式是epoll的缺省工作模式，其同时支持阻塞和非阻塞socket。内核会告诉开发者一个文件描述符是否就绪，如果开发者不采取任何操作，内核仍会一直通知。</p>
<h2 id="ET模式（Edge-Triggered，边缘触发）"><a href="#ET模式（Edge-Triggered，边缘触发）" class="headerlink" title="ET模式（Edge Triggered，边缘触发）"></a>ET模式（Edge Triggered，边缘触发）</h2><p>该模式是一种高速处理模式，当且仅当状态发生变化时才会获得通知。在该模式下，其假定开发者在接收到一次通知后，会完整地处理该事件，因此内核将不再通知这一事件。注意，缓冲区中还有未处理的数据不能说是状态变化，因此，在ET模式下，开发者如果只读取了一部分数据，其将再也得不到通知了。正确的做法是，开发者自己确认读完了所有的字节（一直调用read/write直到出错EAGAGIN为止）。</p>
<p>Nginx默认采用的就是ET（边缘触发）。</p>
<h1 id="epoll高效性探讨"><a href="#epoll高效性探讨" class="headerlink" title="epoll高效性探讨"></a>epoll高效性探讨</h1><p>epoll的高效性主要体现在以下三个方面：</p>
<p>（1）select/poll每次调用都要传递所要监控的所有fd给select/poll系统调用，这意味着每次调用select/poll时都要将fd列表从用户空间拷贝到内核，当fd数目很多时，这会造成性能低效。对于epoll_wait，每次调用epoll_wait时，其不需要将fd列表传递给内核，epoll_ctl不需要每次都拷贝所有的fd列表，只需要进行增量式操作。因此，在调用epoll_create函数之后，内核已经在内核开始准备数据结构用于存放需要监控的fd了。其后，每次epoll_ctl只是对这个数据结构进行简单的维护操作即可。</p>
<p>（2）内核使用slab机制，为epoll提供了快速的数据结构。在内核里，一切都是文件。因此，epoll向内核注册了一个文件系统，用于存储所有被监控的fd。当调用epoll_create时，就会在这个虚拟的epoll文件系统中创建一个file节点。epoll在被内核初始化时，同时会分配出epoll自己的内核告诉cache区，用于存放每个我们希望监控的fd。这些fd会以红黑树的形式保存在内核cache里，以支持快速查找、插入和删除。这个内核高速cache，就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配好想要的size的内存对象，每次使用时都使用空闲的已分配好的对象。</p>
<p>（3）当调用epoll_ctl往epfd注册百万个fd时，epoll_wait仍然能够快速返回，并有效地将发生的事件fd返回给用户。原因在于，当我们调用epoll_create时，内核除了帮我们在epoll文件系统新建file节点，同时在内核cache创建红黑树用于存储以后由epoll_ctl传入的fd外，还会再建立一个list链表，用于存储准备就绪的事件。当调用epoll_wait时，仅仅观察这个list链表中有无数据即可。如果list链表中有数据，则返回这个链表中的所有元素；如果list链表中没有数据，则sleep然后等到timeout超时返回。所以，epoll_wait非常高效，而且，通常情况下，即使我们需要监控百万计的fd，但大多数情况下，一次也只返回少量准备就绪的fd而已。因此，每次调用epoll_wait，其仅需要从内核态复制少量的fd到用户空间而已。那么，这个准备就绪的list链表是怎么维护的呢？过程如下：当我们执行epoll_ctl时，除了把fd放入到epoll文件系统里file对象对应的红黑树之外，还会给内核中断处理程序注册一个回调函数，其告诉内核，如果这个fd的中断到了，就把它放到准备就绪的list链表中。</p>
<p>如此，一棵红黑树、一张准备就绪的fd链表以及少量的内核cache，就帮我们解决了高并发下fd的处理问题。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>执行epoll_create时，创建了红黑树和就绪list链表；</p>
<p>执行epoll_ctl时，如果增加fd，则检查在红黑树中是否存在，存在则立即返回，不存在则添加到红黑树<br>中，然后向内核注册回调函数，用于当中断事件到来时向准备就绪的list链表中插入数据。</p>
<p>执行epoll_wait时立即返回准备就绪链表里的数据即可。</p>
<h1 id="epoll源码分析"><a href="#epoll源码分析" class="headerlink" title="epoll源码分析"></a>epoll源码分析</h1><p>eventpoll_init过程：</p>
<pre class="line-numbers language-none"><code class="language-none">static int __init eventpoll_init(void)
{
    int error;

    init_MUTEX(&amp;epsem);

    /* Initialize the structure used to perform safe poll wait head wake ups */
    ep_poll_safewake_init(&amp;psw);

    /* Allocates slab cache used to allocate "struct epitem" items */
    epi_cache = kmem_cache_create("eventpoll_epi", sizeof(struct epitem),
            0, SLAB_HWCACHE_ALIGN|EPI_SLAB_DEBUG|SLAB_PANIC,
            NULL, NULL);

    /* Allocates slab cache used to allocate "struct eppoll_entry" */
    pwq_cache = kmem_cache_create("eventpoll_pwq",
            sizeof(struct eppoll_entry), 0,
            EPI_SLAB_DEBUG|SLAB_PANIC, NULL, NULL);

    /*
     * Register the virtual file system that will be the source of inodes
     * for the eventpoll files
     */
    error = register_filesystem(&amp;eventpoll_fs_type);
    if (error)
        goto epanic;

    /* Mount the above commented virtual file system */
    eventpoll_mnt = kern_mount(&amp;eventpoll_fs_type);
    error = PTR_ERR(eventpoll_mnt);
    if (IS_ERR(eventpoll_mnt))
        goto epanic;

    DNPRINTK(3, (KERN_INFO "[%p] eventpoll: successfully initialized.\n",
            current));
    return 0;

epanic:
    panic("eventpoll_init() failed\n");
}
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>其中，epoll用slab分配器kmem_cache_create分配内存用于存放struct epitem和struct eppoll_entry。</p>
<p>当向系统中添加一个fd时，就会创建一个epitem结构体，这是内核管理epoll的基本数据结构：</p>
<p>````<br>/*</p>
<ul>
<li><p>Each file descriptor added to the eventpoll interface will</p>
</li>
<li><p>have an entry of this type linked to the hash.</p>
</li>
<li><p>/<br>struct epitem {<br>   /* RB-Tree node used to link this structure to the eventpoll rb-tree */<br>   struct rb_node rbn;   // 用于主结构管理的红黑树</p>
<p>   /* List header used to link this structure to the eventpoll ready list */<br>   struct list_head rdllink;  // 事件就绪队列</p>
<p>   /* The file descriptor information this item refers to */<br>   struct epoll_filefd ffd; // 用于主结构中的链表</p>
<p>   /* Number of active wait queue attached to poll operations */<br>   int nwait; // 事件个数</p>
<p>   /* List containing poll wait queues */<br>   struct list_head pwqlist; // 双向链表，保存着被监控文件的等待队列</p>
<p>   /* The “container” of this item */<br>   struct eventpoll *ep;  // 该项属于哪个主结构体</p>
<p>   /* The structure that describe the interested events and the source fd */<br>   struct epoll_event event; // 注册的感兴趣的时间</p>
<p>   /*</p>
<pre><code>* Used to keep track of the usage count of the structure. This avoids
* that the structure will desappear from underneath our processing.
*/
</code></pre>
<p>   atomic_t usecnt;</p>
<p>   /* List header used to link this item to the “struct file” items list */<br>   struct list_head fllink;</p>
<p>   /* List header used to link the item to the transfer list */<br>   struct list_head txlink;</p>
<p>   /*</p>
<pre><code>* This is used during the collection/transfer of events to userspace
* to pin items empty events set.
*/
</code></pre>
<p>   unsigned int revents;<br>};</p>
<pre class="line-numbers language-none"><code class="language-none">
对于每个epfd，其对应的数据结构为：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>/*</p>
</li>
<li><p>This structure is stored inside the “private_data” member of the file</p>
</li>
<li><p>structure and rapresent the main data sructure for the eventpoll</p>
</li>
<li><p>interface.</p>
</li>
<li><p>/<br>struct eventpoll {<br>   /* Protect the this structure access */<br>   rwlock_t lock;</p>
<p>   /*</p>
<pre><code>* This semaphore is used to ensure that files are not removed
* while epoll is using them. This is read-held during the event
* collection loop and it is write-held during the file cleanup
* path, the epoll file exit code and the ctl operations.
*/
</code></pre>
<p>   struct rw_semaphore sem;</p>
<p>   /* Wait queue used by sys_epoll_wait() */<br>   wait_queue_head_t wq;</p>
<p>   /* Wait queue used by file-&gt;poll() */<br>   wait_queue_head_t poll_wait;</p>
<p>   /* List of ready file descriptors */<br>   struct list_head rdllist;  // 准备就绪的事件链表</p>
<p>   /* RB-Tree root used to store monitored fd structs */<br>   struct rb_root rbr;   // 用于管理所有fd的红黑树（根节点）<br>};</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">
eventpoll在epoll_create时创建：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<p>/*</p>
<ul>
<li><p>It opens an eventpoll file descriptor by suggesting a storage of “size”</p>
</li>
<li><p>file descriptors. The size parameter is just an hint about how to size</p>
</li>
<li><p>data structures. It won’t prevent the user to store more than “size”</p>
</li>
<li><p>file descriptors inside the epoll interface. It is the kernel part of</p>
</li>
<li><p>the userspace epoll_create(2).</p>
</li>
<li><p>/<br>asmlinkage long sys_epoll_create(int size)<br>{<br>   int error, fd;<br>   struct eventpoll *ep;<br>   struct inode *inode;<br>   struct file *file;</p>
<p>   DNPRINTK(3, (KERN_INFO “[%p] eventpoll: sys_epoll_create(%d)\n”,</p>
<pre><code>        current, size));
</code></pre>
<p>   /*</p>
<pre><code>* Sanity check on the size parameter, and create the internal data
* structure ( "struct eventpoll" ).
*/
</code></pre>
<p>   error = -EINVAL;<br>   if (size &lt;= 0 || (error = ep_alloc(&amp;ep)) != 0)  // ep_alloc为eventpoll分配内存并初始化</p>
<pre><code>   goto eexit_1;
</code></pre>
<p>   /*</p>
<pre><code>* Creates all the items needed to setup an eventpoll file. That is,
* a file structure, and inode and a free file descriptor.
*/
</code></pre>
<p>   error = ep_getfd(&amp;fd, &amp;inode, &amp;file, ep); // 创建于eventpoll相关的数据结构，包括file、inode和fd等信息<br>   if (error)</p>
<pre><code>   goto eexit_2;
</code></pre>
<p>   DNPRINTK(3, (KERN_INFO “[%p] eventpoll: sys_epoll_create(%d) = %d\n”,</p>
<pre><code>        current, size, fd));
</code></pre>
<p>   return fd;</p>
</li>
</ul>
<p>eexit_2:<br>    ep_free(ep);<br>    kfree(ep);<br>eexit_1:<br>    DNPRINTK(3, (KERN_INFO “[%p] eventpoll: sys_epoll_create(%d) = %d\n”,<br>             current, size, error));<br>    return error;<br>}</p>
<pre class="line-numbers language-none"><code class="language-none">

如上，内核中维护了一棵红黑树，大致结构如下：



下面是epoll_ctl函数过程：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>/*</p>
<ul>
<li><p>The following function implements the controller interface for</p>
</li>
<li><p>the eventpoll file that enables the insertion/removal/change of</p>
</li>
<li><p>file descriptors inside the interest set.  It represents</p>
</li>
<li><p>the kernel part of the user space epoll_ctl(2).</p>
</li>
<li><p>/<br>asmlinkage long<br>sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event)<br>{<br>   int error;<br>   struct file *file, *tfile;<br>   struct eventpoll *ep;<br>   struct epitem *epi;<br>   struct epoll_event epds;</p>
<p>   DNPRINTK(3, (KERN_INFO “[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p)\n”,</p>
<pre><code>        current, epfd, op, fd, event));
</code></pre>
<p>   error = -EFAULT;<br>   if (ep_op_hash_event(op) &amp;&amp;</p>
<pre><code>   copy_from_user(&amp;epds, event, sizeof(struct epoll_event)))
   goto eexit_1;
</code></pre>
<p>   /* Get the “struct file *” for the eventpoll file */<br>   error = -EBADF;<br>   file = fget(epfd);  // 获取epfd对应的文件<br>   if (!file)</p>
<pre><code>   goto eexit_1;
</code></pre>
<p>   /* Get the “struct file *” for the target file */<br>   tfile = fget(fd);  // 获取fd对应的文件<br>   if (!tfile)</p>
<pre><code>   goto eexit_2;
</code></pre>
<p>   /* The target file descriptor must support poll */<br>   error = -EPERM;<br>   if (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)</p>
<pre><code>   goto eexit_3;
</code></pre>
<p>   /*</p>
<pre><code>* We have to check that the file structure underneath the file descriptor
* the user passed to us _is_ an eventpoll file. And also we do not permit
* adding an epoll file descriptor inside itself.
*/
</code></pre>
<p>   error = -EINVAL;<br>   if (file == tfile || !is_file_epoll(file))</p>
<pre><code>   goto eexit_3;
</code></pre>
<p>   /*</p>
<pre><code>* At this point it is safe to assume that the "private_data" contains
* our own data structure.
*/
</code></pre>
<p>   ep = file-&gt;private_data;</p>
<p>   down_write(&amp;ep-&gt;sem);</p>
<p>   /* Try to lookup the file inside our hash table */<br>   epi = ep_find(ep, tfile, fd);  // 在哈希表中查询，防止重复添加</p>
<p>   error = -EINVAL;<br>   switch (op) {<br>   case EPOLL_CTL_ADD:  // 添加节点，调用ep_insert函数</p>
<pre><code>   if (!epi) {
       epds.events |= POLLERR | POLLHUP;

       error = ep_insert(ep, &amp;epds, tfile, fd);
   } else
       error = -EEXIST;
   break;
</code></pre>
<p>   case EPOLL_CTL_DEL:  // 删除节点，调用ep_remove函数</p>
<pre><code>   if (epi)
       error = ep_remove(ep, epi);
   else
       error = -ENOENT;
   break;
</code></pre>
<p>   case EPOLL_CTL_MOD:  // 修改节点，调用ep_modify函数</p>
<pre><code>   if (epi) {
       epds.events |= POLLERR | POLLHUP;
       error = ep_modify(ep, epi, &amp;epds);
   } else
       error = -ENOENT;
   break;
</code></pre>
<p>   }</p>
<p>   /*</p>
<pre><code>* The function ep_find() increments the usage count of the structure
* so, if this is not NULL, we need to release it.
*/
</code></pre>
<p>   if (epi)</p>
<pre><code>   ep_release_epitem(epi);
</code></pre>
<p>   up_write(&amp;ep-&gt;sem);</p>
</li>
</ul>
<p>eexit_3:<br>    fput(tfile);<br>eexit_2:<br>    fput(file);<br>eexit_1:<br>    DNPRINTK(3, (KERN_INFO “[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p) = %d\n”,<br>             current, epfd, op, fd, event, error));</p>
<pre><code>return error;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
对于ep_insert函数，基本代码如下：
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>static int ep_insert(struct eventpoll *ep, struct epoll_event *event,<br>             struct file *tfile, int fd)<br>{<br>    int error, revents, pwake = 0;<br>    unsigned long flags;<br>    struct epitem *epi;<br>    struct ep_pqueue epq;</p>
<pre><code>error = -ENOMEM;
// 分配一个epitem结构体来保存每个加入的fd
if (!(epi = kmem_cache_alloc(epi_cache, SLAB_KERNEL)))
    goto eexit_1;

/* Item initialization follow here ... */
// 初始化结构体
ep_rb_initnode(&amp;epi-&gt;rbn);
INIT_LIST_HEAD(&amp;epi-&gt;rdllink);
INIT_LIST_HEAD(&amp;epi-&gt;fllink);
INIT_LIST_HEAD(&amp;epi-&gt;txlink);
INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);
epi-&gt;ep = ep;
ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);
epi-&gt;event = *event;
atomic_set(&amp;epi-&gt;usecnt, 1);
epi-&gt;nwait = 0;

/* Initialize the poll table using the queue callback */
epq.epi = epi;
// 安装poll回调函数
init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);

/*
 * Attach the item to the poll hooks and get current event bits.
 * We can safely use the file* here because its usage count has
 * been increased by the caller of this function.
 */
// 将当前item添加至poll hook中，然后获取当前event位
revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);

/*
 * We have to check if something went wrong during the poll wait queue
 * install process. Namely an allocation for a wait queue failed due
 * high memory pressure.
 */
if (epi-&gt;nwait &lt; 0)
    goto eexit_2;

/* Add the current item to the list of active epoll hook for this file */
spin_lock(&amp;tfile-&gt;f_ep_lock);
list_add_tail(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);
spin_unlock(&amp;tfile-&gt;f_ep_lock);

/* We have to drop the new item inside our item list to keep track of it */
write_lock_irqsave(&amp;ep-&gt;lock, flags);

/* Add the current item to the rb-tree */
ep_rbtree_insert(ep, epi);

/* If the file is already "ready" we drop it inside the ready list */
if ((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink)) {
    list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);

    /* Notify waiting tasks that events are available */
    if (waitqueue_active(&amp;ep-&gt;wq))
        wake_up(&amp;ep-&gt;wq);
    if (waitqueue_active(&amp;ep-&gt;poll_wait))
        pwake++;
}

write_unlock_irqrestore(&amp;ep-&gt;lock, flags);

/* We have to call this outside the lock */
if (pwake)
    ep_poll_safewake(&amp;psw, &amp;ep-&gt;poll_wait);

DNPRINTK(3, (KERN_INFO "[%p] eventpoll: ep_insert(%p, %p, %d)\n",
         current, ep, tfile, fd));

return 0;
</code></pre>
<p>eexit_2:<br>    ep_unregister_pollwait(ep, epi);</p>
<pre><code>/*
 * We need to do this because an event could have been arrived on some
 * allocated wait queue.
 */
write_lock_irqsave(&amp;ep-&gt;lock, flags);
if (ep_is_linked(&amp;epi-&gt;rdllink))
    ep_list_del(&amp;epi-&gt;rdllink);
write_unlock_irqrestore(&amp;ep-&gt;lock, flags);

kmem_cache_free(epi_cache, epi);
</code></pre>
<p>eexit_1:<br>    return error;<br>}</p>
<pre class="line-numbers language-none"><code class="language-none">
其中，init_poll_funcptr和tfile-&gt;f_op-&gt;poll将ep_ptable_queue_proc注册到epq.pt中的qproc中。

ep_ptable_queue_proc函数设置了等待队列的ep_poll_callback回调函数。在设备硬件数据到来时，硬件中断函数唤醒该等待队列上等待的进程时，会调用唤醒函数ep_poll_callback。

ep_poll_callback函数主要的功能是将被监视文件的等待事件就绪时，将文件对应的epitem实例添加到就绪队列中，当用户调用epoll_wait时，内核会将就绪队列中的事件报告给用户。

epoll_wait的实现如下：
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>/*</p>
<ul>
<li><p>Implement the event wait interface for the eventpoll file. It is the kernel</p>
</li>
<li><p>part of the user space epoll_wait(2).</p>
</li>
<li><p>/<br>asmlinkage long sys_epoll_wait(int epfd, struct epoll_event __user *events,</p>
<pre><code>              int maxevents, int timeout)
</code></pre>
<p>{<br>   int error;<br>   struct file *file;<br>   struct eventpoll *ep;</p>
<p>   DNPRINTK(3, (KERN_INFO “[%p] eventpoll: sys_epoll_wait(%d, %p, %d, %d)\n”,</p>
<pre><code>        current, epfd, events, maxevents, timeout));
</code></pre>
<p>   /* The maximum number of event must be greater than zero */<br>   if (maxevents &lt;= 0 || maxevents &gt; MAX_EVENTS) // 检查maxevents参数</p>
<pre><code>   return -EINVAL;
</code></pre>
<p>   /* Verify that the area passed by the user is writeable */<br>   // 检查用户空间传入的events指向的内存是否可写<br>   if (!access_ok(VERIFY_WRITE, events, maxevents * sizeof(struct epoll_event))) {</p>
<pre><code>   error = -EFAULT;
   goto eexit_1;
</code></pre>
<p>   }</p>
<p>   /* Get the “struct file *” for the eventpoll file */<br>   error = -EBADF;<br>   file = fget(epfd); // 获取epfd对应的eventpoll文件的file实例，file结构是在epoll_create中创建的<br>   if (!file)</p>
<pre><code>   goto eexit_1;
</code></pre>
<p>   /*</p>
<pre><code>* We have to check that the file structure underneath the fd
* the user passed to us _is_ an eventpoll file.
*/
</code></pre>
<p>   error = -EINVAL;<br>   if (!is_file_epoll(file))</p>
<pre><code>   goto eexit_2;
</code></pre>
<p>   /*</p>
<pre><code>* At this point it is safe to assume that the "private_data" contains
* our own data structure.
*/
</code></pre>
<p>   ep = file-&gt;private_data;</p>
<p>   /* Time to fish for events … */<br>   // 核心处理函数<br>   error = ep_poll(ep, events, maxevents, timeout);</p>
</li>
</ul>
<p>eexit_2:<br>    fput(file);<br>eexit_1:<br>    DNPRINTK(3, (KERN_INFO “[%p] eventpoll: sys_epoll_wait(%d, %p, %d, %d) = %d\n”,<br>             current, epfd, events, maxevents, timeout, error));</p>
<pre><code>return error;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
其中，调用ep_poll函数，具体流程如下：
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,<br>           int maxevents, long timeout)<br>{<br>    int res, eavail;<br>    unsigned long flags;<br>    long jtimeout;<br>    wait_queue_t wait;</p>
<pre><code>/*
 * Calculate the timeout by checking for the "infinite" value ( -1 )
 * and the overflow condition. The passed timeout is in milliseconds,
 * that why (t * HZ) / 1000.
 */
jtimeout = (timeout &lt; 0 || timeout &gt;= EP_MAX_MSTIMEO) ?
    MAX_SCHEDULE_TIMEOUT : (timeout * HZ + 999) / 1000;
</code></pre>
<p>retry:<br>    write_lock_irqsave(&amp;ep-&gt;lock, flags);</p>
<pre><code>res = 0;
if (list_empty(&amp;ep-&gt;rdllist)) {
    /*
     * We don't have any available event to return to the caller.
     * We need to sleep here, and we will be wake up by
     * ep_poll_callback() when events will become available.
     */
    init_waitqueue_entry(&amp;wait, current);
    add_wait_queue(&amp;ep-&gt;wq, &amp;wait);

    for (;;) {
        /*
         * We don't want to sleep if the ep_poll_callback() sends us
         * a wakeup in between. That's why we set the task state
         * to TASK_INTERRUPTIBLE before doing the checks.
         */
        set_current_state(TASK_INTERRUPTIBLE);
        if (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)
            break;
        if (signal_pending(current)) {
            res = -EINTR;
            break;
        }

        write_unlock_irqrestore(&amp;ep-&gt;lock, flags);
        jtimeout = schedule_timeout(jtimeout);
        write_lock_irqsave(&amp;ep-&gt;lock, flags);
    }
    remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);

    set_current_state(TASK_RUNNING);
}

/* Is it worth to try to dig for events ? */
eavail = !list_empty(&amp;ep-&gt;rdllist);

write_unlock_irqrestore(&amp;ep-&gt;lock, flags);

/*
 * Try to transfer events to user space. In case we get 0 events and
 * there's still timeout left over, we go trying again in search of
 * more luck.
 */
if (!res &amp;&amp; eavail &amp;&amp;
    !(res = ep_events_transfer(ep, events, maxevents)) &amp;&amp; jtimeout)
    goto retry;

return res;
</code></pre>
<p>}</p>
<p>```</p>
<p>ep_send_events函数用于向用户空间发送就绪事件。ep_send_events函数将用户传入的内存简单封装到ep_send_events_data结构中，然后调用ep_scan_ready_list将就绪队列中的事件传入用户空间的内存。</p>
<p>六、参考<br>Epoll详解及源码分析——CSDN博客</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:bohemia0508@gmail.com">Skykens</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skykens.github.io/linuxepoll-mo-xing-xiang-jie-ji-yuan-ma-fen-xi-zhuan/">https://skykens.github.io/linuxepoll-mo-xing-xiang-jie-ji-yuan-ma-fen-xi-zhuan/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/skykens/pubPhotos/main/wallhaven-ox2dg7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/tong-guo-leetcode-lai-liao-jie-hui-su-suan-fa/"><img class="prev-cover" src="https://raw.githubusercontent.com/skykens/pubPhotos/main/wallhaven-mdr3k1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">通过LeetCode来了解   回溯算法</div></div></a></div><div class="next-post pull-right"><a href="/shen-ru-li-jie-select-mo-xing-yuan-ma-fen-xi/"><img class="next-cover" src="https://raw.githubusercontent.com/skykens/pubPhotos/main/wallhaven-4g6l30.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">深入理解select 模型     （源码分析 ）</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Skykens</div><div class="author-info__description"> 分享后端开发相关知识、复盘、个人观点，愿君喜欢。</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">99</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">17</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/skykens"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/skykens" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="skykens:470798745@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">2020年,关键词:疫情,求职,进入腾讯
2021年,关键词:入职,异地,迷茫
2022年,学习,改变,写作自由,离开
2023年,关键词:新城市,思念,深耕,代码自由</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#epoll%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">epoll简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EPOLL-%E7%89%B9%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">EPOLL 特点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%89%93%E5%BC%80%E8%BE%83%E5%A4%A7%E6%95%B0%E7%9B%AE%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88fd%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">支持一个进程打开较大数目的文件描述符（fd）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%95%88%E7%8E%87%E4%B8%8D%E4%BC%9A%E9%9A%8F%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88fd%EF%BC%89%E7%9A%84%E5%A2%9E%E5%8A%A0%E8%80%8C%E7%BA%BF%E6%80%A7%E4%B8%8B%E9%99%8D"><span class="toc-number">2.2.</span> <span class="toc-text">IO效率不会随文件描述符（fd）的增加而线性下降</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8mmap%E5%8A%A0%E9%80%9F%E5%86%85%E6%A0%B8%E4%B8%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">2.3.</span> <span class="toc-text">使用mmap加速内核与用户空间的消息传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%BE%AE%E8%B0%83"><span class="toc-number">2.4.</span> <span class="toc-text">内核微调</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#epoll-API"><span class="toc-number">3.</span> <span class="toc-text">epoll API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll-create"><span class="toc-number">3.1.</span> <span class="toc-text">epoll_create</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll-ctl"><span class="toc-number">3.2.</span> <span class="toc-text">epoll_ctl</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#epoll-wait"><span class="toc-number">4.</span> <span class="toc-text">epoll_wait</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#epoll%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">epoll工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LT%E6%A8%A1%E5%BC%8F%EF%BC%88Level-Triggered%EF%BC%8C%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">LT模式（Level Triggered，水平触发）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ET%E6%A8%A1%E5%BC%8F%EF%BC%88Edge-Triggered%EF%BC%8C%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">ET模式（Edge Triggered，边缘触发）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#epoll%E9%AB%98%E6%95%88%E6%80%A7%E6%8E%A2%E8%AE%A8"><span class="toc-number">6.</span> <span class="toc-text">epoll高效性探讨</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#epoll%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">8.</span> <span class="toc-text">epoll源码分析</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/undefined-symbol-ke-neng-de-wen-ti/" title="undefined symbol 可能的问题"><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/wallhaven-zxg76o.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="undefined symbol 可能的问题"/></a><div class="content"><a class="title" href="/undefined-symbol-ke-neng-de-wen-ti/" title="undefined symbol 可能的问题">undefined symbol 可能的问题</a><time datetime="2023-03-23T22:01:00.000Z" title="Created 2023-03-23 22:01:00">2023-03-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/na-xie-kai-xiang-ji-yong-de-kai-fa-huan-jing/" title="开箱即用的开发环境"><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/wallhaven-6oqzgq.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="开箱即用的开发环境"/></a><div class="content"><a class="title" href="/na-xie-kai-xiang-ji-yong-de-kai-fa-huan-jing/" title="开箱即用的开发环境">开箱即用的开发环境</a><time datetime="2023-03-23T00:16:00.000Z" title="Created 2023-03-23 00:16:00">2023-03-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/man-tan-vcs-zai-you-xi-zhong-de-shi-yong/" title="漫谈VCS在游戏中的使用"><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/wallhaven-6oqzgq.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="漫谈VCS在游戏中的使用"/></a><div class="content"><a class="title" href="/man-tan-vcs-zai-you-xi-zhong-de-shi-yong/" title="漫谈VCS在游戏中的使用">漫谈VCS在游戏中的使用</a><time datetime="2023-03-18T00:01:00.000Z" title="Created 2023-03-18 00:01:00">2023-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/guan-yu-tong-guo-cp-fu-gai-so-dao-zhi-coredump/" title="关于通过cp覆盖so导致coredump"><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/wallhaven-dgpvzl.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于通过cp覆盖so导致coredump"/></a><div class="content"><a class="title" href="/guan-yu-tong-guo-cp-fu-gai-so-dao-zhi-coredump/" title="关于通过cp覆盖so导致coredump">关于通过cp覆盖so导致coredump</a><time datetime="2021-07-08T10:20:27.000Z" title="Created 2021-07-08 10:20:27">2021-07-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/kubernetes-xue-xi-bi-ji-0-cong-ling-da-jian-k8s-ji-qun/" title="Kubernetes学习笔记0-从零搭建k8s集群"><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/wallhaven-5dx6w7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kubernetes学习笔记0-从零搭建k8s集群"/></a><div class="content"><a class="title" href="/kubernetes-xue-xi-bi-ji-0-cong-ling-da-jian-k8s-ji-qun/" title="Kubernetes学习笔记0-从零搭建k8s集群">Kubernetes学习笔记0-从零搭建k8s集群</a><time datetime="2021-06-30T15:20:27.000Z" title="Created 2021-06-30 15:20:27">2021-06-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By Skykens</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'AmW91X1WNrKyj5Y7sCfuj4v3-gzGzoHsz',
      appKey: '4SoS7HRckX0IlgpKVJcVSpsP',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>