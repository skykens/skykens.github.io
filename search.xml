<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>undefined symbol 可能的问题</title>
      <link href="undefined-symbol-ke-neng-de-wen-ti/"/>
      <url>undefined-symbol-ke-neng-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><blockquote><p>这里尤为重要，通常情况下是没有时间去看那么多的基础知识的，就只需要哪几个命令管用拿来用就好了。</p></blockquote><p>有时候构建项目会遇到一些undeined symbol这样的错误。这里备忘一下用到命令和排错方式。 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ldd <span class="token punctuation">[</span>.so/.a/bin<span class="token punctuation">]</span> <span class="token comment"># 查看link 的lib库有哪些( T 表示加载， U表示undefined symbol）</span>strings <span class="token punctuation">[</span>.so/.a/bin<span class="token punctuation">]</span> <span class="token comment"># 打印出二进制中的string，有时候可以用来看.so的version</span>objdump <span class="token comment"># 用来查看目标文件的构成,除非你懂目标文件的构成（section）那些不然一般用不上</span>nm <span class="token comment"># 显示目标文件中的符号，意味着可以看到一些全局变量之类的） 这个具体的说明看这个博客https://blog.csdn.net/K346K346/article/details/89088542</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大致就是看代码，symbol是存放在哪个lib里的，然后用ldd看这个lib的位置，然后看一下时间戳和version 是不是正确的。</p><blockquote><p>如果lib是自己项目编译出来的呢？</p></blockquote><p>那么就是到编译目录下（build/）下面找.o文件，用objdump来看。具体的需要补充知识，后面多看一些编译方面的东西再来单开一篇知识文章补充这个东西吧。</p>]]></content>
      
      
      <categories>
          
          <category> 链接 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开箱即用的开发环境</title>
      <link href="na-xie-kai-xiang-ji-yong-de-kai-fa-huan-jing/"/>
      <url>na-xie-kai-xiang-ji-yong-de-kai-fa-huan-jing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每次安装部署开发环境都很折腾。不是这个依赖就是那个依赖，然后基开发资源如果有限的话就更头疼，有没有可能有开箱即用的开发环境呢。可以让新人一来项目，部署环境就像安装个exe文件那么简单。</p></blockquote><h1 id="rsync-inotifywait-wsl2"><a href="#rsync-inotifywait-wsl2" class="headerlink" title="rsync+inotifywait +wsl2"></a>rsync+inotifywait +wsl2</h1><blockquote><p>主要还是因为公用资源有限，代码解析速度很慢。</p></blockquote><h2 id="用wsl同步代码的理由"><a href="#用wsl同步代码的理由" class="headerlink" title="用wsl同步代码的理由"></a>用wsl同步代码的理由</h2><ul><li>服务器资源有限，但是办公电脑的配置很高，可以用办公电脑来做这件事</li><li>只是在本地生成compile_commands.json和运行clangd服务器，并不需要很多依赖</li></ul><h2 id="谈谈rsync"><a href="#谈谈rsync" class="headerlink" title="谈谈rsync"></a>谈谈rsync</h2><p>事情起因是因为服务器配置有限，没那么好用。就用inotifywait来监听文件变化，然后触发rsync进行增量同步。rsync的增量同步大致就是在执行初期，remote会将每个dest文件的rolling checksum和checksum 组成列表发给local机器。本地机器将需要同步的文件分成多个chunk，每个chunk有对应的check sum和rolling checksum。这些chunk以rolling checksum 为key，存入hash table中。如果有哈希碰撞就在后面用数组链表来存value（check sum + chunk no）</p><p>前面说到，remote发过来的列表会和本地的进行比对，然后有不同的chunk就会发到remote进行同步。这里用rolling checksum的好处是，正常的checksum计算是每次都是全量的输入计算，但是rolling checksum有点类似于滑动窗口，只需要将当前值减去上一个，再加上下一个的值就可以。</p><h1 id="更好的想法"><a href="#更好的想法" class="headerlink" title="更好的想法"></a>更好的想法</h1><p>其实这是一个比较糙的想法。有很多没有考虑到，一般来说，如果自己本地电脑的配置还不错，装个VMWare15.5.5其实更好一些（这个版本支持同时启动虚拟化），这样新人在配置环境的时候就可以开箱即用了！虽然代价是损失一些服务器运行的资源，毕竟虚拟机里运行服务器资源有限。但是个人开发环境并不需要高并发。</p><p>环境搭建无非是开发环境和部署运行环境。这两个都可以放在一个Docker里，然后通过NET模式 + 虚拟机的端口转发，vscode 用remote的方式连上workspace。</p><p>至于其他人的访问，如果都是同处在一个局域网下改改配置就没问题了。（相关博文在这里可以借鉴下：<a href="https://cloud.tencent.com/developer/article/1599108">https://cloud.tencent.com/developer/article/1599108</a>）然后用Docker配置开发环境和运行服务端，然后用端口转发的方式。</p><p>如果不是在一个局域网下，那么可以用rsync+inotifywait的方式吧。</p><hr><p>推荐两篇讲rsync原理的博文</p><p><a href="https://juejin.cn/post/6874919265917632525#heading-9">https://juejin.cn/post/6874919265917632525#heading-9</a></p><p><a href="https://coolshell.cn/articles/7425.html/comment-page-2#comments">https://coolshell.cn/articles/7425.html/comment-page-2#comments</a></p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>漫谈VCS在游戏中的使用</title>
      <link href="man-tan-vcs-zai-you-xi-zhong-de-shi-yong/"/>
      <url>man-tan-vcs-zai-you-xi-zhong-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="漫谈VCS在游戏中的使用"><a href="#漫谈VCS在游戏中的使用" class="headerlink" title="漫谈VCS在游戏中的使用"></a>漫谈VCS在游戏中的使用</h1><blockquote><p><em>VCS（版本控制系统）</em></p></blockquote><p>基本上大家耳熟能详的就是git和svn这两个。前者是基于分支做管理的，后者是用目录来进行版本管理。从使用上来说，代码更友好的是Git，但是对于游戏项目来说很多都是用SVN，更好管理文件资源。</p><p>最近还用到一个叫Perforce（P4V）的商业VCS软件，也很不错。网上各种VCS资料已经很多了，这里着重讲讲不同的VCS使用上的体验和个人主观臆断的想法。</p><h1 id="切版本的资源开销"><a href="#切版本的资源开销" class="headerlink" title="切版本的资源开销"></a>切版本的资源开销</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p> 每次的开销上，对于一些非文本的文件，例如图像资源、二进制等Git在做分支管理的时候就是会比SVN更慢一些。因为我理解的Git 在每次切换分支的时候，是经过了本地的Git Tree来比对不同分支下的差异，然后根据这些差异来重放的，也就是说Git只存每次提交Diff的内容。但是对于二进制或者是非简单文本内容来说（例如xlsx），Git就没办法分析出Diff内容了，也就是退化到存文件本身。</p><h2 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h2><p>这个是用目录来管理的，就好像不同目录下有不同版本的资源。Git是用分支来隔离，SVN就是用目录了。只要把所有目录都拉下来其实就不存在切换版本的开销了，毕竟换个目录就可以。但是如果要新建一个版本（在Git叫分支），就需要耗费比较多的时间，可以想象成拷贝出一个新的目录。</p><h2 id="P4V"><a href="#P4V" class="headerlink" title="P4V"></a>P4V</h2><p>用Workspace来做隔离，在Config文件里也叫Client。这些workspace都是放在中心话的P4V Server上的，我并没有深究存放的形式是什么样的，但是切版本的话资源开销上也就h是网络开销。需要到P4V Server上去拉取信息。和上述两种都有存放在本地的一些版本信息不同，P4V是全部版本信息都放在服务器上的。</p><h1 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h1><p>如果单论代码管理来说，Git是最好用的，无论是流畅的分支管理，还是各类生态插件的成熟程度。但是一个产品的组成并不是只有代码，也包含了很多非代码资源。在游戏，就包含了：unity资源、配置表格、各类工具等等。</p><p>单论配置表格，一个xlsx文件如何用Git来进行管理呢？Git并不支持对这一类特殊编码文件的diff分析。如果全部包含的来看，最近体验P4V &gt; Git + SVN。</p><p>P4V这里简单讲一下，其实一饿很简单，就是将所有的版本控制的信息都放在P4V的Server上，本地只需要一个拉取配置和客户端就可以拉取信息和读取一些版本信息。</p><p>极具中心化的版本管理的一个问题就是，单点部署的服务端出问题了你的所有版本信息都没办法用了。这是什么意思呢？可以理解的是你失去了.git 文件夹这样。</p><h3 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h3><p>权限管理混乱、服务器资源有限（有待补充）</p><h3 id="如果单点万无一失呢？"><a href="#如果单点万无一失呢？" class="headerlink" title="如果单点万无一失呢？"></a>如果单点万无一失呢？</h3><p>那么好处就很多了，相比于Git和SVN。</p><p>首先，因为是用workspace进行不同用户隔离的，每个用户又可以用Stream的形式从远端拉取指定的分支（原谅我这么叫它，我也不知道官方怎么说），所以这个workspace相当于每个用户独有的.git文件夹（或者.svn），然后Stream 就是remote分支。</p><p>其次，因为数据都是存在服务器上的，所以其他用户想看到你暂存的内容是可以的！这一点我很喜欢。Git有个暂存区的概念，git add 会把文件加入到本地的暂存区里，但是其他用户是看不到的，想看到你的修改需要提交到远端才可以。但是因为版本信息都是放在服务器上的，在P4V上暂存区叫做changelist，git add 操作又称作shelve。这个changelist是可以跨workspace的，也就是可以通过分享自己的changelist id 给其他人，在不提交代码的情况下让其他人看到你的修改内容！</p><p>最后，因为是商用软件，所以在一些开源组件上的支持还挺成熟的。</p>]]></content>
      
      
      <categories>
          
          <category> VCS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于通过cp覆盖so导致coredump</title>
      <link href="guan-yu-tong-guo-cp-fu-gai-so-dao-zhi-coredump/"/>
      <url>guan-yu-tong-guo-cp-fu-gai-so-dao-zhi-coredump/</url>
      
        <content type="html"><![CDATA[<p>| 这个问题的起因是在讨论别人热更方案的过程中发现用cp替换so会出现coredump的问题，这里转载一部分网上的文章同时自己做一个补充。后续补充服务器热更的一些文章吧（如果有时间的话：）</p><h3 id="一、为何cp覆盖进程的动态库-so-会导致coredump？"><a href="#一、为何cp覆盖进程的动态库-so-会导致coredump？" class="headerlink" title="一、为何cp覆盖进程的动态库(so)会导致coredump？"></a>一、为何cp覆盖进程的动态库(so)会导致coredump？</h3><p>先说结论： </p><p>1.应用程序通过```dlopen`` 函数打开so的时候，kernel通过mmap把so加载到进程地址空间，其对应于虚拟内存空间（vma）里的几个page.</p><p><strong>2.在这个so加载过程中loader会把so里面引用的外部符号例如malloc、printf等外部函数解析成真正的虚存地址。</strong></p><p>3.当so被cp覆盖时，确切地说是被trunc（trunc标志会先清空文件内容后打开）时，kernel会把so文件在虚拟内存的页清除掉。</p><p>4.当运行到so里面的代码时，因为虚拟内存的页已经清除掉了，这时会产生一次缺页中断。</p><p>5.缺页中断会导致Kernel从so文件中拷贝对应的页到内存中去，这时候问题出现了： </p><ul><li>a) 如果so里面依赖了外部符号，但是这时的外部符号并没有经过重新解析，kernel只是简单的将我so文件中对应的页拷贝到内存中，当调用到时就产生segment fault</li><li>b) 如果需要的文件偏移大于新的so的地址范围，就会产生bus error.</li></ul><p>其本质原因是cp后的目标inode并没有被改变。在kernel中，是识别文件的方式是通过inode号而不是文件路径，也就是同一个文件路径下同一个名称的文件，在kernel眼中可能是不一样的inode。 </p><p>通过```strace`` 命令 我们可以看到cp的实现是这样的：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">strace</span> <span class="token function">cp</span> new.so old.so <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">|</span> <span class="token function">grep</span> open.*test <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面就a这种情况用代码分析验证下。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//test.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"test1:j=%dn"</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行下面命令生成so文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gcc -fPIC -shared -o libtest.so test.c -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//main.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;dlfcn.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">void</span> <span class="token operator">*</span>lib_handle<span class="token punctuation">;</span>   <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">char</span> <span class="token operator">*</span>error<span class="token punctuation">;</span>   <span class="token comment">//表示要将库装载到内存，准备使用</span>   lib_handle <span class="token operator">=</span> <span class="token function">dlopen</span><span class="token punctuation">(</span><span class="token string">"libtest.so"</span><span class="token punctuation">,</span> RTLD_LAZY<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lib_handle<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%sn"</span><span class="token punctuation">,</span> <span class="token function">dlerror</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment">//获得指定函数(symbol)在内存中的位置(指针)</span>   fn1 <span class="token operator">=</span> <span class="token function">dlsym</span><span class="token punctuation">(</span>lib_handle<span class="token punctuation">,</span> <span class="token string">"test1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>error <span class="token operator">=</span> <span class="token function">dlerror</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%sn"</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fn1:0x%xn"</span><span class="token punctuation">,</span> fn1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   fn2 <span class="token operator">=</span> <span class="token function">dlsym</span><span class="token punctuation">(</span>lib_handle<span class="token punctuation">,</span> <span class="token string">"test2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>error <span class="token operator">=</span> <span class="token function">dlerror</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>     <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%sn"</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fn2:0x%xn"</span><span class="token punctuation">,</span> fn2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">dlclose</span><span class="token punctuation">(</span>lib_handle<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行命令：</p><pre class="line-numbers language-none"><code class="language-none">gcc -o main main.c -ldl -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先进行测试1，断点设置在27行，fn1()执行之前</p><pre class="line-numbers language-gdb" data-language="gdb"><code class="language-gdb">Breakpoint 1, main () at main.c:27//这时我们在另外一个终端执行下面的命令//cp libtest.so libtest2.so//cp libtest2.so libtest.so27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fn1();(gdb) stest1 () at test.c:44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int j=0; //没有报错(gdb) n5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("test1:j=%dn", j);(gdb) n//出错，因为引用了printf外部函数，而全局符号表并没有经过重新解析，找不到printf函数Program received signal SIGSEGV, Segmentation fault.0x00000396 in ?? ()(gdb) bt#0&nbsp; 0x00000396 in ?? ()#1&nbsp; 0xb7fd84aa in test1 () at test.c:5#2&nbsp; 0x08048622 in main () at main.c:27<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面进行测试2，断点设置在38行，fn2执行之前。</p><p>然后在另一个终端执行和测试1相同的cp操作</p><pre class="line-numbers language-none"><code class="language-none">Breakpoint 1, main () at main.c:3838&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fn2();(gdb) stest2 () at test.c:1010&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int j=1;(gdb) n12&nbsp; }(gdb) nmain () at main.c:4040&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dlclose(lib_handle);(gdb) n42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;(gdb)43&nbsp; }//程序正常结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这两个测试例子中，我们可以得到这样的结论：</p><p>当用新的so文件去覆盖老的so文件时候：</p><p>A)如果so里面依赖了外部符号，程序会core掉</p><p>B)如果so里面没有依赖外部符号，so部分代码可以正常运行</p><h3 id="二、中为什么动态换bin程序不会core而换so容易core？"><a href="#二、中为什么动态换bin程序不会core而换so容易core？" class="headerlink" title="二、中为什么动态换bin程序不会core而换so容易core？"></a>二、中为什么动态换bin程序不会core而换so容易core？</h3><p>  Linux中， 如果一个程序正在运行中，那么要动态替换程序，<code>cp new old</code>, 会发现报“text file busy”。用 strace 查看cp命令输出，会发现报：open old的时候，用了 O_WRONLY|O_TRUNC，open 返回 ETXTBSY (Text file busy)。也就是说，这时候这个文件已经是不可更改的了。如果用 cp -rf 复制，检验下又会发现，其实复制得到的文件的文件虽然还是原来的名字，但是 inode 已经变了。也就是说，cp -rf 其实还是没有真正的覆盖成功。</p><p>  这些都是为什么呢？首先不得不说下linux中二进制文件执行的时候的延迟加载。也就是说如果一个bin文件并不会一次性加载进内存，而是按需逐步加载的。为了防止bin文件修改后动态按需load的时候出错，所以内核系统就会把文件锁死，使得不能随便更改。这解释了为什么会“text file busy”。同时也说明了，rm + cp方式动态替换程序的时候，或者动态删除 bin 的时候，“延迟加载”不会导致程序出core。因为文件的inode还没有释放，等于说原文件还存在。</p><p>  对于 .so 动态库文件，动态覆盖容易导致出core，是因为系统没有对so作特殊保护，不会”text file busy”之故。</p><p>​        还有一点想说的是编写so文件不应该将内存对象暴露到外部，避免热更的时候发生内存泄漏。通过so热更的第一步就是用install替换so文件，之后要有一个客户端或者是服务器上设置一个哨兵触发程序reload（自己编写的函数，实际上就是重新加载so）so文件。 这样简单的so热更就完成了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ruanyifeng.com/blog/2011/12/inode.html">https://www.ruanyifeng.com/blog/2011/12/inode.html</a> 理解inode</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes学习笔记0-从零搭建k8s集群</title>
      <link href="kubernetes-xue-xi-bi-ji-0-cong-ling-da-jian-k8s-ji-qun/"/>
      <url>kubernetes-xue-xi-bi-ji-0-cong-ling-da-jian-k8s-ji-qun/</url>
      
        <content type="html"><![CDATA[<h1 id="先从实践开始吧"><a href="#先从实践开始吧" class="headerlink" title="先从实践开始吧"></a>先从实践开始吧</h1><p>这是一个比较烧钱的方法， 我直接在腾讯云上开了两台双核4G的centos服务器。 （只要设置服务器是双核4G，非大陆地区的网络，其他默认即可，怎么便宜怎么来）</p><p>网上有很多是虚拟机的，因为某些原因不方便用虚拟机的网络，同时因为可以白嫖腾讯云的服务器，就直接买了两台~ </p><p>下面参考博文中也有虚拟机配置集群的教程，没有试过，看着挺靠谱的样子~</p><p>在这里建议，买服务器如果是为了编程，强烈建议买国外的节点，很多镜像源都不用配置了，对于开发来说实在太友好了！当然访问速度也很差，如果有梯子就另当别论了，梯子相关的教程也在我的博客里，大家可以找一下。</p><p>配置： 双核（必须，没有双核就装不了）</p><p>搭建harbor教程： （这个只是个镜像仓库，也可以不装。） <a href="https://zhuanlan.zhihu.com/p/31483386">https://zhuanlan.zhihu.com/p/31483386</a></p><h3 id="公共配置（所有机器都要安装的）"><a href="#公共配置（所有机器都要安装的）" class="headerlink" title="公共配置（所有机器都要安装的）"></a>公共配置（所有机器都要安装的）</h3><p>（可选）一键服务器环境脚本（这是我比较喜欢的环境配置，大家酌情使用）只是简单的安装了zsh和vim的配置</p><pre class="line-numbers language-none"><code class="language-none">sudo yum install git -ysudo yum install zsh -ygit clone https://github.com/chxuan/vimplus.git ~/.vimpluscd ~/.vimplus./install.sh //不加sudosh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（可选）设置主机名称，这样后面加到集群里面方便辨认</p><pre class="line-numbers language-none"><code class="language-none">hostnamectl set-hostname 主机名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装docker（直接用centos的yum安装的docker 实际上是podman，没有守护进程的）： <a href="https://zhuanlan.zhihu.com/p/286845061">https://zhuanlan.zhihu.com/p/286845061</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> -fsSL https://get.docker.com -o get-docker.sh <span class="token operator">&amp;&amp;</span> <span class="token function">sh</span> get-docker.shsystemctl start docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来是Kubernetes</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 官方 的方法</span><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/yum.repos.d/kubernetes.repo</span>[kubernetes]name=Kubernetesbaseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\<span class="token variable">$basearch</span>enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpgexclude=kubelet kubeadm kubectlEOF</span><span class="token comment"># 建议用下面这个库，用上面的发现后初始化结束后会出现cni接口初始化失败的问题，看上去是版本不对 cni 版本不对，读取flannel 配置会出问题。</span><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/yum.repos.d/kubernetes.repo</span>[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF</span><span class="token comment"># 将 SELinux 设置为 permissive 模式（相当于将其禁用）</span><span class="token function">sudo</span> setenforce <span class="token number">0</span><span class="token function">sudo</span> <span class="token function">sed</span> -i <span class="token string">'s/^SELINUX=enforcing$/SELINUX=permissive/'</span> /etc/selinux/config<span class="token function">sudo</span> yum <span class="token function">install</span> -y kubelet kubeadm kubectl --disableexcludes<span class="token operator">=</span>kubernetes<span class="token function">sudo</span> yum <span class="token function">install</span> kubernetes-cni -y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我将分为<strong>master</strong>节点和<strong>node</strong>节点来说明。</p><h2 id="master节点"><a href="#master节点" class="headerlink" title="master节点"></a>master节点</h2><p>安裝kubeadm</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> --now kubeletkubeadm init --ignore-preflight-errors<span class="token operator">=</span>all <span class="token punctuation">\</span>  --pod-network-cidr<span class="token operator">=</span><span class="token number">10.244</span>.0.0/16 <span class="token punctuation">\</span> <span class="token comment"># 这个值是后面安装flannel里用到的.</span>  --apiserver-advertise-address<span class="token operator">=</span>服务器内网ip<span class="token comment">## !!!!初始化结束后会打印出kubeadm join .... 这段命令，需要记下来，后面加入节点需要用到。</span><span class="token function">mkdir</span> -p <span class="token environment constant">$HOME</span>/.kube<span class="token function">sudo</span> <span class="token function">cp</span> -i /etc/kubernetes/admin.conf <span class="token environment constant">$HOME</span>/.kube/config<span class="token function">sudo</span> <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> <span class="token environment constant">$HOME</span>/.kube/config<span class="token builtin class-name">export</span> <span class="token assign-left variable">KUBECONFIG</span><span class="token operator">=</span>/etc/kubernetes/admin.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">swapoff -a <span class="token operator">&amp;&amp;</span> systemctl daemon-reload <span class="token operator">&amp;&amp;</span> systemctl restart kubelet  <span class="token operator">&amp;&amp;</span> iptables -F <span class="token operator">&amp;&amp;</span> iptables -t nat -F <span class="token operator">&amp;&amp;</span> iptables -t mangle -F <span class="token operator">&amp;&amp;</span> iptables -X<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>K8s集群初始化成功后使用下面命令检查一下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl get nodes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看节点信息时报错</p><p>报错信息：</p><pre class="line-numbers language-none"><code class="language-none">The connection to the server localhost:8080 was refused - did you specify the right host or port<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">mkdir</span> -p <span class="token environment constant">$HOME</span>/.kube<span class="token function">sudo</span> <span class="token function">cp</span> -i /etc/kubernetes/admin.conf <span class="token environment constant">$HOME</span>/.kube/config<span class="token function">sudo</span> <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> <span class="token environment constant">$HOME</span>/.kube/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>再次查看节点信息即可看到：</p><pre class="line-numbers language-none"><code class="language-none">kubectl get nodes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现节点的状态是NoReady。使用下面命令查看是哪里出错了</p><pre class="line-numbers language-none"><code class="language-none">kebectl describe node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现报错： </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">network plugin is not ready: cni config uninitialized <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可能是cni网络接口插件没有安装上 。如果是/opt/cni/下没有bin文件，就装一个。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> <span class="token function">mkdir</span> -p /opt/cni/bin  <span class="token builtin class-name">cd</span> /opt/cni/bin                                                                                                         <span class="token function">wget</span> https://github.com/containernetworking/plugins/releases/download/v0.9.1/cni-plugins-linux-arm64-v0.9.1.tgz  <span class="token function">tar</span> -zxvf cni-plugins-linux-arm64-v0.9.1.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正常来说是因为flannel 插件没装，默认是没有装的。 使用下面的命令安装</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>装了之后发现还是NoReady，使用jouralctl -f -u kubelet.service 看到下面的情况： </p><p>如果出现以下日志</p><pre class="line-numbers language-none"><code class="language-none">"Error validating CNI config list" configList="{\n  \"name\": \"cbr0\",\n  \"cniVersion\": \"0.3.1\",\n  \"plugins\": [\n    {\n      \"type\": \"flannel\",\n      \"delegate\": {\n        \"hairpinMode\": true,\n        \"isDefaultGateway\": true\n      }\n    },\n    {\n      \"type\": \"portmap\",\n      \"capabilities\": {\n        \"portMappings\": true\n      }\n    }\n  ]\n}\n" err="[failed to find plugin \"flannel\" in path [/opt/cni/bin] failed to find plugin \"portmap\" in path [/opt/cni/bin]]"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 我这边的原因是安装的CNI组件版本不对，解析出问题了，需要执行： </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span> /etc/yum.repos.d/kubernetes.repo</span>[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF</span>yum clean allyum <span class="token function">install</span> kubernetes-cni -y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后出现查看节点信息，出现这样就大功告成了。</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/image-20210701190236287.png" alt="master安装成功图"></p><h2 id="node节点"><a href="#node节点" class="headerlink" title="node节点"></a>node节点</h2><p>下面这些命令都是在node节点的机器上执行。 </p><p>输入刚刚kubeadm init输出的命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubeadm <span class="token function">join</span> xx.xx.xx.xx:6443 --token xxxxx.xxxxxxxx <span class="token punctuation">\</span>    --discovery-token-ca-cert-hash sha256:xxxxxxxxxxxxxxxxxxxxxx       <span class="token comment"># 上面的ip是内网IP</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果忘记了，也可以调用下面命令获得token </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubeadm token list <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面的命令获得sha256</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt <span class="token operator">|</span> openssl rsa -pubin -outform der <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>/dev/null <span class="token operator">|</span>  openssl dgst -sha256 -hex <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/^.* //'</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后节点就加入到集群里了。过一会儿就会出现</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/image-20210701191108860.png" alt="image-20210701191108860"></p><h2 id="重装"><a href="#重装" class="headerlink" title="重装"></a>重装</h2> <pre class="line-numbers language-none"><code class="language-none">kubeadm reset <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>手动删除东西： </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#删除net.d</span><span class="token function">rm</span> -rf /etc/cni/net.d<span class="token comment">#重置iptables</span>iptables -F <span class="token operator">&amp;&amp;</span> iptables -t nat -F <span class="token operator">&amp;&amp;</span> iptables -t mangle -F <span class="token operator">&amp;&amp;</span> iptables -Xsysctl net.bridge.bridge-nf-call-iptables<span class="token operator">=</span><span class="token number">1</span><span class="token comment"># 手动执行以下命令来清除对应的残余网卡信息：</span><span class="token function">sudo</span> <span class="token function">ip</span> <span class="token function">link</span> del cni0<span class="token function">sudo</span> <span class="token function">ip</span> <span class="token function">link</span> del flannel.1<span class="token comment"># 删除 $HOME/.kube/config</span><span class="token function">rm</span> -rf <span class="token environment constant">$HOME</span>/.kube/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="https://blog.csdn.net/qq_20143059/article/details/116156448">https://blog.csdn.net/qq_20143059/article/details/116156448</a></p><p><a href="https://blog.csdn.net/qq_34857250/article/details/82562514">https://blog.csdn.net/qq_34857250/article/details/82562514</a></p><p><a href="https://www.cnblogs.com/potato-chip/p/13973760.html">https://www.cnblogs.com/potato-chip/p/13973760.html</a></p><p><a href="https://juejin.cn/post/6844903652386144263">https://juejin.cn/post/6844903652386144263</a></p><p><a href="https://blog.csdn.net/weixin_42072280/article/details/112464472">https://blog.csdn.net/weixin_42072280/article/details/112464472</a></p><p><a href="https://last2win.com/2020/01/30/k8s-install-and-use-and-fix-bug/#docker">https://last2win.com/2020/01/30/k8s-install-and-use-and-fix-bug/#docker</a></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes学习笔记1-容器编排</title>
      <link href="kubernetes-xue-xi-bi-ji-1-rong-qi-bian-pai/"/>
      <url>kubernetes-xue-xi-bi-ji-1-rong-qi-bian-pai/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes中的进程组—Pod"><a href="#Kubernetes中的进程组—Pod" class="headerlink" title="Kubernetes中的进程组—Pod"></a>Kubernetes中的进程组—Pod</h1><h1 id="Deployment-——"><a href="#Deployment-——" class="headerlink" title="Deployment ——"></a>Deployment ——</h1><h1 id="ReplicaSet-——-版本控制"><a href="#ReplicaSet-——-版本控制" class="headerlink" title="ReplicaSet —— 版本控制"></a>ReplicaSet —— 版本控制</h1><h1 id="容器状态的好助手-——-StatefulSet"><a href="#容器状态的好助手-——-StatefulSet" class="headerlink" title="容器状态的好助手 —— StatefulSet"></a>容器状态的好助手 —— StatefulSet</h1><h2 id="容器化守护进程——-DaemonSet"><a href="#容器化守护进程——-DaemonSet" class="headerlink" title="容器化守护进程—— DaemonSet"></a>容器化守护进程—— DaemonSet</h2><p>DaemonSet的作用就是在每一个节点里运行一个Daemon Pod，它会在节点加入集群后自动的创建出来，生命周期是跟随节点的。<strong>更重要的是，跟其他编排对象不一样，DaemonSet 开始运行的时机，很多时候比整个 Kubernetes 集群出现的时机都要早。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker深入理解</title>
      <link href="docker-shen-ru-li-jie/"/>
      <url>docker-shen-ru-li-jie/</url>
      
        <content type="html"><![CDATA[<p>| 知识来自于极客时间 张磊老师的《深入剖析Kubernetes》，这里是作为学习笔记存放。</p><h1 id="Docker-深入理解"><a href="#Docker-深入理解" class="headerlink" title="Docker 深入理解"></a>Docker 深入理解</h1><h2 id="虚拟机与容器"><a href="#虚拟机与容器" class="headerlink" title="虚拟机与容器"></a>虚拟机与容器</h2><p>以前，想要搭建一个开发环境或者是博客，就需要找一篇教程，按部就班的一步步走下来。后来我想能不能把整个系统打包下来，每次到新的电脑上，直接下载这个系统装上去就行了。如果真的打包一个系统肯定不可能，那么打包一个虚拟机还是很容易的。</p><p>虚拟机本身就是模拟出一整套的硬件和系统，可以说虚拟机里的所作所为与宿主机没有任何关系。缺点就是性能消耗太大了，要知道，在一个操作系统上跑一个另外一个完整的操作系统这件事本身就占据了极大的资源开支，更别说还需要在虚拟机上运行程序。常见的虚拟机有VMware。</p><p>如果说要把虚拟机的所有内容打包下来给别人使用，这个压缩包也太大了。起码5G以上。有没有什么办法可以尽可能的减少一些我不需要的内容呢？ 比如像操作系统这样的我就是不想需要的，因为我能运行开发环境或者博客，肯定已经有了操作系统了。</p><p>Docker 容器应运而生。容器技术本身就是通过操作系统的隔离（namespace）做出了一个完整的rootfs文件系统，里面包含了应用程序所需要的依赖，对于程序最大的依赖而言就是操作系统，其与宿主机共享使用一个内核，通过CGroup（control group）来对应用程序能够占用到的资源进行限制。</p><p>下图清晰的说明了容器和虚拟机的区别。</p><p>这幅图的左边，画出了虚拟机的工作原理。其中，名为 Hypervisor 的软件是虚拟机最主要的部分。它通过硬件虚拟化功能，模拟出了运行一个操作系统需要的各种硬件，比如 CPU、内存、I/O 设备等等。然后，它在这些虚拟的硬件上安装了一个新的操作系统，即 Guest OS。</p><p>这样，用户的应用进程就可以运行在这个虚拟的机器中，它能看到的自然也只有 Guest OS 的文件和目录，以及这个机器里的虚拟设备。这就是为什么虚拟机也能起到将不同的应用进程相互隔离的作用。</p><p>而这幅图的右边，则用一个名为 Docker Engine 的软件替换了 Hypervisor。这也是为什么，很多人会把 Docker 项目称为“轻量级”虚拟化技术的原因，实际上就是把虚拟机的概念套在了容器上。</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/%E4%B8%8B%E8%BC%89.png" alt="虚拟机和容器的区别"></p><p><strong>“敏捷”和“高性能”是容器相较于虚拟机最大的优势，也是它能够在 PaaS 这种更细粒度的资源管理平台上大行其道的重要原因。</strong></p><p>不过，有利就有弊，基于 Linux Namespace 的隔离机制相比于虚拟化技术也有很多不足之处，其中最主要的问题就是：<strong>隔离得不彻底。</strong></p><p>相比于虚拟化技术，Linux 的隔离机制也有诸多限制，首要的就是内核使用的任然是同一个，其次是很多资源和兑现无法被Namespace化，例如时间。</p><h2 id="隔离与限制"><a href="#隔离与限制" class="headerlink" title="隔离与限制"></a>隔离与限制</h2><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>下面来写一个简单的容器： </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _GNU_SOURCE#include &lt;sys/mount.h&gt; #include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;sched.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#define STACK_SIZE (1024 * 1024)static char container_stack[STACK_SIZE];char* const container_args[] = {  "/bin/bash",  NULL}; int container_main(void* arg){    printf("Container - inside the container!\n");  execv(container_args[0], container_args);  printf("Something's wrong!\n");  return 1;} int main(){  printf("Parent - start a container!\n");  int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWNS | SIGCHLD , NULL);  waitpid(container_pid, NULL, 0);  printf("Parent - container stopped!\n");  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码的功能非常简单：在 main 函数里，我们通过 clone() 系统调用创建了一个新的子进程 container_main，并且声明要为它启用 Mount Namespace（即：CLONE_NEWNS 标志）。</p><p>而这个子进程执行的，是一个“/bin/bash”程序，也就是一个 shell。所以这个 shell 就运行在了 Mount Namespace 的隔离环境中。</p><p>编译启动后发现我们看到的文件系统和宿主机完全一样。</p><p>这是怎么回事呢？</p><p>仔细思考一下，你会发现这其实并不难理解：<strong>Mount Namespace 修改的，是容器进程对文件系统“挂载点”的认知</strong>。但是，这也就意味着，只有在“挂载”这个操作发生之后，进程的视图才会被改变。而在此之前，新创建的容器会直接继承宿主机的各个挂载点。</p><p>也就是说，我们在容器进程执行前可以添加重新挂载/tmp目录的操作。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int container_main(void* arg){  printf("Container - inside the container!\n");  // 如果你的机器的根目录的挂载类型是 shared，那必须先重新挂载根目录  // mount("", "/", NULL, MS_PRIVATE, "");  mount("none", "/tmp", "tmpfs", 0, "");  execv(container_args[0], container_args);  printf("Something's wrong!\n");  return 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动运行后发现/tmp目录下是没有东西的。 </p><p><strong>这就是 Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效。</strong></p><h3 id="CGroup"><a href="#CGroup" class="headerlink" title="CGroup"></a>CGroup</h3><h2 id="容器镜像"><a href="#容器镜像" class="headerlink" title="容器镜像"></a>容器镜像</h2><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>容器技术中一个非常重要的概念，即：<strong>容器是一个“单进程”模型。</strong></p><p>由于一个容器的本质就是一个进程，用户的应用进程实际上就是容器里 PID=1 的进程，也是其他后续创建的所有进程的父进程。这就意味着，在一个容器中，你没办法同时运行两个不同的应用，除非你能事先找到一个公共的 PID=1 的程序来充当两个不同应用的父进程，这也是为什么很多人都会用 systemd 或者 supervisord 这样的软件来代替应用本身作为容器的启动进程。</p><p>这是因为容器本身的设计，就是希望容器和应用能够<strong>同生命周期</strong>，这个概念对后续的容器编排非常重要。否则，一旦出现类似于“容器是正常运行的，但是里面的应用早已经挂了”的情况，编排系统处理起来就非常麻烦了。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于CI/CD 持续部署、交付的一些想法吧</title>
      <link href="guan-yu-cicd-chi-xu-bu-shu-jiao-fu-de-yi-xie-xiang-fa-ba/"/>
      <url>guan-yu-cicd-chi-xu-bu-shu-jiao-fu-de-yi-xie-xiang-fa-ba/</url>
      
        <content type="html"><![CDATA[<h1 id="关于CI-CD-持续部署、交付的一些想法吧"><a href="#关于CI-CD-持续部署、交付的一些想法吧" class="headerlink" title="关于CI/CD 持续部署、交付的一些想法吧"></a>关于CI/CD 持续部署、交付的一些想法吧</h1><p>不得不说，这两样东西大大的节约了我博客部署的时间，以前我需要频繁的</p><pre class="line-numbers language-none"><code class="language-none">hexo cleannhexo g hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>才可以部署上我的博客。最糟糕的时候就是我转换到一个新的电脑/开发环境，想要写点博客内容，如果博客源程序没有在github上的话就没办法开始写作，即使是在GitHub上的话也要经过提交，之后再敲入上面的三个命令才可以上传一篇新的文章在我博客上。</p><h2 id="时代变了，大人"><a href="#时代变了，大人" class="headerlink" title="时代变了，大人"></a>时代变了，大人</h2><p>现在用上了CI/CD，来到一个崭新的电脑上，我仅仅需要<code>git clone</code>  然后写文章，最后提交就可以部署好所有的东西了，背后的GitAction会自动化的执行脚本，将博客清理缓存，然后生成文章，最后部署到实际的托管网站上。 </p><p>在我看来，CI/CD就是类似于流水线一样，把原来的一系列操作缩影成脚本一样的东西，程序员只要提交上去流水线程序会自动的将后面需要执行的操作自动化的执行完成，中间如果出现故障的话就会终止。 当然，这一系列自动化动作的起点就是需要一个明确的动作来触发流水线执行，在我这边的例子就是感知到当前Git仓库有新的提交，就会触发流水线重新构造。还没有仔细看GitAction里面的参数设置，我猜测应该还有一些其他的触发条件可供我们设置吧。</p><p>不得不说，有了这个省心太多了，尤其是在一个新的地方想要写博客的时候就不用担心需要重新搭建环境什么了。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021-5-14 晴. 重新连接</title>
      <link href="2021-5-14-qing-chong-xin-lian-jie/"/>
      <url>2021-5-14-qing-chong-xin-lian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="阔别一年，重新开始写博客"><a href="#阔别一年，重新开始写博客" class="headerlink" title="阔别一年，重新开始写博客"></a>阔别一年，重新开始写博客</h1><p>大概从去年开始实习之后就很少有时间写博客了。主要是因为本来博客从typecho迁移到hexo这个过程是在公司里面做的，离职的时候忘记把源码带走了，只留下生成后的网页，一年多以来的心血差点化为乌有。还好有vultr的快照在，回去之后重新买了一小时的服务器（vultr真好啊，按小时计费），把数据库给download下来，再用工具转换为Markdown格式的。实际上这个过程我断断续续花了近半年，倒不是很难，主要还是自己太懒了。其实2020下半年大部分都还是在摸鱼，把项目做完后休息了快半年了。经常有想法写博客，把这半年来的技术积累记录下来，但是看到博客源码都没了，实在提不起笔，也能体会到雷军大佬代码被删了之后专心做产品经理的心情了，或许有些许相似。</p><p>还好，我还是比较幸运的，有备份。 为什么这么久才开始写博客呢？ 其实每次一想到自己的博客网站，都不禁联系到小时候杂草丛生的破旧学校，很是心疼，但是也仅仅是想法上而已，哈哈哈哈。</p><p>不过刚好一年咯，终于还是把博客重新整了一遍。参考了一个前端大佬的博客，用在github和coding双线部署，在dnspod里把线路解析为境内和境外，这样国内访问应该不会太慢了。这个步骤整了快一下午吧，主要还是coding这网站的一些适配性有点差，再加上界面和以前太不一样了，熟悉还是花了点时间。不过客服还是很友善，很快帮我解决了问题，真棒~</p><p>然后又用了GitHub Action 来做持续交付，这样就不用多敲那几行hexo g &amp;&amp; hexo d了，直接可以git push 就好了，GitHub上有流水线可以自动部署网站。其实节省了也就一点功夫，但是做完之后成就感满满的。</p><h1 id="所以这一年来我在做什么？"><a href="#所以这一年来我在做什么？" class="headerlink" title="所以这一年来我在做什么？"></a>所以这一年来我在做什么？</h1><p>分为三个部分吧。</p><ol><li><p>暑期实习</p><p>主要还是做部门里面 转正的项目。有空的时候真的想把当时的一些心得记录下来，学到蛮多东西的， 包括一些思维上的转变。 当然，除了代码以外还有一些比较有趣的事情，比如说超新星的采访，里面有我哎，认识的应该都能一眼找出来。<a href="https://www.bilibili.com/video/BV1wD4y1U7DP">https://www.bilibili.com/video/BV1wD4y1U7DP</a></p></li><li><p>玩 ~</p><p>其实本来暑期实习回去后还想学习学习， 可惜满脑子只想着玩，感觉完了半年的LOL。这个游戏太棒了！我这半年感觉把大学前几年没玩的次数都玩了一遍，然后还有打排球，打了一个小比赛什么的balabla。（OS:后面这项运动把我劝退了很久。） </p></li><li><p>毕业实习</p><p>这就是今年上半年的事情了。 不得不说，深圳这边的房价太高了，劝退。其实大部分时间还是在做MQ的事情，也就有了博客里面那篇RabbitMQ的总结文章，这篇我写了很久的，把囊括了很多网上零散的一些知识，当然仅仅是涉及知识层面的了，实操还是懒得写。最也总结了一些关于云原生的东西，感觉有空的时候还是记录一下。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>发现很久不写文字， 语言组织能力越来越差了，一句话的内容只知道表述出关键的几个词语，连接词和介词都不太会用，泪目了。写这篇的时候座位上方的水管又喷水了。。去年也是，今年换了座位还是。。怎么这么有缘。。。。泪目了。</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>容器相关名词解释</title>
      <link href="rong-qi-xiang-guan-ming-ci-jie-shi/"/>
      <url>rong-qi-xiang-guan-ming-ci-jie-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="容器相关名词解释"><a href="#容器相关名词解释" class="headerlink" title="容器相关名词解释"></a>容器相关名词解释</h1><h2 id="Helm-和-Chart"><a href="#Helm-和-Chart" class="headerlink" title="Helm 和 Chart"></a>Helm 和 Chart</h2><p><a href="http://helm.sh/">Helm</a> 是一个 Kubernetes 应用的包管理工具，用来管理 <a href="https://github.com/helm/charts">chart</a>——预先配置好的安装包资源，有点类似于 Ubuntu 的 APT 和 CentOS 中的 YUM。2019 年 11 月 13 日，<a href="https://helm.sh/blog/helm-3-released/">Helm 3 发布</a>，2020 年 4 月 30 日，从 CNCF 中<a href="https://helm.sh/blog/celebrating-helms-cncf-graduation/">毕业</a>。本文基于 Helm 3。</p><p>Helm chart 是用来封装 Kubernetes 原生应用程序的 YAML 文件，可以在你部署应用的时候自定义应用程序的一些 metadata，便与应用程序的分发。</p><p>Helm 和 chart 的主要作用是：</p><ul><li>应用程序封装</li><li>版本管理</li><li>依赖检查</li><li>便于应用程序分发</li></ul><p>下面是 Helm 的架构图。</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/helm-chart.png" alt="helm-chart"></p><p>Helm 可以安装本地或者远程的 chart，当 chart 安装到 Kubernetes 中后就会创建一个 release，每次更新该 chart 的配置并执行 <code>helm upgrade</code>， release 的版本数就会加 1。同一个 chart 可以部署多次。</p><h2 id="安装-Helm"><a href="#安装-Helm" class="headerlink" title="安装 Helm"></a>安装 Helm</h2><p><strong>前提要求</strong></p><ul><li>Kubernetes 1.5 以上版本</li><li>执行 helm 命令的主机可以访问到 Kubernetes 集群</li></ul><p>请参考 <a href="https://helm.sh/docs/intro/install/">Helm 官方文档</a>安装，对于 Mac 用户可以直接运行 <code>brew install helm</code> 安装即可。</p><h2 id="Chart-说明"><a href="#Chart-说明" class="headerlink" title="Chart 说明"></a>Chart 说明</h2><p>下面我们将一步步创建一个 chart 来说明其组织结构。</p><p>首先使用 <code>helm create mychart</code> 创建一个名为 <code>mychart</code> 的示例，我们再使用 <code>tree mychart</code> 命令看一下 chart 的目录结构。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mychart├── Chart.yaml├── charts <span class="token comment"># 该目录保存其他依赖的 chart（子 chart）</span>├── templates <span class="token comment"># chart 配置模板，用于渲染最终的 Kubernetes YAML 文件</span>│   ├── NOTES.txt <span class="token comment"># 用户运行 helm install 时候的提示信息</span>│   ├── _helpers.tpl <span class="token comment"># 用于创建模板时的帮助类</span>│   ├── deployment.yaml <span class="token comment"># Kubernetes deployment 配置</span>│   ├── ingress.yaml <span class="token comment"># Kubernetes ingress 配置</span>│   ├── service.yaml <span class="token comment"># Kubernetes service 配置</span>│   ├── serviceaccount.yaml <span class="token comment"># Kubernetes serviceaccount 配置</span>│   └── tests│       └── test-connection.yaml└── values.yaml <span class="token comment"># 定义 chart 模板中的自定义配置的默认值，可以在执行 helm install 或 helm update 的时候覆盖</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上仅为 helm 为我们自动创建的目录结构，我们还可以在 <code>templates</code> 目录加其他 Kubernetes 对象的配置，比如 <code>ConfigMap</code>、<code>DaemonSet</code> 等。</p><p>我们查看下使用 <code>helm create</code> 命令自动生成的 <code>templates/service.yaml</code> 文件。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> include "mychart.fullname" . <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> include "mychart.labels" . <span class="token punctuation">|</span> nindent 4 <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Values.service.type <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Values.service.port <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> http      <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP      <span class="token key atrule">name</span><span class="token punctuation">:</span> http  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> include "mychart.selectorLabels" . <span class="token punctuation">|</span> nindent 4 <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到其中有很多<code>{{ }}</code> 包围的字段，这是使用的 <a href="https://golang.org/pkg/text/template/">Go template</a> 创建的自定义字段，其中 <code>mychart</code> 开头的都是在 <code>_helpers.tpl</code> 中生成的定义。</p><p>例如 <code>_helpers.tpl</code> 中对 <code>chart.fullname</code> 的定义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token comment">/*Create a default fully qualified app name.We truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).If release name contains chart name it will be used as a full name.*/</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span> define <span class="token string">"mychart.fullname"</span> <span class="token operator">-</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span> <span class="token keyword">if</span> <span class="token punctuation">.</span>Values<span class="token punctuation">.</span>fullnameOverride <span class="token operator">-</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span> <span class="token punctuation">.</span>Values<span class="token punctuation">.</span>fullnameOverride <span class="token operator">|</span> trunc <span class="token number">63</span> <span class="token operator">|</span> trimSuffix <span class="token string">"-"</span> <span class="token operator">-</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span> $name <span class="token operator">:=</span> <span class="token keyword">default</span> <span class="token punctuation">.</span>Chart<span class="token punctuation">.</span>Name <span class="token punctuation">.</span>Values<span class="token punctuation">.</span>nameOverride <span class="token operator">-</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span> <span class="token keyword">if</span> contains $name <span class="token punctuation">.</span>Release<span class="token punctuation">.</span>Name <span class="token operator">-</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span> <span class="token punctuation">.</span>Release<span class="token punctuation">.</span>Name <span class="token operator">|</span> trunc <span class="token number">63</span> <span class="token operator">|</span> trimSuffix <span class="token string">"-"</span> <span class="token operator">-</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span> printf <span class="token string">"%s-%s"</span> <span class="token punctuation">.</span>Release<span class="token punctuation">.</span>Name $name <span class="token operator">|</span> trunc <span class="token number">63</span> <span class="token operator">|</span> trimSuffix <span class="token string">"-"</span> <span class="token operator">-</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span> end <span class="token operator">-</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span> end <span class="token operator">-</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span> end <span class="token operator">-</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们再看下 <code>values.yaml</code> 文件中有这样的一段配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">service</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> ClusterIP  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在使用 <code>helm install</code> 或 <code>helm update</code> 时，会渲染 <code>templates/service.yaml</code> 文件中的 <code>{{ .Values.service.type }}</code> 和 <code>{{ .Values.service.port }}</code> 的值。</p><h2 id="使用-Helm"><a href="#使用-Helm" class="headerlink" title="使用 Helm"></a>使用 Helm</h2><p>Helm 常用命令如下：</p><ul><li><code>helm create</code>：在本地创建新的 chart；</li><li><code>helm dependency</code>：管理 chart 依赖；</li><li><code>helm intall</code>：安装 chart；</li><li><code>helm lint</code>：检查 chart 配置是否有误；</li><li><code>helm list</code>：列出所有 release；</li><li><code>helm package</code>：打包本地 chart；</li><li><code>helm repo</code>：列出、增加、更新、删除 chart 仓库；</li><li><code>helm rollback</code>：回滚 release 到历史版本；</li><li><code>helm pull</code>：拉取远程 chart 到本地；</li><li><code>helm search</code>：使用关键词搜索 chart；</li><li><code>helm uninstall</code>：卸载 release；</li><li><code>helm upgrade</code>：升级 release；</li></ul><p>使用 <code>helm -h</code> 可以查看 Helm 命令行使用详情，请参考 <a href="https://helm.sh/docs/helm/helm/">Helm 文档</a>。</p><h3 id="安装-chart"><a href="#安装-chart" class="headerlink" title="安装 chart"></a>安装 chart</h3><p>安装 chart 的命令格式为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">helm <span class="token function">install</span> <span class="token punctuation">[</span>NAME<span class="token punctuation">]</span> <span class="token punctuation">[</span>CHART<span class="token punctuation">]</span> <span class="token punctuation">[</span>flags<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 安装本地 chart</span>helm <span class="token function">install</span> -f myvalues.yaml myredis ./redis<span class="token comment"># 指定变量</span>helm <span class="token function">install</span> --set <span class="token assign-left variable">name</span><span class="token operator">=</span>prod myredis ./redis<span class="token comment"># 指定变量的值为 string 类型</span>helm <span class="token function">install</span> --set-string <span class="token assign-left variable">long_int</span><span class="token operator">=</span><span class="token number">1234567890</span> myredis ./redis<span class="token comment"># 指定引用的文件地址</span>helm <span class="token function">install</span> --set-file <span class="token assign-left variable">my_script</span><span class="token operator">=</span>dothings.sh myredis ./redis<span class="token comment"># 同时指定多个变量</span>helm <span class="token function">install</span> --set <span class="token assign-left variable">foo</span><span class="token operator">=</span>bar --set <span class="token assign-left variable">foo</span><span class="token operator">=</span>newbar  myredis ./redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中：</p><ul><li><code>myvalues.yaml</code>：自定义变量配置文件；</li><li><code>myredis</code>：release 名称；</li><li><code>./redis</code>：本地的 chart 目录；</li></ul><p>Helm chart 安装后会转化成 Kubernetes 中的资源对象，生成一个 chart release，可以使用 <code>helm list</code> 命令查看。</p><p>关于 <code>helm intsall</code> 详细用法见：<a href="https://helm.sh/docs/helm/helm_install/%E3%80%82">https://helm.sh/docs/helm/helm_install/。</a></p><h2 id="升级和回滚-chart"><a href="#升级和回滚-chart" class="headerlink" title="升级和回滚 chart"></a>升级和回滚 chart</h2><p>要想升级 chart 可以修改本地的 chart 配置并执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">helm upgrade <span class="token punctuation">[</span>RELEASE<span class="token punctuation">]</span> <span class="token punctuation">[</span>CHART<span class="token punctuation">]</span> <span class="token punctuation">[</span>flags<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 <code>helm ls</code> 的命令查看当前运行的 chart 的 release 版本，并使用下面的命令回滚到历史版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">helm rollback <span class="token operator">&lt;</span>RELEASE<span class="token operator">&gt;</span> <span class="token punctuation">[</span>REVISION<span class="token punctuation">]</span> <span class="token punctuation">[</span>flags<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="卸载-chart"><a href="#卸载-chart" class="headerlink" title="卸载 chart"></a>卸载 chart</h3><p>要想卸载 chart 可以使用下面的命令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">helm uninstall RELEASE_NAME <span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token punctuation">[</span>flags<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://golang.org/pkg/text/template/">Go template - golang.org</a></li><li><a href="https://helm.sh/docs/chart_template_guide/getting_started/">Getting Started - helm.sh</a></li><li><a href="https://whmzsu.github.io/helm-doc-zh-cn/">Helm 用户指南 - whmzsu.github.io</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++后台开发环境部署</title>
      <link href="c-bian-yi-huan-jing-bu-shu/"/>
      <url>c-bian-yi-huan-jing-bu-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="C-后台开发环境部署"><a href="#C-后台开发环境部署" class="headerlink" title="C++ 后台开发环境部署"></a>C++ 后台开发环境部署</h1><blockquote><p> 记录C++ 后台开发环境的部署，包括但不限于代码补全，编译等。</p><p>大致方案就是VScode+ Clang来进行代码补全的，编译直接就上服务器编译就好了。不过本方案也仅限于用Cmake的项目，其他的没试过</p></blockquote><ol start="0"><li><p>有一台自己的服务器（:</p></li><li><p>下载VScode，安装插件。<img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/image-20210506100521560.png" alt="插件"></p></li><li><p>配置服务器的SSH。 </p></li><li><p>在服务器上安装clang</p></li><li><p>在VScode上安装clangd插件和clang-format插件</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git 使用笔记</title>
      <link href="git-shi-yong-bi-ji/"/>
      <url>git-shi-yong-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h1><h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><ul><li>git stash ：暂存当前变更</li><li>git stash pop ： 恢复变更</li><li>git checkout 分支 ： 切换到分支</li><li>git pull ：更新到最新</li><li>git add 文件：加入追踪</li><li>git checkout -b 新分支 ： 在当前分支上创建新分支</li><li>git commit -m “–story=863210137 【紧急发布】mq_proxy优化” ：提交</li><li>git push ： 推送</li><li>git push –set-upstream origin KiHan36Month3Week1Pub_MqProxy 设置远端上游分支</li><li>git fetch origin 分支名 切换到远程分支名下</li><li>git rebase 分支： 改变基节点为[分支]的HEAD节点。</li></ul><h2 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h2><p>假设我们从master上签出新的分支dev1，在我们开发dev1分支的时候master上也不断有新的提交、合并分支。如果想merge 到master上的话会有新的merge记录。但是如果是用rebase就没有。因为rebase操作就是从master上重新签出一个新的临时分支，将dev1上的所有提交（从他签出master的时间开始算起的提交）都放到新的临时分支上，将冲突都解决完了之后临时分支就成为了dev1，原本dev1就被丢弃了</p><h2 id="Cherry-Pick"><a href="#Cherry-Pick" class="headerlink" title="Cherry-Pick"></a>Cherry-Pick</h2><p>其实就是复制提交，把某一个分支上的某一个提交复制到某一个分支上</p>]]></content>
      
      
      <categories>
          
          <category> VCS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker 入门笔记</title>
      <link href="docker-ru-men-bi-ji/"/>
      <url>docker-ru-men-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h1 id="Docker使用"><a href="#Docker使用" class="headerlink" title="Docker使用"></a>Docker使用</h1><p>概念： docker就是一个容器，可以类比于Windows上的虚拟机， 别人把image都弄好了传到社区里我们只要pull下来进入容器就可以用了。</p><p>显示可用的容器</p><pre class="line-numbers language-none"><code class="language-none">docker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除指定镜像</p><pre class="line-numbers language-none"><code class="language-none">docker rmi &lt;镜像Id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载镜像</p><pre class="line-numbers language-none"><code class="language-none">docker pull hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不指定版本号默认拉取latest版本的</p><p>删除指定镜像</p><pre class="line-numbers language-none"><code class="language-none">docker rmi &lt;镜像Id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看容器</p><pre class="line-numbers language-none"><code class="language-none">docker ps [OPTIONS]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>列出当前正在运行的容器, 结果的第一列是container_Id, 第2列是容器名称.</p><p>参数：</p><ul><li>a :显示所有的容器，包括未运行的。</li><li>f :根据条件过滤显示的内容。</li><li>–format :指定返回值的模板文件。</li><li>l :显示最近创建的容器。</li><li>n :列出最近创建的n个容器。</li><li>–no-trunc :不截断输出。</li><li>q :静默模式，只显示容器编号。</li><li>s :显示总的文件大小。</li></ul><p>停止指定的容器</p><pre class="line-numbers language-none"><code class="language-none">docker stop container_id/container-name 该容器Id或名称可以从docker ps中获取.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>启动容器</p><pre class="line-numbers language-none"><code class="language-none">docker start container_id/container-name 该容器Id或名称可以从docker ps中获取.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>重启容器</p><pre class="line-numbers language-none"><code class="language-none">docker restart container_id/container-name 该容器Id或名称可以从docker ps中获取.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>删除容器</p><pre class="line-numbers language-none"><code class="language-none">docker rm container_id/container-name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>批量删除容器</p><pre class="line-numbers language-none"><code class="language-none">docker rm $(docker ps -a -q)删除所有运行结束了容器,正在运行的容器不会被删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看容器内的进程</p><pre class="line-numbers language-none"><code class="language-none">docker top container_id/container-name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看容器的日志输出</p><pre class="line-numbers language-none"><code class="language-none">docker logs [-f] [-t] [--tail string] 容器名, 查看容器的日志输出, -f是打开跟踪, -t是加上时间戳, --tail 100 表示仅显示最后的100行日志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li></li><li>f : 跟踪日志输出</li><li>–since :显示某个开始时间的所有日志</li><li>t : 显示时间戳</li><li>–tail :仅列出最新N条容器日志</li></ul><p>搜寻镜像</p><pre class="line-numbers language-none"><code class="language-none">docker search镜像名字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>显示指定镜像的详细信息</p><pre class="line-numbers language-none"><code class="language-none">docker image inspect image_iddocker container inspect container_id/container-name （包括容器的Ip）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>列出没有被容器化的镜像</p><pre class="line-numbers language-none"><code class="language-none">docker images -f dangling=true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除那些没有被容器化的镜像</p><pre class="line-numbers language-none"><code class="language-none">docker rmi $(docker images -qf dangling=true)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以磁盘占用情况.</p><pre class="line-numbers language-none"><code class="language-none">docker system df<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>docker 一些管理命令集</p><p>除了上面常用的命令外, docker 还有一些管理命令集, 这些命令集还可以包含二级命令:</p><pre class="line-numbers language-none"><code class="language-none">configManageDocker configscontainerManage containersimageManage images networkManage networks node ManageSwarm nodes pluginManage plugins secret ManageDocker secrets serviceManage servicesstack Manage Docker stacksswarm Manage Swarmsystem Manage Docker trust Manage trust on Docker images volume Manage volumes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比较常用的是:</p><pre class="line-numbers language-none"><code class="language-none">docker image build编译Dockfiledocker network create创建 docker网络docker volume create创建数据卷<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>docker run/exec 命令</p><p>运行 hello-world 容器, 如果本地没有下载, 将会自动从hub站点下载.</p><pre class="line-numbers language-none"><code class="language-none">docker run hello-world 命令<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以守护态运行容器</p><pre class="line-numbers language-none"><code class="language-none">docker run -d --name mybusybox busybox /bin/sh -c "while true; do echo hello world; sleep 1; done"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>登陆一个容器, 运行中的容器其实是<strong>一个功能完备的Linux操作系统</strong>, 所以我们可以在登陆该容器执行常规的Linux命令.</p><pre class="line-numbers language-none"><code class="language-none">docker exec -it container_id/container-name /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 redis-cli 登陆 myredis 容器</p><pre class="line-numbers language-none"><code class="language-none">docker exec -it myredis redis-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>exec 后的 -it 参数的意思是, 以交互的方式并分配一个伪tty, 经常一起联用.</p><p>附录：</p><p>菜鸟教程</p><h2 id="Docker-命令大全"><a href="#Docker-命令大全" class="headerlink" title="Docker 命令大全"></a>Docker 命令大全</h2><p>容器生命周期管理</p><ul><li>run</li><li>start/stop/restart</li><li>kill</li><li>rm</li><li>pause/unpause</li><li>create</li><li>exec</li></ul><p>容器操作</p><ul><li>ps</li><li>inspect</li><li>top</li><li>attach</li><li>events</li><li>logs</li><li>wait</li><li>export</li><li>port</li></ul><p>容器rootfs命令</p><ul><li>commit</li><li>cp</li><li>diff</li></ul><p>镜像仓库</p><ul><li>login</li><li>pull</li><li>push</li><li>search</li></ul><p>本地镜像管理</p><ul><li>images</li><li>rmi</li><li>tag</li><li>build</li><li>history</li><li>save</li><li>load</li><li>import</li></ul><p>info|version</p><ul><li></li><li>info</li><li>version</li></ul><p>网络问题： 遇到<code>Error response from daemon: could not find an available, non-overlapping IPv4 address pool among the defaults to assign to the network</code> 可能是网络模块有问题。</p><p>解决方案1 ： yum update</p><p>解决方案2：创建一个自己的network。<code>docker network create your-network --subnet 172.24.24.0/24</code> ，然后在yaml文件上加上</p><pre class="line-numbers language-none"><code class="language-none">version: '3'services: app:   build: ./app   networks:      - xxx-networknetworks: xxx-network:   external: true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解决方案3：<code>sudo service network-manager restart</code></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s 日常笔记</title>
      <link href="k8s-ri-chang-bi-ji/"/>
      <url>k8s-ri-chang-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h1><h1 id="K8S学习笔记"><a href="#K8S学习笔记" class="headerlink" title="K8S学习笔记"></a>K8S学习笔记</h1><p>K8S ： 自动化运维管理docker程序</p><p>主从架构模型：Master 负责核心调度、管理、运维，Worker（上图的minions）节点则是执行用户程序 所有的Master Node 和Worker Node组成了K8S集群</p><h2 id="Master-Node"><a href="#Master-Node" class="headerlink" title="Master Node"></a>Master Node</h2><ul><li>API Server : k8s的请求入口服务</li><li>Scheduler : k8s所有的Worker Node的调度器</li><li>Controller Manager : k8s所有Worker Node的监控器。有很多具体的controller ， 例如Node Controller、Service Controller、Volume Controller 等。 Controller负责监控和调整worker node上部署的服务状态。</li><li>Etcd : k8s的存储服务。存储关键配置和用户配置，只能通过API Server才能读写数据。其他组件需要通过APIServer 才能读写数据</li></ul><h2 id="Worker-Node"><a href="#Worker-Node" class="headerlink" title="Worker Node"></a>Worker Node</h2><ul><li>Kubelet: Worker Node的监视器和Master Node的通讯器。定期向master汇报自己node上运行服务的状态，并接受来自master的指示</li><li>Kube-Proxy : 网络代理，负责Node在k8s里面的网络通讯和对外部网络流量的负载均衡</li><li>Container Runtime: Worker Node的运行环境（就是装好的docker运行环境）</li><li>Logging Layer : k8s的监控状态收集器（CPU、内存、磁盘、网络等）</li><li>Add-Ons : 管理插件的组件</li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod 是可以在K8s中创建和管理的、最小的可部署的计算单元。就是Pod是K8s中一个服务的闭包，也就是一群可以共享网络、存储和计算资源的容器化服务的集合</p><p>举个例子： 同一个Pod之间的Container可以通过localhost来进行访问，并且可以挂载Pod内所有的数据卷，但是不同的Pod之间不行</p><p>img</p><p>k8s中的所有对象都通过yaml来表示。如下：</p><pre class="line-numbers language-none"><code class="language-none">apiVersion: v1kind: Pod #记录yaml的对象metadata: #记录pod自身的元数据name: memory-demonamespace: mem-examplespec: #记录了pod内部所有资源的详细信息containers: #记录了pod内的容器信息- name: memory-demo-ctr  image: polinux/stress  resources:    limits:      memory: "200Mi"    requests:      memory: "100Mi"  command: ["stress"] #容器入口命令  args: ["--vm", "1", "--vm-bytes", "150M", "--vm-hang", "1"] #入口参数  volumeMounts: #pod内的数据卷信息  - name: redis-storage    mountPath: /data/redisvolumes:- name: redis-storage  emptyDir: {}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Volume数据卷"><a href="#Volume数据卷" class="headerlink" title="Volume数据卷"></a>Volume数据卷</h3><p>数据卷Volume是Pod内部的磁盘资源，对应一个实体的数据卷，VolumeMounts只是Container的挂载点,对应的是Container的其中一个参数。但是，VolumeMounts依赖于Volume，只有当Pod内有Volume资源的时候，该Pod内部的container才可能有VolumeMount。</p><h3 id="Container容器"><a href="#Container容器" class="headerlink" title="Container容器"></a>Container容器</h3><p>一个Pod内可以有多个Container 容器分类有：</p><ul><li>标准容器 Application Container</li><li>初始化容器 Init Container</li><li>边车容器 Sidecar Container</li><li>临时容器 Ephemeral Container</li></ul><h3 id="Deployment和ReplicaSet"><a href="#Deployment和ReplicaSet" class="headerlink" title="Deployment和ReplicaSet"></a>Deployment和ReplicaSet</h3><p>Deployment的作用就是管理和控制Pod和ReplicaSet，管控他们运行在用户期望的状态下。也就是如果用户对Pod如果进行了更新，那么Deployment会先起一个ReplicaSet然后等到内部的Pod都处在Ready状态时，再把原本的ReplicaSet停掉，转移到新版本的ReplicaSet上。</p><p>ReplicaSet的作用就是管理和控制Pod</p><p>img</p><p>主要的区别可以看：<a href="https://blog.csdn.net/qq_41999455/article/details/104220882">https://blog.csdn.net/qq_41999455/article/details/104220882</a></p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service是K8s服务的核心，屏蔽了服务的细节，统一对外暴露服务接口。可以理解为是一个简单的服务注册发现组件。 Service类型：</p><ul><li>ClusterIP：最基本的类型，用作本集群内部的互相通信,也就是起一个转发的作用,避免一个服务宕机了可以保证访问到其他同级的服务</li><li>NodePort ： 集群每个节点上开发一个端口，对外提供服务，同时集群内的节点也可以通过这个内网节点IP 连接到这个端口。外部的话需要通过连接到对外IP的这个端口上。</li><li>Loadbalancer：这个是建立在NodePort服务之上的， 就是负载均衡器，需要有一个单独的IP地址，它会将请求通过这个IP地址分配给所有的外部节点IP，例如说通过round robin策略</li></ul><h3 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h3><p>最后是 ExternalName 服务，这个服务和前面的几种类型的服务有点分离。它创建一个内部服务，其端点指向一个 DNS 名。</p><p>举个例子， 我们在集群内部需要访问到一个python API这样的外部服务，一般而言我们直接通过对应的url 连接到外部服务商。 但是考虑到以后某个时候如果想把外部服务集成到集群中，还不希望去更改连接的地址（因为修改了url），这时候可以用ExternalName类型的服务了， 只要修改serviceType并设置正确标签就可以了。具体如下：</p><p>我们假设 pod-nginx 运行在 Kubernetes 集群中，但是 python api 服务在集群外部。</p><p>对应的 YAML 资源清单文件如下所示：</p><pre class="line-numbers language-none"><code class="language-none">kind: ServiceapiVersion: v1metadata:  name: service-pythonspec:  ports:  - port: 3000    protocol: TCP    targetPort: 443  type: ExternalName  externalName: remote.server.url.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在 <strong>pod-nginx</strong> 就可以很方便地通过 <code>http://service-python:3000</code> 进行通信了，就像使用 ClusterIP 服务一样，当我们决定将 python api 这个服务也迁移到我们 Kubernetes 集群中时，我们只需要将服务改为 ClusterIP 服务，并设置正确的标签即可，其他都不需要更改了。</p><p>Python api 仍然可以通过 <a href="http://service-python/">http://service-python</a> 访问</p><p>当我们创建一个 NodePort 的 Service 时，它也会创建一个 ClusterIP，而如果你创建一个 LoadBalancer，它就会创建一个 NodePort，然后创建一个 ClusterIP</p><p>此外我们还需要明白 Service 是指向 pods 的，Service 不是直接指向 Deployments 或 ReplicaSets，而是直接使用 labels 标签指向 Pod，这种方式就提供了极大的灵活性，因为通过什么方式创建的 Pod 其实并不重要。接下来我们通过一个简单的例子开始，我们用不同的 Service 类型来逐步扩展，看看这些 Service 是如何建立的。</p><p>Service主要负责K8sS集群内部的网络拓扑，Ingress则是负责集群外部访问集群内部的组件，是整个K8S集群的接入层，复杂集群内外通讯。</p><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>Kubernetes Ingress 只是 Kubernetes 中的一个普通资源对象，需要一个对应的 Ingress Controller 来解析 Ingress 的规则，暴露服务到外部，比如 ingress-nginx，本质上来说它只是一个 Nginx Pod，然后将请求重定向到其他内部（ClusterIP）服务去，这个 Pod 本身也是通过 Kubernetes 服务暴露出去，最常见的方式是通过 LoadBalancer 来实现的。和Nginx相比它已经为我们做了所有的代理重定向工作，这为我们节省了大量的手动配置工作了。</p><h2 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h2><h3 id="Kubernetes-Services"><a href="#Kubernetes-Services" class="headerlink" title="Kubernetes Services"></a>Kubernetes Services</h3><p>我们可以用简短地说明下如何实现 Kubernetes Services，这这有助于理解 Istio 如何工作的。</p><p>img</p><p>图1: Kubernetes native service request</p><p>上图的 Kubernetes 集群中一共有两个节点和 4 个 pod，每个 pod 都有一个容器。服务 service-nginx 指向 nginx pods，服务 service-python 指向 python pods。红线显示了从 pod1-nginx 中的 nginx 容器向 service-python 服务发出的请求，该服务将请求重定向到 pod2-python。</p><p>默认情况下，ClusterIP 服务进行简单的随机或轮询转发请求，Kubernetes 中的 Services 并不存在于特定的节点上，而是存在于整个集群中。我们可以在下图 中看到更多细节:</p><p>img</p><p>图2: Kubernetes native service request with kube-proxy</p><p>上图要更详细点，Kubernetes 中的服务是由运行在每个节点上的 kube-proxy 组件实现的，该组件创建 iptables 规则，并将请求重定向到 Pod。因此，服务就是 iptables 规则。(还有其他不使用 iptables 的代理模式，但过程是相同的。)</p><p>现在我们来看一个配置了 Istio 的相同示例:</p><p>图3: Istio Control Plane programs istio-proxy</p><p>上图中可以看到集群中安装了 Istio，每个 pod 都有第二个称为 istio-proxy 的 sidecar 容器，该容器在创建期间会自动将其注入到 pods 中。</p><p>Istio 最常见的代理是 <strong>Envoy</strong>，当然也可以使用其他代理（如 Nginx），所以我们将代理称为 istio-proxy。</p><p>我们可以看到不再显示 kube-proxy 组件，这样做是为了保持图像的整洁，这些组件仍然存在，但是拥有 istio-proxy 的 pods 将不再使用 kube-proxy 组件了。</p><p>每当配置或服务发生变化时，Istio 控制平面就会对所有 istio-proxy sidecars 进行处理，类似于图 2 中 Kubernetes API 处理所有 kube-proxy 组件的方式。Istio 控制平面使用现有的 Kubernetes 服务来接收每个服务点所指向的所有 pods ，通过使用 pod IP 地址，Istio 实现了自己的路由。</p><p>在 Istio 控制平面对所有 istio-proxy sidecars 处理之后，它看起来是这样的:</p><p>img</p><p>图4: Istio Control Plane programmed all istio-proxys</p><p>在图 4 中，我们看到 Istio 控制平面如何将当前配置应用到集群中的所有 istio-proxy 容器，Istio 将把 Kubernetes 服务声明转换成它自己的路由声明。</p><p>让我们看看如何使用 Istio 发出请求:</p><p>图5: Request made with Istio</p><p>在上图中，所有的 istio-proxy 容器已经被 Istio 控制平面所管控，并包含所有必要的路由信息，如图 3/4 所示，来自 pod1-nginx 的 nginx 容器向 service-python 发出请求。</p><p>请求被 pod1-nginx 的 istio-proxy 容器拦截，并被重定向到一个 python pod 的 istio-proxy 容器，该容器随后将请求重定向到 python 容器。</p><h3 id="发生了什么？"><a href="#发生了什么？" class="headerlink" title="发生了什么？"></a>发生了什么？</h3><p>图 1-5 显示了使用 nginx 和 python pod 的 Kubernetes 应用程序的相同示例，我们已经看到了使用默认的 Kubernetes 服务和使用 Istio 是如何发生请求的。</p><p><strong>重要的是</strong>：无论使用什么方法，结果都是相同的，并且不需要更改应用程序本身，只需要更改基础结构代码。</p><p>为什么要使用 Istio?</p><p>如果在使用 Istio 的时候没有什么变化（nginx pod 仍然可以像以前一样连接到 python pod），那么我们为什么还要使用 Istio 呢？</p><p><strong>其惊人的优势是</strong>，现在所有流量都通过每个 Pod 中的 istio-proxy 容器进行路由，每当 istio-proxy 接收并重定向一个请求时，它还会将有关该请求的信息提交给 Istio 控制平面。因此 Istio 控制平面可以准确地知道该请求来自哪个 pod、存在哪些 HTTP 头、从一个istio-proxy 到另一个 istio-proxy 的请求需要多长时间等等。在具有彼此通信的服务的集群中，这可以提高可观察性并更好地控制所有流量。</p><p><strong>先进的路由</strong>，Kubernetes 内部 Services 只能对 pods 执行轮询或随机分发请求，使用 Istio 可以实现更复杂的方式。比如，如果发生错误，根据请求头进行重定向，或者重定向到最少使用的服务。</p><p><strong>部署</strong>，它允许将一定比例的流量路由到特定的服务版本，因此允许绿色/蓝色和金丝雀部署。</p><p><strong>加密</strong>，可以对 pods 之间从 istio-proxy 到 istio-proxy 的集群内部通信进行加密。</p><p><strong>监控/图形</strong>，Istio 可以连接到 Prometheus 等监控工具，也可以与 Kiali 一起展示所有的服务和他们的流量。</p><p>img</p><p><strong>追踪</strong>，因为 Istio 控制平面拥有大量关于请求的数据，所以可以使用 Jaeger 等工具跟踪和检查这些数据。</p><p>img</p><p><strong>多集群 mesh，</strong>Istio 有一个内部服务注册中心，它可以使用现有的 Kubernetes 服务，但是也可以从集群外部添加资源，甚至将不同的集群连接到一个网格中。</p><p>img</p><p><strong>Sidecar 注入</strong>，为了使 Istio 工作，每一个作为网状结构一部分的 pod 都需要注入一个 istio-proxy sidecar，这可以在 pod 创建期间为整个命名空间自动完成（也可以手动完成）。</p><h3 id="Istio-会取代-Kubernetes-的服务吗？"><a href="#Istio-会取代-Kubernetes-的服务吗？" class="headerlink" title="Istio 会取代 Kubernetes 的服务吗？"></a>Istio 会取代 Kubernetes 的服务吗？</h3><p>当然不会，当我开始使用 Istio 时，我问自己的一个问题是它是否会取代现有的 Kubernetes 服务，答案是否定的，因为 Istio 会使用现有的 Kubernetes 服务获取它们的所有 endpoints/pod IP 地址。</p><h3 id="Istio-取代了-Kubernetes-的-Ingress-吗？"><a href="#Istio-取代了-Kubernetes-的-Ingress-吗？" class="headerlink" title="Istio 取代了 Kubernetes 的 Ingress 吗？"></a>Istio 取代了 Kubernetes 的 Ingress 吗？</h3><p>是的，Istio 提供了新的 CRD 资源，比如 Gateway 和 VirtualService，甚至还附带了 ingress 转换器 istioctl convert-ingress，下图显示了 Istio 网关如何处理进入流量，网关本身也是一个 istio-proxy 组件。</p><p>img</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Istio 无疑在 Kubernetes 之上又增加了另一层次的复杂性，但是对于现代微服务架构来说，它实际上提供了一种比必须在应用程序代码本身中实现跟踪或可观察性更简单的方法。</p><p>关于 Istio 更多的使用说明，可以查看官方文档 ﻿<a href="https://istio.io/">https://istio.io</a> 了解更多。</p><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>namespace是为了把一个k8s集群划分为若干个资源不可共享的虚拟集群而诞生的。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>后台日常笔记</title>
      <link href="hou-tai-ri-chang-bi-ji/"/>
      <url>hou-tai-ri-chang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>k8s<br>sidecar ： istio-proxy </p><p>配置<br>docker</p><p>后台：整体概念： 处理什么事情 - &gt; 转发、路由（主流怎么用 ）-&gt;</p><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><h2 id="后台主要解决的事情"><a href="#后台主要解决的事情" class="headerlink" title="后台主要解决的事情"></a>后台主要解决的事情</h2><ul><li><p>网络包</p></li><li><p>定时器</p></li><li><p>存储</p><h2 id="网络包"><a href="#网络包" class="headerlink" title="网络包"></a>网络包</h2><p>从包的生命期开始：来源、解析 、去向</p></li><li><p>来源</p><ul><li>上级服务是如何将包投递过来的</li><li>这个过程包的正确性</li><li>投递速度</li><li>健壮性如何保证（丢包、宕机）</li><li>恶意攻击</li><li>高负载情况</li></ul></li><li><p>解析</p><ul><li>效率</li><li>正确性</li><li>校验</li><li>完整性</li></ul></li><li><p>去向 </p><ul><li>包的下一级如何处理的</li><li>如何投递的</li><li>具体给谁</li><li>与下一级的关系</li><li>效率（线程、如果有锁的话粒度如何）</li></ul></li></ul><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>主要关心：精度、追frame</p><h3 id="思考方式"><a href="#思考方式" class="headerlink" title="思考方式"></a>思考方式</h3><ol><li>需求背景</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ 知识库</title>
      <link href="rabbitmq/"/>
      <url>rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMq"><a href="#RabbitMq" class="headerlink" title="RabbitMq"></a>RabbitMq</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>略咯~~ 网上很多的</p><h2 id="队列模式"><a href="#队列模式" class="headerlink" title="队列模式"></a>队列模式</h2><p>RabbitMq队列具备两种模式：default和lazy。在队列声明的时候可以通过x-queue-mode参数来设置队列的模式，取值为default和lazy。</p><p>RabbitMQ从3.6.0版本开始引入了惰性队列的概念，即将接受到的消息直接存入文件系统中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。惰性队列虽然减少了内存的消耗，但是增加了I/O的使用，因此对于持久化的消息，本身就不可避免磁盘I/O，使用惰性队列是较佳的选择。要注意的是，如果惰性队列中存储的是非持久化的消息，重启之后消息一样会丢失。</p><p> 默认情况下，消息会先存放在内存中，即使是持久化消息也会在内存中驻留一份备份，这部分是由Mq内部的存储结构决定的，后面有写~ 当mq需要释放内存的时候，会将内存中的消息换页（page）到磁盘中，这个操作比较耗时，也会阻塞队列的操作，无法接受新的消息，严重的话甚至会长达几分钟。 </p><p>官方说明文档： </p><p><a href="https://www.rabbitmq.com/lazy-queues.html">https://www.rabbitmq.com/lazy-queues.html</a></p><hr><p>惰性队列和普通队列相比，只有很小的内存开销。这里很难对每种情况给出一个具体的数值，但是我们可以类比一下：当发送1千万条消息，每条消息的大小为1KB，并且此时没有任何的消费者，那么普通队列会消耗1.2GB的内存，而惰性队列只消耗1.5MB的内存。</p><p>据官网测试数据显示，对于普通队列，如果要发送1千万条消息，需要耗费801秒，平均发送速度约为13000条/秒。如果使用惰性队列，那么发送同样多的消息时，耗时是421秒，平均发送速度约为24000条/秒。出现性能偏差的原因是普通队列会由于内存不足而不得不将消息换页至磁盘。如果有消费者消费时，惰性队列会耗费将近40MB的空间来发送消息，对于一个消费者的情况，平均的消费速度约为14000条/秒。</p><h2 id="镜像队列-vs-仲裁队列"><a href="#镜像队列-vs-仲裁队列" class="headerlink" title="镜像队列 vs 仲裁队列"></a>镜像队列 vs 仲裁队列</h2><p>以下围绕同步模型和性能。 </p><h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><p>RabbitMQ的集群在默认模式下，队列实例只存在于一个节点上，既不能保证该节点崩溃的情况下队列还可以继续运行，也不能线性扩展该队列的吞吐量。虽然RabbitMQ的队列实际只会在一个节点上，但元数据可以存在于各个节点上。举个例子来说，当创建一个新的交换器时，RabbitMQ会把该信息同步到所有节点上，这个时候客户端不管连接到哪个RabbitMQ节点，都可以访问到这个新的交换器，也就能找到交换器下的队列：</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/OFqjExcshZpj=tsMaQJXIBApa06sCdts0=91EuBoQhpl31544076799852compressflag.png" alt="镜像队列"></p><p>RabbitMQ内部的元数据主要有：</p><ol><li>队列元数据：队列名称和属性</li><li>交换器元数据：交换器名称，类型和属性</li><li>绑定元数据：路由信息</li></ol><p>尽管交换器和绑定关系能够在单点故障问题上幸免于难，但是队列和其上存储的消息却不行，它们仅存在于单个节点上。引入镜像队列的机制，可以将队列镜像到集群中的其它Broker节点之上，如果集群中的一个节点失效了，队列能够自动地切换到镜像中的另一个节点上以保证服务的可用性。通常情况下，针对每一个配置镜像的队列都包含一个主拷贝和若干个从拷贝，相应架构如下：</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/%E6%9E%B6%E6%9E%84-1620265400840.png" alt="架构"></p><p>除了发送消息外的所有动作都只会向主拷贝发送，然后再由主拷贝将命令执行的结果广播给各个从拷贝，从拷贝实际只是个冷备（默认的情况下所有RabbitMQ节点上都会有镜像队列的拷贝），如果使用消息确认模式，RabbitMQ会在主拷贝和从拷贝都安全的接受到消息时才通知生产者。从这个结构上来看，如果从拷贝的节点挂了，实际没有任何影响，如果主拷贝挂了，那么会有一个重新选举的过程，这也是镜像队列的优点，除非所有节点都挂了，才会导致消息丢失。重新选举后，RabbitMQ会给消费者一个消费者取消通知（Consumer Cancellation），让消费者重连新的主拷贝。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>不同于普通的非镜像队列，镜像队列的实现结构如下：<br><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/8=93STeAbnCfJrE7VLgGxEOr1IDyCPEUR8Lb8jY1F6IiF1544076799852compressflag.png" alt="镜像队列实现结构"></p><p>所有对镜像队列主拷贝的操作，都会通过GM同步到各个slave节点，Coodinator负责组播结果的确认。GM是一种可靠的组播通信协议，该协议能够保证组播消息的原子性，即保证组内的存活节点要么都收到消息要么都收不到。</p><p>GM的组播并不是由master来负责通知所有slave的（目的是为了避免master压力过大，同时避免master失效导致消息无法最终ack)，RabbitMQ把所有节点组成一个链表，每个节点都会监控位于自己左右两边的节点，当有节点新增时，相邻的节点保证当前广播的消息会复制到新节点上；当有节点失效时，相邻的节点会接管以保证本次广播的消息会复制到所有的节点。操作命令由master发起，也由master最终确认通知到了所有的slave，而中间过程则由slave接力的方式进行消息传播。</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/WUD5eU3KpIo3rCJZti5tw1TvD0yeQMZYCnHvQ6i5fXoCb1544076799853compressflag.png" alt="原理"></p><p>镜像队列性能低于应有的速度，使用leader 队列 和一个以上的镜像队列，读写操作都经过leader队列，同时将所有的命令复制到镜像队列里，一旦所有的镜像队列都持有这个消息，leader队列才会发送confirm。 一旦过程中leader下线了，一个镜像队列将会成为leader使得整个队列依然可用。</p><p>在节点与节点之间有一个Inter-node Communication Buffer，用来临时缓存尚未同步的消息， 在某些情况下，节点间的通信量可能非常大，并且会耗尽缓存区的容量，默认配置是128M 。如果要修改可以使用环境变量。当缓存区耗尽的时候会导致节点阻塞。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">RABBITMQ_DISTRIBUTION_BUFFER_SIZE</span><span class="token operator">=</span><span class="token number">192000</span>  <span class="token comment">#直接设置值</span><span class="token assign-left variable">RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS</span><span class="token operator">=</span><span class="token string">"+zdbbl 192000"</span> <span class="token comment">#增加值  单位： 千字节</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当缓冲区处在满负载的情况下，节点会记录一个警告，提到一个负载严重的端口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">2019</span>-04-06 <span class="token number">22</span>:48:19.031 <span class="token punctuation">[</span>warning<span class="token punctuation">]</span> <span class="token operator">&lt;</span><span class="token number">0.242</span>.<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span> rabbit_sysmon_handler busy_dist_port <span class="token operator">&lt;</span><span class="token number">0.1401</span>.<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体官方描述 ： <a href="https://www.rabbitmq.com/runtime.html#distribution-buffer">https://www.rabbitmq.com/runtime.html#distribution-buffer</a></p><p>问题1： 当broker重新上线的话需要面临一个问题： 是否同步镜像，如果同步了，原本队列中的消息就会丢失，同步意味着将当前消息从leader复制到镜像。</p><p>问题2： 接上个问题， 同步过程会阻塞整个队列，导致队列不可用。如果队列很短影响不大，producer可以重新发送那些在同步过程中被拒绝的消息。但是当队列很长的话，影响就很大了。</p><p>默认情况下会自动同步，如果选择不同步镜像的话：所有新消息都会得到复制，但是现有消息不会，也就是说冗余会减少，会存在更大的消息丢失的可能。同时滚动更新也会成为问题，因为重启broker会丢失所有数据需要同步来恢复数据冗余。</p><h3 id="仲裁队列"><a href="#仲裁队列" class="headerlink" title="仲裁队列"></a>仲裁队列</h3><p>基于raft 算法的实现，<strong>仲裁队列比镜像队列更安全，并且吞吐量更高</strong>。那么，这是什么意思呢？</p><p>每个仲裁队列是一个复制队列。它有一个Leader和多个Follower。具有5的复制因子的仲裁队列将由五个复制的队列组成：领导者和四个跟随者。每个复制的队列将托管在不同的节点上。</p><p>客户（发布者和消费者）始终与Leader 进行交互，Leader然后将所有命令（写入，读取，确认等）复制到跟随者。追随者根本不与客户互动。它们仅出于冗余目的而存在，从而在Broker发生故障，宕机时，另一个Broker上的跟随者副本将被选为Leader，并且服务将继续。</p><p>仲裁队列之所以有其名称，是因为所有操作（消息复制和领导者选举）都需要多数副本（称为仲裁）才能达成一致。发布者发送消息时，只有大多数副本将消息写入磁盘后，队列才能确认它。这意味着缓慢的少数群体不会降低整个队列的速度。同样，只有在多数人同意的情况下才能选举领导者，这可以防止两个领导者在发生网络分区时接受消息。因此，仲裁队列的重点是可用性的一致性。</p><p>仲裁队列的<strong>建议副本数</strong>是群集节点的仲裁数（但不少于三个）。</p><p>要声明仲裁队列，请将x-queue-type queue参数设置为quorum （默认值为classic）</p><h4 id="性能特点"><a href="#性能特点" class="headerlink" title="性能特点"></a>性能特点</h4><p>仲裁队列被设计为以延迟为代价来交换吞吐量，并且已经过测试，并与几种消息大小的3、5和7节点配置中的持久<a href="https://www.rabbitmq.com/ha.html">经典镜像队列</a>进行了比较。在同时使用使用者acks和发布者的情况下，<strong>确认已观察到仲裁队列与经典镜像队列具有相等或更大的吞吐量</strong>。</p><p>由于仲裁队列会在执行任何操作之前将所有数据持久保存到磁盘，因此建议使用尽可能快的磁盘。仲裁队列还受益于使用较高预取值的使用者，以确保在确认流经系统并允许消息及时传递的同时，不会使使用者感到饥饿。</p><p>由于仲裁队列的磁盘I / O繁忙特性，其吞吐量随着消息大小的增加而降低。</p><p>就像镜像队列一样，仲裁队列也受群集大小的影响。仲裁队列中的副本越多，通常其吞吐量就越低，因为必须做更多的工作来复制数据并达成共识。</p><p>具体可以看官方描述：<a href="https://www.rabbitmq.com/quorum-queues.html">https://www.rabbitmq.com/quorum-queues.html</a></p><h3 id="两种队列的区别"><a href="#两种队列的区别" class="headerlink" title="两种队列的区别"></a>两种队列的区别</h3><table><thead><tr><th align="left">特性</th><th align="left">镜像队列</th><th align="left">仲裁队列</th></tr></thead><tbody><tr><td align="left"><a href="https://www.rabbitmq.com/queues.html">非持久性队列</a></td><td align="left">yes</td><td align="left">no</td></tr><tr><td align="left"><a href="https://www.rabbitmq.com/queues.html">排他性</a></td><td align="left">yes</td><td align="left">no</td></tr><tr><td align="left">每条消息的持久性</td><td align="left">per message</td><td align="left">always</td></tr><tr><td align="left">成员变更</td><td align="left">automatic</td><td align="left">manual</td></tr><tr><td align="left"><a href="https://www.rabbitmq.com/ttl.html">Message TTL</a></td><td align="left">yes</td><td align="left">no</td></tr><tr><td align="left"><a href="https://www.rabbitmq.com/ttl.html#queue-ttl">Queue TTL</a></td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left"><a href="https://www.rabbitmq.com/maxlength.html">Queue length limits</a></td><td align="left">yes</td><td align="left">yes (except x-overflow: reject-publish-dlx)</td></tr><tr><td align="left"><a href="https://www.rabbitmq.com/lazy-queues.html">Lazy队列</a></td><td align="left">yes</td><td align="left">partial (see <a href="https://www.rabbitmq.com/quorum-queues.html#memory-limit">Memory Limit</a>)</td></tr><tr><td align="left"><a href="https://www.rabbitmq.com/priority.html">优先级消息</a></td><td align="left">yes</td><td align="left">no</td></tr><tr><td align="left"><a href="https://www.rabbitmq.com/consumer-priority.html">消费者优先级</a></td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left"><a href="https://www.rabbitmq.com/dlx.html">DLE</a></td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">Adheres to <a href="https://www.rabbitmq.com/parameters.html#policies">policies</a></td><td align="left">yes</td><td align="left">partial (dlx, queue length limits)</td></tr><tr><td align="left">对内存 <a href="https://www.rabbitmq.com/alarms.html">内存预警</a> 做出反应</td><td align="left">yes</td><td align="left">partial (truncates log)</td></tr><tr><td align="left">处理消费失败信息</td><td align="left">no</td><td align="left">yes</td></tr><tr><td align="left">全局的<a href="https://www.rabbitmq.com/quorum-queues.html#global-qos">QOS值</a></td><td align="left">yes</td><td align="left">no</td></tr></tbody></table><h2 id="DLE（Dead-letter-exchange-）"><a href="#DLE（Dead-letter-exchange-）" class="headerlink" title="DLE（Dead-letter-exchange ）"></a>DLE（Dead-letter-exchange ）</h2><p>一些消息在被broker接收的时候就无法被投递或者处理， 这些信息被称为dead message 。 </p><p>被认为dead message 的情况： </p><ul><li>不被消费者认可消息被否定确认，使用 <code>channel.basicNack</code> 或 <code>channel.basicReject</code> ，并且此时<code>requeue</code> 属性被设置为<code>false</code>。</li><li>TTL过期</li><li>队伍达到了最大容量</li></ul><h3 id="死信队列应用场景"><a href="#死信队列应用场景" class="headerlink" title="死信队列应用场景"></a>死信队列应用场景</h3><p>一般用在较为重要的业务队列中，确保未被正确消费的消息不被丢弃，一般发生消费异常可能原因主要有由于消息信息本身存在错误导致处理异常，处理过程中参数校验异常，或者因网络波动导致的查询异常等等，当发生异常时，当然不能每次通过日志来获取原消息，然后让运维帮忙重新投递消息。通过配置死信队列，可以让未正确处理的消息暂存到另一个队列中，待后续排查清楚问题后，编写相应的处理代码来处理死信消息，这样比手工恢复数据要好太多了。</p><h2 id="用AlternateExchange中收集不可路由的消息"><a href="#用AlternateExchange中收集不可路由的消息" class="headerlink" title="用AlternateExchange中收集不可路由的消息"></a>用AlternateExchange中收集不可路由的消息</h2><p><strong>不可路由消息会导致：</strong> </p><ul><li>返回到一个不断重新发送他们的损坏的应用程序</li><li>Mq被恶意活动攻击导致失去响应</li><li>关键数据丢失</li></ul><p>可以通过基于消息头的的<code>mandatory flag</code>来设置如何处理： <code>true</code> 则原路返回，<code>false</code> 则是静默删除，<code>log</code>可以记录返回的消息但是<code>log</code>无法提供无法访问的<code>exchange</code>或<code>queue</code> 的信息 </p><p>使用AlternateExchange来捕捉不可路由的消息，主交换器上的 <code>mandatory flag</code>需要set，备用交换器上不能，主交换器将消息转发到备用交换器上，备用交换器将消息发送给备用队列（ 他们之间的绑定方式是<code>fanot</code>），将不可路由消息交给专门的<code>consumer</code>处理吧。</p><p><strong>What happens when the mandatory flag is set with an alternate exchange?</strong> </p><p>There is still a chance that messages won’t be routed if an alternate exchange is provided. The service may be unreachable, or the alternate queue may not be specified correctly. You might accidentally specify a non-existent exchange as well.</p><p>当消息路由到备用交换的时候，RabbitMq将把消息标记为已交付。 </p><h2 id="HA方案"><a href="#HA方案" class="headerlink" title="HA方案"></a>HA方案</h2><p>默认情况下，queue可以认为是只存在于它被声明的那个节点中，但是broker和binding可以认为存在于集群中的所有节点中. 可以通过镜像的方式，将queue复制到其它的节点中，以此来提高可用性</p><ul><li>镜像队列之间彼此形成了一主多从的关系，当主镜像队列因为某些原因消失时，一个从镜像自动被推选为主镜像</li><li>不论客户端连接到哪个结点，它都将连接到主镜像队列中，所有队列的操作也都是通过主镜像队列来完成，这样就保证了队列的FIFO特性</li><li>发布到主镜像队列中的消息将会被自动镜像到所有的从镜像中</li><li>如果主镜像中的消息确认已经被消费了，那么从镜像会自动将该消息删除</li><li>这种镜像的方式并不能将流量分散到各个节点，因为每个节点做的事情是一样的，但是它提高了可用性，如果主镜像队列因为某些原因消失了，那么从镜像可以自动升级为主镜像，保证了队列的可用性</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>Rabbitmq队列是不存在于多个节点上的结构，假设有一个负载平衡的、 HA (高可用性) RabbitMQ 集群，如下所示:</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/rabbitmq-cluster-with-lb.png" alt="RabbitMQ Cluster with Load Balancer"></p><p>节点1-3在彼此之间进行复制，以便在每个节点之间同步所有符合 HA策略的队列的快照。假设我们登录到 RabbitMQ 管理控制台并创建一个新的 ha 配置的队列。我们的负载均衡器是以循环的方式配置的，在这个实例中，为了方便起见，我们被定向到 Node # 2。我们的新 Queue 是在 Node # 2上创建的。注意: 可以显式选择您希望 Queue 驻留的节点，但是为了本示例的目的，我们忽略这一点。</p><p>现在，我们的新 Queue“ NewQueue”存在于 Node # 2中。我们的 HA 策略开始生效，Queue 在所有节点上复制。我们开始向 Queue 添加消息，这些消息也在每个节点之间进行复制。本质上，是获取 Queue 的一个快照，并且在不确定的时间段过去之后在每个节点上复制该快照(当 Queue 的状态发生更改时，它实际上作为一个异步后台任务的发生)。</p><p>RabbitMQ 队列是一种单一结构。它只存在于创建它的节点上，与 HA 策略无关。队列总是它自己的主人，并且拥有0…n个从属队列组成。根据上面的示例，节点 # 2上的“ NewQueue”是 Master-Queue，因为这是创建 Queue 的节点。它包含2个从队列-它的对应节点 # 1和 # 3。让我们假设 Node # 2由于某种原因而死亡; 假设整个服务器都关闭了。以下是“ NewQueue”将会发生的情况。</p><ol><li> 节点 # 2不返回心跳，并且被认为是从集群上掉线了</li><li>主队列不再可用(它随节点 # 2一起死亡)</li><li>RabbitMQ 将 Node # 1或 # 3上的“ NewQueue”从属实例提升为 master</li></ol><p>这是 RabbitMQ 中的标准 HA 行为。现在让我们看一下缺省场景，其中所有3个节点都是活的并且运行良好，节点 # 2上的“ NewQueue”实例仍然是主节点。</p><ol><li> 我们连接到 RabbitMQ，目标是“ NewQueue”</li><li> 我们的负载均衡器基于轮循确定一个合适的 Node</li><li> 我们被定向到一个合适的节点(比如说，节点 # 3)</li><li> RabbitMQ 确定“ NewQueue”主节点在 Node # 2上</li><li> 我们成功地连接到“ NewQueue”的主实例</li></ol><p>尽管我们的队列在每个 HA 节点上复制，但是每个 Queue 只有一个可用的实例，并且它驻留在创建它的节点上，或者在失败的情况下，提升为 master 的实例。在这种情况下，RabbitMQ 可以方便地将我们路由到该节点:</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/rabbitmq-cluster-extra-network-hop.png" alt="RabbitMQ Cluster Exhibiting Extra Network-hop"></p><p>糟糕的是，为了到达目标Queue所在的Node，我们需要额外的网络跳转。按照上面的例子中，有3个节点和一个均衡的负载均衡器，我们将在大约66% 的请求上产生额外的网络跳转。每三个请求中只有一个(假设在任何三个唯一请求的分组中，我们被定向到不同的节点)将导致我们的请求被定向到正确的节点。</p><p>为了确保每个请求都被路由到正确的节点，我们有两个选择:</p><ol><li> 显式连接到目标 Queue 所在的节点</li><li> 在节点之间尽可能均匀地分布队列</li></ol><p>这两种解决方案都会立即引发问题。在第一个选择中，客户机应用程序必须知道 RabbitMQ 集群中的所有节点，并且还必须知道每个主队列驻留在哪里。如果一个 Node 宕机了，我们的应用程序怎么知道？更不用说这种设计打破了单一责任原则，提高了应用程序中的耦合级别。</p><p>第二个解决方案提供了一种设计，其中队列不链接到单个节点。基于我们的“ NewQueue”示例，我们不会简单地在单个节点上实例化一个新的 Queue。相反，在一个3节点的场景中，我们可以实例化3个队列; “ NewQueue1”、“ NewQueue2”和“ NewQueue3”，其中每个队列在一个单独的节点上实例化。</p><p> 例如，我们的客户端应用程序现在可以实现一个简单的随机化函数，选择上面的队列之一并显式地连接到它。在网络应用程序中，给定3个单独的 HTTP 请求，每个请求将针对上面的队列中的一个，并且没有队列会在所有3个请求中多于一次。现在，我们已经在集群中实现了合理的负载均衡，而没有使用传统的负载均衡器</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/rabbitmq-cluster-with-randomiser.png" alt="RabbitMQ Cluster with Randomiser"></p><p> 但是我们仍然面临同样的问题; 我们的客户端应用程序需要知道队列驻留在哪里。所以让我们进一步研究解决方案，这样我们就可以避免这个缺点</p><p>首先，我们需要提供描述 RabbitMQ 基础结构的映射元数据。具体地说，队列所在的位置。这应该是弹性数据源，如数据库或缓存，而不是平面文件，因为多个数据源(至少是2个)可以并发地访问这些数据。</p><p>现在引入一个总是在线的服务，轮询 RabbitMQ，确定节点是否是活的。新队列也应该在这个服务中注册，它应该保持一个最新的注册表，提供关于节点及其队列的元数据:</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/rabbitmq-cluster-with-monitor-service.png" alt="RabbitMQ Cluster with Monitor Service"></p><p> 在初始加载时，我们的客户端应用程序应该轮询这个服务并检索 RabbitMQ 元数据，然后为传入的请求保留这些元数据。如果请求由于节点受损而失败，客户机应用程序可以轮询队列元数据存储，返回最新的 RabbitMQ 元数据，并将消息重新路由到工作节点。</p><p>参考文章： </p><p><a href="https://insidethecpu.com/2014/11/17/load-balancing-a-rabbitmq-cluster/comment-page-1/">https://insidethecpu.com/2014/11/17/load-balancing-a-rabbitmq-cluster/comment-page-1/</a></p><p><a href="https://liqul.github.io/blog/rabbitmq-load-balancing/">https://liqul.github.io/blog/rabbitmq-load-balancing/</a></p><p><a href="https://honeypps.com/mq/rabbitmq-load-balance-3-keepalived-haproxy/">https://honeypps.com/mq/rabbitmq-load-balance-3-keepalived-haproxy/</a></p><h2 id="联邦机制"><a href="#联邦机制" class="headerlink" title="联邦机制"></a>联邦机制</h2><p>联邦机制的实现，依赖于RabbitMQ的Federation插件，该插件的主要目标是为了RabbitMQ可以在多个 Broker节点或者集群中进行消息的无缝传递。下面先假设一种场景，BrokerA服务部署在上海，BrokerB服务部署在北京。来自上海的ClientA向BrokerA的exchangeA发送消息网络延迟很小，但是北京的ClientB向BrokerA的exchangeA发送消息那么将会面临网络延迟的问题。Federation机制则可以帮助我们解决这个问题。</p><p>首先在BrokerA的exchangeA上与北京的BrokerB建立一条单向的Federation Link。此时Federation插件会在BrokerB上建立一个同名的交换器(可以配置，默认同名)，并且还会建立一个内部交换器federation:exchangeA-&gt;Broker B(其中Broker为集群名称)通过相同的绑定建进行绑定，于此同时Federation插件会建立一个federation:exchangeA-&gt;Broker B(BrokerB为集群名称)，并且将内部交换器federation:exchangeA-&gt;Broker B绑定到该队列。</p><p>Federation插件会在队列federation:exchangeA-&gt;Broker B与BrokerA中的交换器exchangeA之间建立一条AMQP连接来实时地消费队列federation:exchangeA-&gt;Broker B中的数据。这些操作都是内部的，对外部业务客户端来说这条Federation link建立在BrokerA的exchangeA和BrokerB的exchangeA之间。</p><p>此时ClientB可以以较小的网络延迟向BrokerB的exchangeA发送消息，并且该消息会被正确路由到BrokerA中的exchangeA中，通过Federation插件我们可以以较小的网络延迟向与客户端属于不同地域的Broker节点发送消息。</p><p>“max_hops=1”表示一条消息最多被转发的次数为1。</p><p>默认的交换器(每个vhost下都会默认创建一个名为””的交换器)和内部交换器，不能对其使用Federation的功能。</p><h3 id="联邦队列"><a href="#联邦队列" class="headerlink" title="联邦队列"></a>联邦队列</h3><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/t01z1sz06a.jpeg"></p><p>队列queue1和queue2原本在broker2中，由于某种需求将其配置为federated queue并将broker1作为upstream。Federation插件会在broker1上创建同名的队列queue1和queue2，与broker2中的队列queue1和queue2分别建立两条单向独立的Federation link。当有消费者ClientA连接broker2并通过Basic.Consume消费队列queue1(或queue2)中的消息时，如果队列queue1(或queue2)中本身有若干消息堆积，那么ClientA直接消费这些消息，此时broker2中的queue1(或queue2)并不会拉取broker1中的queue1(或queue2)的消息；如果队列queue1(或queue2)中没有消息堆积或者消息被消费完了，那么它会通过Federation link拉取在broker1中的上游队列queue1(或queue2)中的消息(如果有消息)，然后存储到本地，之后再被消费者ClientA进行消费。</p><p>和federated exchange不同，一条消息可以在联邦队列间转发无限次。两个队列可以互为联邦队列。</p><p>如果两个队列互为联邦队列，队列中的消息除了被消费，还会转向有多余消费能力的一方，如果这种”多余的消费能力”在broker1和broker2中来回切换，那么消费也会在broker1和broker2中的队列queue中来回转发</p><p>federation queue只能使用Basic.Consume进行消费，并且不具备传递性。</p><p>参考文档： </p><p><a href="https://cloud.tencent.com/developer/article/1469331">https://cloud.tencent.com/developer/article/1469331</a></p><h2 id="数据读写过程"><a href="#数据读写过程" class="headerlink" title="数据读写过程"></a>数据读写过程</h2><h3 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h3><p>首先确认一个点，持久化和非持久化的消息都会落地磁盘，区别在于持久化的消息一定会写入磁盘(并且如果可以在内存中也会有一份)，而非持久化的消息只有在内存吃紧的时候落地磁盘。两种类型消息的落盘都是在RabbitMQ的持久层中完成的。</p><p>RabbitMQ的持久层只是一个逻辑上的概念，实际包含两个部分：</p><ul><li>队列索引(rabbit_queue_index)：负责维护队列中落盘消息的信息，包括消息的存储地点、是否己被交付给消费者、是否己被消费者ack等。 每个队列都有与之对应的一个rabbit_queue_index</li><li>消息存储(rabbit_msg_store)：以键值对的形式存储消息，它被所有vhost中的队列共享，在每个vhost中有且只有一个。rabbit_msg_store具体还可以分为 msg_store_persistent和msg_store_transient，msg_store_persistent负责持久化消息的持久化，重启后消息不会丢失；msg_store_transient负责 非持久化消息的持久化，重启后消息会丢失。</li></ul><p>消息(包括消息体、属性和headers)可以直接存储在rabbit_queue_index中，也可以被保存在rabbit_msg_store中。</p><p>最佳的配备方式是较小的消息存储在rabbit_queue_index中而较大的信息则存储在rabbit_msg_store中。消息大小的参数可以通过queue_index_embed_mgs_below来配置，默认大小4096，单位B。</p><p>rabbit_queue_index中以顺序的段文件来开始存储，后缀为”.idx”，每个段文件中包含固定的SEGMENT_ENTRY_COUNT条记录，SEGMENT_ENTRY_COUNT默认值是16384。</p><p>经过rabbit_msg_store处理的所有消息都会以追加的方式写入到文件中，当一个文件的大小超过指定的限制(filesizelimit)后，关闭这个文件再创建一个新的文件以供新的消息写入。文件名(文件后缀是”.rdq”)从0开始进行累加，因此文件名最小的文件也是最老的文件。在进行消息的存储时，RabbitMQ会在ETS(Erlang Term Storage)表中记录消息在文件中的位置映射(Index)和文件的相关信息(FileSummary)。</p><p>在读取消息的时候，先根据消息的ID(msg id)找到对应存储的文件，如果文件存在并且未被锁住，则直接打开文件，从指定位置读取消息的内容。如果文件不存在或者被锁住了，则发送请求由rabbit_msg_store进行处理。</p><p>消息删除是只是删除ETS表中该消息的相关信息，同时更新消息对应的存储文件的相关信息。执行消息删除操作时，并不立即对文件中的消息进行删除，也就是说消息依然在文件中，仅仅是被标识为垃圾数据而已。一个文件中都是垃圾数据时可以将这个文件删除。当检测到前后两个文件中的有效数据可以合并在一个文件中，并且所有的垃圾数据的大小和所有文件(至少有3个文件存在的情况下)的数据大小的比值超过设置的阀值GARBAGE FRACTION(默认值为0.5)时才会触发垃圾回收将两个文件合并。</p><h3 id="队列结构"><a href="#队列结构" class="headerlink" title="队列结构"></a>队列结构</h3><p>通常队列由rabbit_amqpqueue_process和backing_queue两部分组成：</p><ul><li>rabbit_amqpqueue_process：负责协议相关的消息处理(即接收生产者发布的消息、向消费者交付消息、处理消息的确认(包括生产端的confirm和消费端的ack))等</li><li>backing_queue：消息存储的具体形式和引擎，并向rabbit_amqpqueue_process提供接口以供调用</li></ul><p>如果消息发送的队列是空的且队列有消费者，该消息不会经过该队列直接发往消费者，如果无法直接被消费，则需要将消息暂存入队列，以便重新投递。消息在存入队列后，主要有以下几种状态：</p><ul><li>alpha：消息内容(包括消息体、属性和headers)和消息索引都存在内存中</li><li>beta：消息内容保存在磁盘中，消息索引都存在内存中</li><li>gamma：消息内容保存在磁盘中，消息索引在磁盘和内存中都存在</li><li>delta：消息内容和消息索引都在磁盘中</li></ul><p>持久化的消息，消息内容和消息索引必须都保存在磁盘中，才会处于上面状态中的一种，gamma状态只有持久化的消息才有这种状态。</p><p>对于没有设置优先级和镜像的队列来说，backing_queue的默认实现是rabbit_variable_queue，其内部通过5个子队列来体现消息的各个状态：</p><ul><li>Q1：只包含alpha状态的消息</li><li>Q2：包含beta和gamma的消息</li><li>Delta：包含delta的消息</li><li>Q3：包含beta和gamma的消息</li><li>Q4：只包含alpha状态的消息</li></ul><p>消息的状态一般变更方向是Q1-&gt;Q2-&gt;Delta-&gt;Q3-&gt;Q4，大体是从内存到磁盘然后再到内存中。</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/rabbitmq_struct.png" alt="rabbit队列结构"></p><p>消费者消费消息也会引起消息状态的转换。</p><ol><li>消费者消费时先从Q4获取消息，如果获取成功则返回。</li><li>如果Q4为空，则从Q3中获取消息，首先判断Q3是否为空，如果为空返回队列为空，即此时队列中无消息</li><li>如果Q3不为空，取出Q3的消息，然后判断Q3和Delta中的长度，如果都为空，那么Q2、Delta、Q3、Q4都为空，直接将Q1中的消息转移至Q4，下次直接从Q4中读取消息</li><li>如果Q3为空，Delta不为空，则将Delta中的消息转移至Q3中，下次直接从Q3中读取。</li><li>在将消息从Delta转移至Q3的过程中，是按照索引分段读取，首先读取某一段，然后判断读取的消息个数和Delta消息的个数，如果相等，判定Delta已无消息，直接将读取 Q2和读取到消息一并放入Q3，如果不相等，仅将此次读取的消息转移到Q3。</li></ol><p>通常在负载正常时，如果消息被消费的速度不小于接收新消息的速度，对于不需要保证可靠不丢失的消息来说，极有可能只会处于alpha状态。对于durable属性设置为true的消息，它一定会进入gamma状态，并且在开启publisher confirm机制时，只有到了gamma状态时才会确认该消息己被接收，若消息消费速度足够快、内存也充足，这些消息也不会继续走到下一个状态。</p><p>这里以持久化消息为例（可以看到非持久化消息的生命周期会简单很多），从Q1到Q4，消息实际经历了一个<code>RAM-&gt;DISK-&gt;RAM</code>这样的过程，<br>BackingQueue的设计有点类似于Linux的虚拟内存<code>Swap</code>区，</p><ul><li>当队列<code>负载很高</code>时，通过将部分消息放到磁盘上来<code>·</code>节省内存空间`，</li><li>当<code>负载降低</code>时，消息又从磁盘回到内存中，让整个队列有很好的<code>弹性</code>。<br>因此触发消息流动的主要因素是：</li></ul><ol><li><code>消息被消费</code>；</li><li><code>内存不足</code>。</li></ol><ul><li>RabbitMQ会根据<code>消息的传输速度</code>来计算当前<code>内存中允许保存的最大消息数量</code>（Traget_RAM_Count），</li><li>当<code>内存中保存的消息数量 + 等待ACK的消息数量 &gt; Target_RAM_Count</code>时，RabbitMQ才会把消息<code>写到磁盘</code>上，</li><li>所以说虽然理论上消息会按照<code>Q1-&gt;Q2-&gt;Delta-&gt;Q3-&gt;Q4</code>的顺序流动，但是并不是每条消息都会经历所有的子队列以及对应的生命周期。</li><li>从RabbitMQ的Backing Queue结构来看，当<code>内存不足</code>时，消息要经历多个生命周期，在Disk和RAM之间置换，这实际会<code>降低RabbitMQ的处理性能</code>（后续的流控就是关联的解决方法）。</li><li>对于持久化消息，RabbitMQ先将消息的内容和索引保存在磁盘中，然后才处于上面的某种状态（即只可能处于<code>alpha、gamma、delta</code>三种状态之一）。</li></ul><h3 id="消息什么时候会刷到磁盘？"><a href="#消息什么时候会刷到磁盘？" class="headerlink" title="消息什么时候会刷到磁盘？"></a>消息什么时候会刷到磁盘？</h3><ul><li>写入文件前会有一个<code>Buffer</code>，大小为1M（1048576），数据在写入文件时，首先会写入到这个Buffer，如果Buffer已满，则会将Buffer写入到文件（未必刷到磁盘）；</li><li>有个<code>固定的刷盘时间</code>：<code>25ms</code>，也就是不管Buffer满不满，每隔25ms，Buffer里的数据及未刷新到磁盘的文件内容必定会刷到磁盘；</li><li>每次消息写入后，如果没有后续写入请求，则会直接将已写入的消息刷到磁盘：使用Erlang的<code>receive x after 0</code>来实现，只要进程的信箱里没有消息，则产生一个timeout消息，而timeout会触发刷盘操作。</li></ul><h3 id="消息文件何时删除？"><a href="#消息文件何时删除？" class="headerlink" title="消息文件何时删除？"></a>消息文件何时删除？</h3><ul><li>当所有文件中的垃圾消息（已经被删除的消息）比例大于阈值（<code>GARBAGE_FRACTION = 0.5</code>）时，会触发<code>文件合并</code>操作（至少有三个文件存在的情况下），以提高磁盘利用率。</li><li><code>publish</code>消息时写入内容，<code>ack</code>消息时删除内容（更新该文件的有用数据大小），当一个文件的<code>有用数据等于0时</code>，删除该文件。</li></ul><p>参考文档： </p><p><a href="http://geosmart.github.io/2019/11/11/RabbitMQ%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E8%BF%87%E7%A8%8B/">http://geosmart.github.io/2019/11/11/RabbitMQ%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E8%BF%87%E7%A8%8B/</a></p><p><a href="http://geosmart.github.io/2019/11/11/RabbitMQ%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E8%BF%87%E7%A8%8B/">http://geosmart.github.io/2019/11/11/RabbitMQ%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E8%BF%87%E7%A8%8B/</a></p><p><a href="https://cloud.tencent.com/developer/article/1469333">https://cloud.tencent.com/developer/article/1469333</a></p><h2 id="内存及磁盘告警"><a href="#内存及磁盘告警" class="headerlink" title="内存及磁盘告警"></a>内存及磁盘告警</h2><p>当内存使用超过配置的阈值或者磁盘剩余空间低于配置的阈值时，RabbitMQ会暂时阻塞客户端的连接并停止接收从客户端发来的消息。被阻塞的Connection的状态要么是blocking，要么是blocked，前者对应于并不试图发送消息的Connection，后者对应于一直有消息发送的Connection，这种状态下的Connection会被停止发送消息。注意在一个集群中，如果一个Broker节点的内存或者磁盘受限，都会引起整个集群中所有的Connection被阻塞。</p><h3 id="内存告警"><a href="#内存告警" class="headerlink" title="内存告警"></a>内存告警</h3><p>默认情况下内存阈值为0.4，表示当RabbitMQ使用的内存超过40%时，会产生内存告警并阻塞所有生产者的连接。一旦告警被解除（有消息被消费或者从内存转储到磁盘等情况的发生），一切都会恢复正常。</p><p>在某个Broker快达到内存阈值时，会先尝试将队列中的消息换页到磁盘以释放内存空间。默认情况下，在内存到达内存阈值的50%时会进行换页动作。</p><h3 id="磁盘告警"><a href="#磁盘告警" class="headerlink" title="磁盘告警"></a>磁盘告警</h3><p>当剩余磁盘空间低于确定的阈值时，RabbitMQ同样会阻塞生产者，这样可以避免因非持久化的消息持续换页而耗尽磁盘空间导致服务崩溃。默认情况下，磁盘阈值为50MB。RabbitMQ会定期检测磁盘剩余空间，检测的频率与上一次执行检测到的磁盘剩余空间大小有关，随着磁盘剩余空间与磁盘阈值的接近，检测频率会有所增加。</p><h3 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h3><ul><li>当RabbitMQ出现内存(默认是0.4)或者磁盘资源达到阈值时，会触发流控机制：<code>阻塞Producer的Connection</code>，让生产者不能继续发送消息，直到内存或者磁盘资源得到释放。</li><li>Erlang进程之间并不共享内存（binaries类型除外），而是通过消息传递来通信，每个进程都有自己的进程邮箱。Erlang默认没有对进程邮箱大小设限制，所以当有大量消息持续发往某个进程时，会导致该进程邮箱过大，最终内存溢出并崩溃。</li><li>在RabbitMQ中，如果生产者持续高速发送，而消费者消费速度较低时，如果没有流控，很快就会使内部进程邮箱大小达到内存阈值，阻塞生产者（得益于block机制，并不会崩溃）。然后RabbitMQ会进行page操作，将内存中的数据持久化到磁盘中。</li><li>因此，要保证各个进程占用的内容在一个合理的范围，RabbitMQ的流控采用了一种信用机制(Credit)，为每个进程维护了4类键值对：<ul><li><code>{credit_from,From}</code>-该值表示还能向消息接收进程From<code>发送</code>多少条消息;</li><li><code>{credit_to,To}</code>-表示当前进程再<code>接收</code>多少条消息，就要向消息<code>发送</code>进程增加Credit数量;</li><li><code>credit_blocked</code>-表示当前进程被哪些进程block了，比如进程A向B发送消息，那么当A的进程字典中{credit_from,B}的值为0是，那么A的credit_blocked值为[B];</li><li><code>credit_deferred</code>-<code>消息接收</code>进程向<code>消息发送</code>进程增加Credit的<code>消息列表</code>，当进程被Block时会记录消息信息，<code>Unblock后依次发送这些消息</code>;</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/rabbitmq_credit.png" alt="信用机制"></p><p>如图所示:</p><ul><li>A进程当前可以发送给B的消息有100条，每发一次，值减1，直到为0，A才会被Block住。</li><li>B消费消息后，会给A增加新的Credit，这样A才可以持续的发送消息。</li></ul><p>这里只画了两个进程，多进程串联的情况下，这中影响也就是从底向上传递的。</p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>避免队列过长</li><li>不要重复打开和关闭连接或者通道</li><li>不要在线程间共享通道</li><li>不要用太多的链接或者通道</li><li>prefetch值设置要合理</li><li>不要忽略lazy queue</li><li>可以用TTL或者最大长度限制队列大小：如果吞吐量是优先级的话，可以通过从队列头部丢弃消息来保持队短</li><li>在底层节点上使用与核心数量一样多的队列（队列是单线程的）</li><li>持久化消息和队列</li><li>在不同内核上分割队列<ul><li>队列性能仅 限于一个 CPU 核心。因此，如果您将队列拆分到不同的核心，并且如果您有一个 RabbitMQ 集群，那么您将获得更好的性能。</li></ul></li></ul><h2 id="通过监控查看MQ线程负载"><a href="#通过监控查看MQ线程负载" class="headerlink" title="通过监控查看MQ线程负载"></a>通过监控查看MQ线程负载</h2> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rabbitmq-diagnostics observer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>下面这个插件我认为可能有点用处</p><h3 id="consistent-hash-exchange"><a href="#consistent-hash-exchange" class="headerlink" title="consistent-hash-exchange"></a>consistent-hash-exchange</h3><p>当一个队列被绑定到这个交换机上，它会更具他的绑定权重在一致哈希环上分配一个或者多个分区。 对于每个属性hash（例如routing_key），会被放置到相应的散列环分区。该分区对应于一个绑定队列，消息被路由到该队列。</p><p>假设publish的消息的routing_key是合理均匀的，那么被路由的消息应该均匀的分布在所有的环分区上，从而根据他们的绑定权重排队。 </p><h2 id="Q1-Rabbitmq集群的负载均衡是怎么做的-？"><a href="#Q1-Rabbitmq集群的负载均衡是怎么做的-？" class="headerlink" title="Q1 Rabbitmq集群的负载均衡是怎么做的 ？"></a>Q1 Rabbitmq集群的负载均衡是怎么做的 ？</h2><p>A： Rabbitmq服务端本身是不支持负载均衡的，对于RabbitMQ集群来说，主要有两类负载均衡，客户端内部的和服务端的，客户端内部主要是采用负载均衡算法，服务端主要是采用代理服务器。服务端也可以用Haproxy作为负载均衡器。假设一个cluster里有两个实例，记作rabbitA和rabbitB。如果某个队列在rabbitA上创建，随后在rabbitB上镜像备份，那么rabbitA上的队列称为该队列的<strong>主队列</strong>（master queue），其它备份均为<strong>从队列</strong>。接下来，无论client访问rabbitA或rabbitB，最终消费的队列都是主队列。换句话说，即使在连接时主动连接rabbitB，RabbitMQ的cluster会自动把连接转向rabbitA。当且仅当rabbitA服务down掉以后，在剩余的从队列中再选举一个作为继任的主队列。出于这种机制而言， 负载均衡就不能简单的用随机化连接可以做到了</p><p>如果这种机制是真的，那么负载均衡就不能简单随机化连接就能做到了。需要满足下面的条件：</p><ol><li>队列本身的建立需要随机化，即将队列分布于各个服务器；</li><li>client访问需要知道每个队列的主队列保存在哪个服务器；</li><li>如果某个服务器down了，需要知道哪个从队列被选择成为继任的主队列。<br>于是，Load Balancing a RabbitMQ Cluster的作者给出了下图的结构。</li></ol><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/rabbitmq-cluster-with-monitor-service.png" alt="负载均衡架构"></p><p>这还是颇有点复杂的。首先，在建立一个新队列的时候，Randomiser会随机选择一个服务器，这样能够保证队列均匀分散在各个服务器（这里暂且不考虑负载）。建立队列后需要在Meta data里记录这个队列对应的服务器；另外，Monitor Service是关键，它用于处理某个服务器down掉的情况。一旦发生down机，它需要为之前主队列在该服务器的队列重新建立起与服务器的映射关系。</p><p>这里会遇到一个问题，即怎么判断某个队列的主队列呢？一个方法是通过rabbitmqctl，如下面的例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./rabbitmqctl -p production list_queues pid slave_pidsregistration-email-queue        <span class="token operator">&lt;</span>rabbit@mq01.2.1076.<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span>       <span class="token punctuation">[</span><span class="token operator">&lt;</span>rabbit@mq00.1.285.<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span><span class="token punctuation">]</span>registration-sms-queue  <span class="token operator">&lt;</span>rabbit@mq01.2.1067.<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span>       <span class="token punctuation">[</span><span class="token operator">&lt;</span>rabbit@mq00.1.281.<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到pid和slave_pids分别对应主队列所在的服务器和从服务器（可能有多个）。利用这个命令就可以了解每个队列所在的主服务器了。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本编写笔记</title>
      <link href="shell-jiao-ben-bian-xie-bi-ji/"/>
      <url>shell-jiao-ben-bian-xie-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell脚本编写笔记"><a href="#Shell脚本编写笔记" class="headerlink" title="Shell脚本编写笔记"></a>Shell脚本编写笔记</h1><h2 id="读取外部输入"><a href="#读取外部输入" class="headerlink" title="读取外部输入"></a>读取外部输入</h2><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">echo <span class="token operator">-</span>n <span class="token string">"enter:"</span> ##<span class="token operator">-</span>n <span class="token operator">:</span>不换行read 存放的变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="控制流-if-while-for"><a href="#控制流-if-while-for" class="headerlink" title="控制流 if / while / for"></a>控制流 if / while / for</h2><p>读取文件内容</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">while</span> read line<span class="token keyword">do</span>   body ##通常对变量line进行处理done <span class="token operator">&lt;</span> 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>循环n次</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">while</span> <span class="token punctuation">[</span> $i <span class="token operator">-</span>lt $num<span class="token punctuation">]</span><span class="token keyword">do</span>  bodydone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>判断文件夹不存在的情况：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token operator">-</span>d <span class="token string">"文件夹"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> then bodyfi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h3><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">$变量名<span class="token keyword">var</span><span class="token operator">=</span><span class="token function">$</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span> #变量接收命令值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在echo命令中使用变量需要用双引号：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">echo <span class="token string">"print my $变量"</span>echo <span class="token string">"print my ${变量}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在shell中，会对双引号里面的内容进行转义，但是对单引号的不会</p><h2 id="变量运算"><a href="#变量运算" class="headerlink" title="变量运算"></a>变量运算</h2><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">let</span> <span class="token string">'++i'</span> <span class="token keyword">let</span> <span class="token string">'--i'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="函数编写"><a href="#函数编写" class="headerlink" title="函数编写"></a>函数编写</h2><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>body<span class="token punctuation">}</span>##参数我一般直接用全局变量## 返回值用echo $<span class="token operator">?</span> 获取<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Awk"><a href="#Awk" class="headerlink" title="Awk"></a>Awk</h2><pre class="line-numbers language-none"><code class="language-none">awk '{[pattern] action}' {filenames}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例子： </p><pre class="line-numbers language-none"><code class="language-none">awk -F, '{print $1,$4}' log.txt #-F相当于内置变量FS, 指定分割字符,输出文本中的1、4项<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">awk -v  # 设置变量<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Sed"><a href="#Sed" class="headerlink" title="Sed"></a>Sed</h1><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>参数说明</strong>：</p><ul><li>-e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。</li><li>-f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。</li><li>-h或–help 显示帮助。</li><li>-n或–quiet或–silent 仅显示script处理后的结果。</li><li>-V或–version 显示版本信息。</li></ul><p><strong>动作说明</strong>：</p><ul><li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li><li>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li><li>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li><li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li><li>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li><li>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</li></ul><h2 id="inotifywait"><a href="#inotifywait" class="headerlink" title="inotifywait"></a>inotifywait</h2><p>监控文件变化</p><h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><p>定时任务</p></script></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>muduo网络库的实现(1)</title>
      <link href="muduo-wang-luo-ku-de-shi-xian-1/"/>
      <url>muduo-wang-luo-ku-de-shi-xian-1/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>通过绑定回调函数的办法实现当请求到来的时候可以响应业务代码，避免侵入底层网络库。</p><h1 id="常用模型"><a href="#常用模型" class="headerlink" title="常用模型"></a>常用模型</h1><ol><li><p>单线程服务器<br>Reactor模式，其实简单来说就是将非阻塞IO绑定到IO复用模型（epoll,select,poll）上，当有请求到来的时候就通知我们去处理，这是同步的方式。其实有更先进的办法就是Proactor模式，即异步回调。像epoll 这类的IO复用模型都是有事件就会产生通知，但是如何处理，是否读取数据就需要在用户态来执行。Proactor不然，它在调用的时候同时需要传入缓冲区，这样一来当事件发生的时候同时数据也会一并读到用户态缓冲区中，就不用我们再手动去read/recv这样从用户态切换到内核态来进行拷贝，效率更高一些。可惜的是，我在Linux的系统API中并没有发现支持这一模式的API，据说Asio实现了，但是具体没用过。</p></li><li><p>多线程服务器<br>同样是非阻塞IO，这时候就是每个线程分配一个IO复用模型了。即：one loop per thread. 这里面的loop其实是上述的Reator模型。</p><h1 id="一些误区"><a href="#一些误区" class="headerlink" title="一些误区"></a>一些误区</h1></li><li><p>线程越多越好吗?<br>肯定不是呀。根据不同的应用场景，一昧的提高线程数没有意义，例如并发连接数的提升（要提高并发连接的话可能你需要去修改系统最大支持的FD数量了），提高吞吐： 对于计算密集的服务，多线程并不能提高吞吐量，但是可以降低响应延迟。众所周知，对于多核心CPU来说，一个线程分配一个核心是最理想的状态，如果每个线程都能跑满CPU就更好了。但是当线程数大于核心数的时候，线程数越多反而会成为累赘，频繁的CPU切换会导致无用的时间开销。</p></li><li><p>单线程一定比多线程差?<br>参照我example中的memcached程序。 多线程 远不如单线程快，原因是频繁的锁调度同样会导致无法完全发挥出线程并发的作用。极端情况下，当只有一条数据库连接，N个线程，每个线程对数据库进行操作前都需要加锁，这样一来原本计划是并行的程序因为需要等锁变成了串行，而且相比于单线程来说，这样的多线程程序增加了加锁解锁的额外开支。</p></li><li><p>线程池线程数应该多少?<br>根据书中的线程池大小的阻抗匹配原则：<br>T = C/P （之间可以上下浮动50%）<br>T ： 线程数<br>C ： 分配给该任务的CPU核心数<br>P ： 计算密集型任务所占时间比</p><h1 id="Copy-on-write-写时复制）"><a href="#Copy-on-write-写时复制）" class="headerlink" title="Copy-on-write(写时复制）"></a>Copy-on-write(写时复制）</h1><p>写入时复制（英语：Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被建立，因此多个调用者只是读取操作时可以共享同一份资源。(from wiki)<br>下面是通过shared_ptr来实现copy-on-write的内容</p><pre class="line-numbers language-none"><code class="language-none">void traverse(){    FooPtr foos; //一个智能指针    {        Lock        foos = g_foos    }   for(auto it: foos){       it-&gt;doit()   }}void post(const Foo &amp;f){    Lock    if(!g_foos.unique()){        g_foos.reset(new FooList(*g_foos))    }    g_foos-&gt;push_back(f)}//以上可以避免在doit中调用post导致的死锁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的，通过写时复制思想我们也能用普通Mutex 实现读写锁的功能。</p></li></ol><h1 id="EventLoop、Channel、Poll"><a href="#EventLoop、Channel、Poll" class="headerlink" title="EventLoop、Channel、Poll"></a>EventLoop、Channel、Poll</h1><p>这三者就是Muduo网络库的核心，可以说搞懂了这三个就懂了Muduo。</p><p>EventLoop: 一个线程最多只能有一个。相当于网络库中最外层的一个类</p><p>Channel： 属于EventLoop。只负责一个fd的IO分发和IO时间的更新（增删改）</p><p>Poll： 调用poll/epoll/select获得当前活动的IO来填入activeChannel</p><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>One loop per thread 实际上就是指每个线程只能有一个eventloop对象，这个对象主要的工作还是在等待poll这一类多路复用的监听函数。当有时间到来的时候再通过管道（Channel）进行事件分发</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/baUzTjORhnM2HlD.png" alt="loop代码"></p><p>值得一提的是doPendingFunctors()函数的功能，在这个函数执行的是一些需要加锁才能完成的函数。通过这个函数可以轻易地在线程间调配任务，比方说将TimerQueue的成员函数调用移动到所在的IO线程，这样就可以在不加锁的情况下保证了线程安全性。</p><p>同时由于平时loop()阻塞在poll调用中，当有任务来的时候，我们需要一个eventfd来唤醒它。</p><p>在下面函数的实现中，用到了COW来避免发生死锁。 试想一下，假如改成直接加锁，然后执行functors中的函数，会发生什么？</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/Ck1RnXQLM2u7Fyx.png" alt="doPendingFunctors代码"></p><h2 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h2><p>这个类就是IO多路复用模型的一个接口类，后续可以实现epoll/poll/select 等IO复用模型</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/JBnZKItkWgo6LmP.png" alt="Poll的抽象"></p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>这个类主要就是存放监听事件和回调函数了。如果更新相关事件的监听等都会实际上都是调用Poll的updateChannel来修改监听事件。<br>其中handleEvent是在有事件到来的时候根据其所监听的事件调用对应的回调函数。</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/Kh1SCH8jGd6xZlD.png" alt="Channel"></p><p>三个类的时序图</p><p><img src="https://raw.githubusercontent.com/skykens/pubPhotos/main/nxtAd8yOXoUhMmk.png" alt="时序图"></p>]]></content>
      
      
      <categories>
          
          <category> 服务器框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>skylu网络库 开发日志</title>
      <link href="skylu-wang-luo-ku-kai-fa-ri-zhi/"/>
      <url>skylu-wang-luo-ku-kai-fa-ri-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="skylu网络库"><a href="#skylu网络库" class="headerlink" title="skylu网络库"></a>skylu网络库</h1><p>主要参考sylar和handy的实现</p><h1 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h1><h2 id="2020-4-25"><a href="#2020-4-25" class="headerlink" title="2020-4-25"></a>2020-4-25</h2><p>快速浏览一遍github上其他人的网络库实现，挑选出比较适合自己的来进行参考。其中将sylar 的日志模块和配置模块删去一些冗余复杂的内容之后作为自己的日志模块和配置模块。sylar 看了好久他的这两个模块，写的太好了，学到了很多东西，不用实在对不起自己前段时间的学习。</p><h2 id="2020-4-26"><a href="#2020-4-26" class="headerlink" title="2020-4-26"></a>2020-4-26</h2><h3 id="完成内容"><a href="#完成内容" class="headerlink" title="完成内容"></a>完成内容</h3><p>封装锁、线程池、网络地址、文件管理类等模块。</p><p>线程类没有使用c++11的线程，而是用自己封装的Thread类，里面包含锁。通过再构造函数中使用信号量来实现当系统创建完线程后构造函数才会退出。（简单来说就是在构造函数中放一个信号量等待，当线程创建完后发送信号量）</p><p>线程池使用安全队列存放task，线程在创建的时候阻塞等待队列不为空的情况。</p><p>网络地址抽象了一个地址类，目前只实现了ipv4的地址。</p><p>文件管理类主要管理文件句柄，使用单例模式。一般来说，从文件管理类中获取所需要的文件句柄（socket）来进行设置是否阻塞、阻塞IO的超时时间.</p><h3 id="后续可以的优化："><a href="#后续可以的优化：" class="headerlink" title="后续可以的优化："></a>后续可以的优化：</h3><p>[ ]线程池可以参考之前实现的线程池、java线程池来完善扩容、缩容<br>[ ]网络地址中可以加个广播、IPv6地址，更好的兼容不同机器(字节序)</p><h3 id="Next-Day"><a href="#Next-Day" class="headerlink" title="Next Day"></a>Next Day</h3><p>[*]完成TCP 部分的网络库。能够通过简单几行代码Echo回射服务器。<br>[]Epoll部分的封装和事件派发</p><h2 id="2020-4-27"><a href="#2020-4-27" class="headerlink" title="2020-4-27"></a>2020-4-27</h2><h3 id="完成内容-1"><a href="#完成内容-1" class="headerlink" title="完成内容"></a>完成内容</h3><p>socket相关部分的封装,支持IPv4地址的TCP\UDP。</p><p>抽象出address 地址来实现具体的IPv4Address地址类，主要存放sockaddr_in成员。</p><p>socket相关操作封装（包括socket设置）。通过简单的静态函数createTCP\UDP创建相关socket。之后根据socket类型依次调用相关API。</p><h3 id="Next-Day-1"><a href="#Next-Day-1" class="headerlink" title="Next Day"></a>Next Day</h3><p>[]Epoll部分的封装<br>[]事件派发器<br>[]缓冲区设计<br>[]TCP连接类</p><h2 id="2020-4-30"><a href="#2020-4-30" class="headerlink" title="2020-4-30"></a>2020-4-30</h2><h3 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h3><ul><li><p>智能指针和锁<br>在析构函数中加锁的时候需要考虑竞态情况下，例如一个线程中的对象正在析构，另一个线程中却在这个对象的成员函数中，同时两个函数都需要加对方所持有的锁。</p></li><li><p>没有通过具体的数据实验，不能片面的认为读写锁效率比互斥锁高，实际上互斥锁的效率更高一些。可以通过shared_ptr中的引用次数来实现读写锁的功能，同时实现copy-on-write。</p><pre class="line-numbers language-none"><code class="language-none">void read(){  {       Lock()       shared_ptr&lt;Type&gt; val = g_ptr;  }   ....}void write(){Lock()shared_ptr&lt;Type&gt; val;if(!g_ptr.unique()){val.reset(new Type(*g_ptr));g_ptr =val;}....}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>服务器常用模型</p><ul><li> 单线程服务器常用模型Reactor : 非阻塞IO + IO复用（one loop event）</li><li> 多线程服务器常用模型：非阻塞IO+one loop(Reactor) per thread</li></ul></li></ul><p>多线程模型并不能增加并发连接数提升，在32位操作系统下，用户内存空间位3G，假设一个线程的栈空间需要10M，那么最多也就只能并发出300个连接。事实上应该是在每个线程中复用IO，同时监听多条连接，这几个也就是IO线程，然后把计算密集操作放到线程池中执行。<br>同时对于计算密集的服务多线程也不能提高吞吐量，但是可以降低服务响应延迟。</p><p>最重要的一点，线程池大小的阻抗匹配原则，也就是线程池一般来说应该多大。T=C/P（T就是数量,C是分配给该任务的CPU数，P是密集计算所占线程执行的总时间比）。其中当P&lt;0.2的时候 不适用，T可以取固定值。由于这个计算并不是准确的，可以根据实际情况上下浮动50%.</p><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>不得不说，陈硕的linux多线程服务器编程真是一本好书，将很多之前零零散散用的知识都归纳起来，有了一个更深的理解。相比之前仅仅通过看博客，好的书籍一方面可以学到更多的知识，另一方面也是在整理自己的知识体系，不至于分崩离析。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11 新特性（1）智能指针（转）</title>
      <link href="c-11-xin-te-xing-1-zhi-neng-zhi-zhen-zhuan/"/>
      <url>c-11-xin-te-xing-1-zhi-neng-zhi-zhen-zhuan/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>众所周知 ，指针是C/C++ 最大的特点，同时也是C/C++ 程序员最头疼的地方，因为你总是会在内存释放、内存泄露这些老生常谈的问题上面出问题，java最受我羡慕的就是它有一个完整的内存管理器，不用我们去头疼内存的管理问题。C++ 中智能指针的出现就是为了缓解我们对于内存管理方面的焦虑。</p><h1 id="auto指针"><a href="#auto指针" class="headerlink" title="auto指针"></a>auto指针</h1><p>从C++98开始便推出了auto_ptr，对裸指针进行封装，让程序员无需手动释放指针指向的内存区域，在auto_ptr生命周期结束时自动释放，然而，由于auto_ptr在转移指针所有权后会产生野指针，导致程序运行时crash。</p><p>如下例子： </p><pre class="line-numbers language-none"><code class="language-none">auto_ptr&lt;int&gt; p1(new int(10));auto_ptr&lt;int&gt; p2 = p1; //转移控制权*p1 += 10; //crash，p1为空指针，可以用p1-&gt;get判空做保护<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="C-11-智能指针"><a href="#C-11-智能指针" class="headerlink" title="C++11 智能指针"></a>C++11 智能指针</h1><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique_ptr是auto_ptr的继承者，对于同一块内存只能有一个持有者，而unique_ptr和auto_ptr唯一区别就是unique_ptr不允许赋值操作，也就是不能放在等号的右边（函数的参数和返回值例外），这一定程度避免了一些误操作导致指针所有权转移，然而，unique_str依然有提供所有权转移的方法move，调用move后，原unique_ptr就会失效，再用其访问裸指针也会发生和auto_ptr相似的crash，如下面示例代码，所以，即使使用了unique_ptr，也要慎重使用move方法，防止指针所有权被转移。</p><pre class="line-numbers language-none"><code class="language-none">unique_ptr&lt;int&gt; up(new int(5));//auto up2 = up; // 编译错误auto up2 = move(up);cout &lt;&lt; *up &lt;&lt; endl; //crash，up已经失效，无法访问其裸指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="shared-ptr-引用型"><a href="#shared-ptr-引用型" class="headerlink" title="shared_ptr 引用型"></a>shared_ptr 引用型</h2><p>auto_ptr和unique_ptr都有或多或少的缺陷，因此C++11还推出了shared_ptr，这也是目前工程内使用最多最广泛的智能指针，他使用引用计数（感觉有参考Objective-C的嫌疑），实现对同一块内存可以有多个引用，在最后一个引用被释放时，指向的内存才释放，这也是和unique_ptr最大的区别。</p><p>另外，使用shared_ptr过程中有几点需要注意：</p><p>构造shared_ptr的方法，如下示例代码所示，我们尽量使用shared_ptr构造函数或者make_shared的方式创建shared_ptr，禁止使用裸指针赋值的方式，这样会shared_ptr难于管理指针的生命周期。</p><pre class="line-numbers language-none"><code class="language-none">// 使用裸指针赋值构造，不推荐，裸指针被释放后，shared_ptr就野了，不能完全控制裸指针的生命周期，失去了智能指针价值int *p = new int(10);shared_ptr&lt;int&gt;sp = p;delete p; // sp将成为野指针，使用sp将crash// 将裸指针作为匿名指针传入构造函数，一般做法，让shared_ptr接管裸指针的生命周期，更安全shared_ptr&lt;int&gt;sp1(new int(10));// 使用make_shared，推荐做法，更符合工厂模式，可以连代码中的所有new，更高效；方法的参数是用来初始化模板类shared_ptr&lt;int&gt;sp2 = make_shared&lt;int&gt;(10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>禁止使用指向shared_ptr的裸指针，也就是智能指针的指针，这听起来就很奇怪，但开发中我们还需要注意，使用shared_ptr的指针指向一个shared_ptr时，引用计数并不会加一，操作shared_ptr的指针很容易就发生野指针异常。</p><pre class="line-numbers language-none"><code class="language-none">shared_ptr&lt;int&gt;sp = make_shared&lt;int&gt;(10);cout &lt;&lt; sp.use_count() &lt;&lt; endl; //输出1shared_ptr&lt;int&gt; *sp1 = &amp;sp;cout &lt;&lt; (*sp1).use_count() &lt;&lt; endl; //输出依然是1(*sp1).reset(); //sp成为野指针cout &lt;&lt; *sp &lt;&lt; endl; //crash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用shared_ptr创建动态数组，在介绍unique_ptr时我们就讲过创建动态数组，而shared_ptr同样可以做到，不过稍微复杂一点，如下代码所示，除了要显示指定析构方法外（因为默认是T的析构函数，不是T[]），另外对外的数据类型依然是shared_ptr<t>，非常有迷惑性，看不出来是数组，最后不能直接使用下标读写数组，要先get()获取裸指针才可以使用下标。所以，不推荐使用shared_ptr来创建动态数组，尽量使用unique_ptr，这可是unique_ptr为数不多的优势了。</t></p><pre class="line-numbers language-none"><code class="language-none">template &lt;typename T&gt;shared_ptr&lt;T&gt; make_shared_array(size_t size) {    return shared_ptr&lt;T&gt;(new T[size], default_delete&lt;T[]&gt;());}shared_ptr&lt;int&gt;sp = make_shared_array(10); //看上去是shared&lt;int&gt;类型，实际上是数组sp.get()[0] = 100; //不能直接使用下标读写数组元素，需要通过get()方法获取裸指针后再操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用shared_ptr实现多态，在我们使用裸指针时，实现多态就免不了定义虚函数，那么用shared_ptr时也不例外，不过有一处是可以省下的，就是析构函数我们不需要定义为虚函数了，如下面代码所示：</p><pre class="line-numbers language-none"><code class="language-none">class A {public:    ~A() {        cout &lt;&lt; "dealloc A" &lt;&lt; endl;    }};class B : public A {public:    ~B() {        cout &lt;&lt; "dealloc B" &lt;&lt; endl;    }};int main(int argc, const char * argv[]) {    A *a = new B();    delete a; //只打印dealloc A    shared_ptr&lt;A&gt;spa = make_shared&lt;B&gt;(); //析构spa是会先打印dealloc B，再打印dealloc A    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>循环引用，笔者最先接触引用计数的语言就是Objective-C，而OC中最常出现的内存问题就是循环引用，如下面代码所示，A中引用B，B中引用A，spa和spb的强引用计数永远大于等于1，所以直到程序退出前都不会被退出，这种情况有时候在正常的业务逻辑中是不可避免的，而解决循环引用的方法最有效就是改用weak_ptr，具体可见下一章。</p><pre class="line-numbers language-none"><code class="language-none">class A {public:    shared_ptr&lt;B&gt; b;};class B {public:    shared_ptr&lt;A&gt; a;};int main(int argc, const char * argv[]) {    shared_ptr&lt;A&gt; spa = make_shared&lt;A&gt;();    shared_ptr&lt;B&gt; spb = make_shared&lt;B&gt;();    spa-&gt;b = spb;    spb-&gt;a = spa;    return 0;} //main函数退出后，spa和spb强引用计数依然为1，无法释放<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>正如上一章提到，使用shared_ptr过程中有可能会出现循环引用，关键原因是使用shared_ptr引用一个指针时会导致强引用计数+1，从此该指针的生命周期就会取决于该shared_ptr的生命周期，然而，有些情况我们一个类A里面只是想引用一下另外一个类B的对象，类B对象的创建不在类A，因此类A也无需管理类B对象的释放，这个时候weak_ptr就应运而生了，使用shared_ptr赋值给一个weak_ptr不会增加强引用计数（strong_count），取而代之的是增加一个弱引用计数（weak_count），而弱引用计数不会影响到指针的生命周期，这就解开了循环引用，上一章最后的代码使用weak_ptr可改造为如下代码。</p><pre class="line-numbers language-none"><code class="language-none">class A {public:    shared_ptr&lt;B&gt; b;};class B {public:    weak_ptr&lt;A&gt; a;};int main(int argc, const char * argv[]) {    shared_ptr&lt;A&gt; spa = make_shared&lt;A&gt;();    shared_ptr&lt;B&gt; spb = make_shared&lt;B&gt;();    spa-&gt;b = spb; //spb强引用计数为2，弱引用计数为1    spb-&gt;a = spa; //spa强引用计数为1，弱引用计数为2    return 0;} //main函数退出后，spa先释放，spb再释放，循环解开了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用weak_ptr也有需要注意的点，因为既然weak_ptr不负责裸指针的生命周期，那么weak_ptr也无法直接操作裸指针，我们需要先转化为shared_ptr，这就和OC的Strong-Weak Dance有点像了，具体操作如下：</p><pre class="line-numbers language-none"><code class="language-none">shared_ptr&lt;int&gt; spa = make_shared&lt;int&gt;(10);weak_ptr&lt;int&gt; spb = spa; //weak_ptr无法直接使用裸指针创建if (!spb.expired()) { //weak_ptr最好判断是否过期，使用expired或use_count方法，前者更快    *spb.lock() += 10; //调用weak_ptr转化为shared_ptr后再操作裸指针}cout &lt;&lt; *spa &lt;&lt; endl; //20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="智能指针原理"><a href="#智能指针原理" class="headerlink" title="智能指针原理"></a>智能指针原理</h1><h2 id="使用栈对象管理堆对象"><a href="#使用栈对象管理堆对象" class="headerlink" title="使用栈对象管理堆对象"></a>使用栈对象管理堆对象</h2><p>在C++中，内存会分为三部分，堆、栈和静态存储区，静态存储区会存放全局变量和静态变量，在程序加载时就初始化，而堆是由程序员自行分配，自行释放的，例如我们使用裸指针分配的内存；而最后栈是系统帮我们分配的，所以也会帮我们自动回收。因此，智能指针就是利用这一性质，通过一个栈上的对象（shared_ptr或unique_ptr）来管理一个堆上的对象（裸指针），在shared_ptr或unique_ptr的析构函数中判断当前裸指针的引用计数情况来决定是否释放裸指针。</p><h2 id="shared-ptr引用计数的原理"><a href="#shared-ptr引用计数的原理" class="headerlink" title="shared_ptr引用计数的原理"></a>shared_ptr引用计数的原理</h2><p>一开始笔者以为引用计数是放在shared_ptr这个模板类中，但是细想了一下，如果这样将shared_ptr赋值给另一个shared_ptr时，是怎么做到两个shared_ptr的引用计数同时加1呢，让等号两边的shared_ptr中的引用计数同时加1？不对，如果还有第二个shared_ptr再赋值给第三个shared_ptr那怎么办呢？或许通过下面的类图便清楚个中奥秘。</p><p><img src="https://banthink.com/usr/uploads/2020/04/723026653.jpg" alt="智能指针UML.jpg"><br>[ boost中shared_ptr与weak_ptr类图 ]</p><p>我们重点关注shared_ptr<t>的类图，它就是我们可以直接操作的类，这里面包含裸指针T*，还有一个shared_count的对象，而shared_count对象还不是最终的引用计数，它只是包含了一个指向sp_counted_base的指针，这应该就是真正存放引用计数的地方，包括强应用计数和弱引用计数，而且shared_count中包含的是sp_counted_base的指针，不是对象，这也就意味着假如shared_ptr<t> a = b，那么a和b底层pi_指针指向的是同一个sp_counted_base对象，这就很容易做到多个shared_ptr的引用计数永远保持一致了。</t></t></p><h1 id="多线程安全"><a href="#多线程安全" class="headerlink" title="多线程安全"></a>多线程安全</h1><p>本章所说的线程安全有两种情况：</p><h2 id="多个线程操作多个不同的shared-ptr对象"><a href="#多个线程操作多个不同的shared-ptr对象" class="headerlink" title="多个线程操作多个不同的shared_ptr对象"></a>多个线程操作多个不同的shared_ptr对象</h2><p>C++11中声明了shared_ptr的计数操作具有原子性，不管是赋值导致计数增加还是释放导致计数减少，都是原子性的，这个可以参考sp_counted_base的源码，因此，基于这个特性，假如有多个shared_ptr共同管理一个裸指针，那么多个线程分别通过不同的shared_ptr进行操作是线程安全的。</p><h2 id="多个线程操作同一个shared-ptr对象"><a href="#多个线程操作同一个shared-ptr对象" class="headerlink" title="多个线程操作同一个shared_ptr对象"></a>多个线程操作同一个shared_ptr对象</h2><p>同样的道理，既然C++11只负责sp_counted_base的原子性，那么shared_ptr本身就没有保证线程安全了，加入两个线程同时访问同一个shared_ptr对象，一个进行释放（reset），另一个读取裸指针的值，那么最后的结果就不确定了，很有可能发生野指针访问crash。</p><p>作者：腾讯技术工程<br><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;mid=2649743462&amp;idx=1&amp;sn=c9d94ddc25449c6a0052dc48392a33c2&amp;utm_source=tuicool&amp;utm_medium=referral">窥见C++11智能指针</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>翻过那座山，让他们听到你的故事。</title>
      <link href="fan-guo-na-zuo-shan-rang-ta-men-ting-dao-ni-de-gu-shi/"/>
      <url>fan-guo-na-zuo-shan-rang-ta-men-ting-dao-ni-de-gu-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2019.11 - 2020.4.15</p></blockquote><p>花了好长时间在准备腾讯的暑假实习，大概第一次 听到是在大二上左右吧，那时候还在培训，听说一个学长说可以暑假进腾讯之后成为正式员工的机会更大。之后就慢慢的一直在发力。</p><p>有一说一，他妈的从去年的11月份排球联赛打完后一直准备到3月份，期间放弃了很多玩的机会吧，我还记得大一的时候贼浪，到处玩，到处打球。其实放弃这些东西感觉没那么难，因为之前就已经慢慢的对这些东西失去了热情。2月份的时候感觉是我进步最多的时候，我看了很多视频，将数据结构、算法这些基础的东西巩固得更深，回来的时候从学校借的书也派上了用场，我都是当工具书查阅，没有完全看过（除了深入探索C++模型，神书啊~）。越学越觉得学不完，太多了。再加上刷牛客上面的面经帖，看着好多都不懂，焦虑了吧。</p><p>后面慢慢发现，很多面经是研究生、应届毕业生的，我是找实习的，问的问题不会到这么难的程度。之后我就看本科实习生的面经，难度果然一下子下降了很多。慢慢的，保持一天一道leetcode medium,完善项目 时间也过得很快。</p><hr><blockquote><p>下面是干货<br>说说春招实习的结果吧，真的就海投大厂，双非真的真的很难，并不是难在技术，而是难在很多大厂连简历都不给你过直接挂掉了，没有面试没有笔试就没了。（双非在这一点上真的是一道门槛）<br>收到面试的只有阿里巴巴-乌鸫科技，腾讯，参加了网易互娱、牛客、美团的笔试，其他的不是在用人部门筛选（我真是恨死这句话了），不然就是感谢信（有的甚至没有感谢信）。</p></blockquote><h1 id="2月份"><a href="#2月份" class="headerlink" title="2月份"></a>2月份</h1><p>2月份的面经都发在牛客上了我也懒得再重新说一遍了。<br><a href="https://www.nowcoder.com/discuss/372052">https://www.nowcoder.com/discuss/372052</a></p><h1 id="3月份"><a href="#3月份" class="headerlink" title="3月份"></a>3月份</h1><p>相比2月份的充实，3月份就很焦虑了，投了很多企业，最后就腾讯IEG捞我了、美团给笔试机会。不过感觉美团的内推水分很大，我扫码内推后他们hr也打来电话问我有没有合适的后面给我一个内推码，感觉人人都能内推的样子。</p><h2 id="腾讯面经"><a href="#腾讯面经" class="headerlink" title="腾讯面经"></a>腾讯面经</h2><p>一面：<br>1h左右</p><p>讨论项目： 从具体每个方面的实现，不足及改进。持久化的实现，序列化<br>A*算法<br>IPC进程间通信<br>C++ 重载和重写<br>虚函数的实现（这个当时讲的不是很清楚，他知道我懂但就是讲的太复杂了。。）<br>数据结构：哈希表的实现</p><p>二面： （因为大部分内容都记得很透彻，就没有什么印象深刻的。后面忘记记录了就挑影响深刻的说吧）<br>30min左右</p><p>自我介绍<br>介绍项目<br>线程池的实现<br>动态链接库<br>堆的实现<br>Epoll模型<br>协程的理解<br>多核心的机器下多线程和多协程分别用到多少核心<br>之后问我喜不喜欢玩游戏balabla的了<br>转正后会不会留下来<br>二面感觉是leader，总体面起来比一面短、简单一些，但是心里比较没谱。不知道自己回答的合不合适。</p><p>HR面（突击面）：这个很刺激，我那天晚上刚好在准备老师给我模拟面试后整理的一堆反馈和问题，她就打电话过来了，猝不及防。 </p><p>自我介绍<br>性格标签<br>项目中遇到的最大挑战<br>项目中遇到的最大问题<br>实习的目标、期望<br>对深圳的看法（就是想看你稳定性啦）<br>目前春招实习的进展</p><p>之后就进入漫长的等待了。等了n久，上个月月底结束的吧，这个月8号官网状态变成已完成。后面就是等OC了。</p><h2 id="美团："><a href="#美团：" class="headerlink" title="美团："></a>美团：</h2><p>美团笔试内容牛客上面都有，我是最早的一场，感觉美团的笔试是最难的，2小时做5道题，相比我后面的网易2小时半4道题来说体验感差很多。但是美团的笔试只是一个参考，我听说0 AC 都有被面的，但是我AC了一道多也没有面试。。不过也没有说凉了，也还是在流程里面等被捞。不过到今天已经不指望了，今年牛客上面美团的丑闻也挺多的。</p><p>（<a href="https://www.nowcoder.com/discuss/381355?type=post&amp;order=time&amp;pos=&amp;page=1">https://www.nowcoder.com/discuss/381355?type=post&amp;order=time&amp;pos=&amp;page=1</a> 这是美团我那时候的题目，我就AC了一题多，总的得分应该是快200吧。得分是看你AC率。满分500.后面两题没做了。整体难度属于LeetCode 中等偏上，需要在19：00 到21:00做完，同时测试案例得自己写。）</p><h1 id="4月份"><a href="#4月份" class="headerlink" title="4月份"></a>4月份</h1><p>总的来说就是等，等得很焦虑（因为腾讯的提前批快要结束了！）</p><p>期间就是CVTE的HR打来电话简历面吧，问的问题也和腾讯的差不多，然后就是等筛选了。</p><h2 id="乌鸫科技"><a href="#乌鸫科技" class="headerlink" title="乌鸫科技"></a>乌鸫科技</h2><p>一面： （电话突击面，那时候我还在骑车去打球的路上，赶紧停下来接电话面试）</p><p>因为我学的是C++ ，他们是java 为主要的技术栈，所以没有问C++ 方面的内容</p><p>三次握手 四次挥手<br>数据结构了解多少<br>数据库了解多少（因为我是sqlite 他就没什么好问的了。）<br>项目中遇到的困难</p><p>二面： （还是电话突击，因为没有官网查流程只能问学长流程状态。很惊险的是，这个面完 腾讯的OC没多久就来了）</p><p>数据库的索引有哪些<br>平衡二叉树有哪些，实现<br>B树和B+ 树的区别<br>在课程外、书本外学到什么知识</p><h2 id="网易笔试"><a href="#网易笔试" class="headerlink" title="网易笔试"></a>网易笔试</h2><p>牛客上也很多，我做得不好，没有ac一道题，都是做一半，没有100%AC的，算法还是太差了。</p><h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><p>多试一试大厂（如腾讯、阿里、百度等等），至少不是那么看重学校。数据结构和算法很重要，项目也很重要，我认为一般来说吧，数据结构&gt; 项目 &gt; 算法 。算法其实我刷了很久，但是一直都没有提升，和高中刷题一样，日积月累才有质变，数据结构是基础，如果问数据结构都不知道的话就基本凉了。项目的话网上很多，可以看看开源项目，也可以看牛客上别人写的仿写一些（人均http服务器警告）。</p><h1 id="总结（可忽略）"><a href="#总结（可忽略）" class="headerlink" title="总结（可忽略）"></a>总结（可忽略）</h1><blockquote><p><strong>谢谢女朋友一直陪在我身边。</strong></p></blockquote><p>认识了好多内推的学长，在牛客上居然还提前认识了几个未来的部门同事（同事业群）。超级谢谢心妤老师给我进行的模拟HR面，帮我躲过了很多很多坑，志军老师的建议也总是很独到精确，有时候真的醍醐灌顶一样。。菜菜大大的内推群真的很棒！真的在等进度的时候不知道自己内部状态很焦虑的其实。其实也挺想进字节的，可惜简历没过。王哥的建议真的很nice 帮我提高了好多技术。帮我内推的学长我也很感激他能帮我<br>内推……</p><p>最后收到腾讯的OC那一瞬间很激动，后面打完游戏就好很多了，（打来的时候刚好在LOL），想发朋友圈的冲动也没有了。长舒一口气，继续看代码，继续看框架，继续学习，继续争取在这个月把sylar的框架看完，继续更新网站。不是结束，是开始。</p><p>未来还有很长的路要走，还有很多的山，像ig一样，翻过这座山，他们就会听到你的故事。</p>]]></content>
      
      
      <categories>
          
          <category> 求职 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高性能服务器框架  （1）日志模块</title>
      <link href="gao-xing-neng-fu-wu-qi-kuang-jia-1-ri-zhi-mo-kuai/"/>
      <url>gao-xing-neng-fu-wu-qi-kuang-jia-1-ri-zhi-mo-kuai/</url>
      
        <content type="html"><![CDATA[<blockquote><p>github地址： <a href="https://github.com/sylar-yin">https://github.com/sylar-yin</a></p></blockquote><h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><p><img src="https://banthink.com/usr/uploads/2020/04/3672390592.png" alt="Log.png"></p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>首先整个日志模块主要分为Logger、LogEvent、LogAppender、LogFormatter四个器件，是不是和log4j很像，没错，sylar 就是仿log4J设计的。如果了解log4J的代码的话可以跳过了。</p><p>首先整体就是Logger存储日志等级（Level）、格式（Formatter）以及输出的位置（Appender）这些信息，调用log()这个方法格式输出到Appender所实现的子类中。但是调用log()需要LogEvent作为传入参数。而LogEvent的作用是通过stringstream字符串流获得输入内容，既可以直接&lt;&lt;输入也可以调用format()方法进行格式化输入（类似于printf(“%d”,i)这样）。</p><p>接下来分部分来看。</p><h2 id="LogFormatter"><a href="#LogFormatter" class="headerlink" title="LogFormatter"></a>LogFormatter</h2><p>这个是格式器。主要就是用来对对每个格式进行format格式解析的。</p><p>构造函数中必须传入一个string 来初始化m_pattern，m_pattern就是输出的格式，之后会在init()方法中对m_pattern进行解析，根据里面的内容实例化出FormatterItem并放入序列容器中。便于之后调用Format()方法进行输出内容。<br>类中定义的FormatterItem 抽象类 ，就是将每个细分下去的格式进行抽象，其子类需要实现formt() 格式解析的方法。</p><p>例如</p><pre class="line-numbers language-none"><code class="language-none">class LevelFormatItem : public LogFormatter::FormatItem {public:    LevelFormatItem(const std::string&amp; str = "") {}    void format(std::ostream&amp; os, Logger::ptr logger, LogLevel::Level level, LogEvent::ptr event) override {        os &lt;&lt; LogLevel::ToString(level);    }//对os输出流进行内容输出。};class MessageFormatItem : public LogFormatter::FormatItem {public:    MessageFormatItem(const std::string&amp; str = "") {}    void format(std::ostream&amp; os, Logger::ptr logger, LogLevel::Level level, LogEvent::ptr event) override {        os &lt;&lt; event-&gt;getContent();    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>格式器的主要解析格式过程在于LogFormatter中的init()方法中，在这个方法里，首先通过对m_pattern 格式字符串进行一个解析，之后将解析得到的关键字符与已经实现出来的Item进行匹配，如果有的话就实例化出具体的对象，如果没有就实例化出一个存储错误信息的Item，最后放入到序列化容器中。</p><pre class="line-numbers language-none"><code class="language-none">//%xxx %xxx{xxx} %%void LogFormatter::init() {    //str, format, type    std::vector&lt;std::tuple&lt;std::string, std::string, int&gt; &gt; vec;    std::string nstr;    for(size_t i = 0; i &lt; m_pattern.size(); ++i) {        if(m_pattern[i] != '%') {            nstr.append(1, m_pattern[i]);            continue;        }        if((i + 1) &lt; m_pattern.size()) {            if(m_pattern[i + 1] == '%') {                nstr.append(1, '%');                continue;            }        }        size_t n = i + 1;        int fmt_status = 0;        size_t fmt_begin = 0;        std::string str;        std::string fmt;        while(n &lt; m_pattern.size()) {            if(!fmt_status &amp;&amp; (!isalpha(m_pattern[n]) &amp;&amp; m_pattern[n] != '{'                    &amp;&amp; m_pattern[n] != '}')) {                str = m_pattern.substr(i + 1, n - i - 1);                break;            }            if(fmt_status == 0) {                if(m_pattern[n] == '{') {                    str = m_pattern.substr(i + 1, n - i - 1);                    //std::cout &lt;&lt; "*" &lt;&lt; str &lt;&lt; std::endl;                    fmt_status = 1; //解析格式                    fmt_begin = n;                    ++n;                    continue;                }            } else if(fmt_status == 1) {                if(m_pattern[n] == '}') {                    fmt = m_pattern.substr(fmt_begin + 1, n - fmt_begin - 1);                    //std::cout &lt;&lt; "# " &lt;&lt; fmt &lt;&lt; std::endl;                    fmt_status = 0;                    ++n;                    break;                }            }            ++n;            if(n == m_pattern.size()) {                if(str.empty()) {                    str = m_pattern.substr(i + 1);                }            }        }        if(fmt_status == 0) {            if(!nstr.empty()) {                vec.push_back(std::make_tuple(nstr, std::string(), 0));                nstr.clear();            }            vec.push_back(std::make_tuple(str, fmt, 1));            i = n - 1;        } else if(fmt_status == 1) {            std::cout &lt;&lt; "pattern parse error: " &lt;&lt; m_pattern &lt;&lt; " - " &lt;&lt; m_pattern.substr(i) &lt;&lt; std::endl;            m_error = true;            vec.push_back(std::make_tuple("&lt;&lt;pattern_error&gt;&gt;", fmt, 0));        }    }    if(!nstr.empty()) {        vec.push_back(std::make_tuple(nstr, "", 0));    }    static std::map&lt;std::string, std::function&lt;FormatItem::ptr(const std::string&amp; str)&gt; &gt; s_format_items = {# define XX(str, C) \        {# str, [](const std::string&amp; fmt) { return FormatItem::ptr(new C(fmt));}}        XX(m, MessageFormatItem),           //m:消息        XX(p, LevelFormatItem),             //p:日志级别        XX(r, ElapseFormatItem),            //r:累计毫秒数        XX(c, NameFormatItem),              //c:日志名称        XX(t, ThreadIdFormatItem),          //t:线程id        XX(n, NewLineFormatItem),           //n:换行        XX(d, DateTimeFormatItem),          //d:时间        XX(f, FilenameFormatItem),          //f:文件名        XX(l, LineFormatItem),              //l:行号        XX(T, TabFormatItem),               //T:Tab        XX(F, FiberIdFormatItem),           //F:协程id        XX(N, ThreadNameFormatItem),        //N:线程名称# undef XX    };    for(auto&amp; i : vec) {        if(std::get&lt;2&gt;(i) == 0) {            m_items.push_back(FormatItem::ptr(new StringFormatItem(std::get&lt;0&gt;(i))));        } else {            auto it = s_format_items.find(std::get&lt;0&gt;(i));            if(it == s_format_items.end()) {                m_items.push_back(FormatItem::ptr(new StringFormatItem("&lt;&lt;error_format %" + std::get&lt;0&gt;(i) + "&gt;&gt;")));                m_error = true;            } else {                m_items.push_back(it-&gt;second(std::get&lt;1&gt;(i)));            }        }        //std::cout &lt;&lt; "(" &lt;&lt; std::get&lt;0&gt;(i) &lt;&lt; ") - (" &lt;&lt; std::get&lt;1&gt;(i) &lt;&lt; ") - (" &lt;&lt; std::get&lt;2&gt;(i) &lt;&lt; ")" &lt;&lt; std::endl;    }    //std::cout &lt;&lt; m_items.size() &lt;&lt; std::endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据init() 所实现的方法我们可以明确格式字符串支持 <code>%%  %x %x{...}</code>这几种格式。</p><p>输出的动作已经完成了，对于这个输出动作format(std::ostream&amp; os, Logger::ptr logger, LogLevel::Level level, LogEvent::ptr event) 的参数来说，还需要一个输出流。这个输出流谁来提供? 就是LogAppender.</p><h2 id="LogAppender"><a href="#LogAppender" class="headerlink" title="LogAppender"></a>LogAppender</h2><p>这个类就是确定一个输出位置的容器。假如我们要实现一个远程日志的话就需要在这里继承这个抽象类，实现他的log()方法。<br>这个类主要的工作就是初始化输出流，并将输出流通过上面的format()传递到LogFormatter中。</p><h2 id="LogEvent-与-Logger"><a href="#LogEvent-与-Logger" class="headerlink" title="LogEvent 与 Logger"></a>LogEvent 与 Logger</h2><p>LogEvent通过里面的stringstream 提供内容，Logger通过调用Log()进行写入日志内容。其中Log()实际上是在调用Appender的Log()，不过又封装了一层。</p><h2 id="LogEventWrap"><a href="#LogEventWrap" class="headerlink" title="LogEventWrap"></a>LogEventWrap</h2><p>这个是对LogEvent 的再包装，根据RAII思想，在析构的时候进行日志写入，非常nice 。主要用在宏里面，方便快速写入相应等级的日志。</p><h2 id="LogLevel-和-LogManage"><a href="#LogLevel-和-LogManage" class="headerlink" title="LogLevel 和 LogManage"></a>LogLevel 和 LogManage</h2><p>这两个很简单，一个就是枚举等级，一个就是通过Logger 的名称来管理多个Logger。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体来说代码不多，把UML图画出来后能理解挺多内容的。不过里面的宏的时候看了很久，最后看到LogEventWrap的析构函数才恍然大悟，原来是在析构的时候调用log()进行写入。我还找了半天找不到哪里写入日志的。RAII思想很有用，方便资源管理。 </p>]]></content>
      
      
      <categories>
          
          <category> 服务器框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10分钟快速 学会UML 类图 （附视频）</title>
      <link href="10-fen-zhong-kuai-su-xue-hui-uml-lei-tu-fu-shi-pin/"/>
      <url>10-fen-zhong-kuai-su-xue-hui-uml-lei-tu-fu-shi-pin/</url>
      
        <content type="html"><![CDATA[<blockquote><p>觉得看文字比较费解的可以看视频<br>视频地址：<a href="https://www.bilibili.com/video/BV1P741127u7from=search&amp;seid=3523200275187714663">https://www.bilibili.com/video/BV1P741127u7from=search&amp;seid=3523200275187714663</a>  </p></blockquote><h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><p>统一建模语言（Unified Modeling Language，缩写UML）是非专利的第三代建模和规约语言。<br>UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。</p><h1 id="属性的表示方法"><a href="#属性的表示方法" class="headerlink" title="属性的表示方法"></a>属性的表示方法</h1><p>+： 表示为public<br>-： 为private</p><h1 id="：-为protected"><a href="#：-为protected" class="headerlink" title="： 为protected"></a>： 为protected</h1><p>~：表示packetage 比较少用 </p><p>我们要在一个类中表示返回值等等内容： </p><p><img src="https://banthink.com/usr/uploads/2020/04/3464422703.jpg" alt="UML类图.jpg"></p><p>依样画葫芦就可以了。<br>对于接口一般用斜体表示，static函数 下面加一个下划线。</p><h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><p>这部分比较重要，下面介绍 关联、泛化（继承）、聚合、组合、依赖和实现这几种关系</p><p><img src="https://banthink.com/usr/uploads/2020/04/2665660570.jpg" alt="UML.jpg"><br>注意看箭头方向</p><h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><p>关联就是强调两个类之间的联系，关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A。<br>我觉得只要是成员变量的关系就会存在一个关联关系。</p><h2 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h2><p>就是继承，如上图动物园继承自景点。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>狮子、乌龟继承自动物。值得一提的是动物是接口，也就是说狮子和乌龟如果继承动物这个接口的话就需要实现其中的方法。因为这个比较特殊，所以我们一般对于接口的继承关系的箭头为虚线。</p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>如上图的售票处聚合成动物园。如果动物园消失了，那么售票处也就没有了。这种关系强调的是个体离开聚合后的整体是无法存在的。</p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>图上图的动物组合成动物园，乌龟组合成乌龟群。乌龟群如果消失了，乌龟还在，同时动物园被拆了动物也还活着。这种组合关系强调的是组合中的个体离开整体后仍然能够存在。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>依赖关系是用一套带箭头的虚线表示的；他描述一个对象在运行期间会用到另一个对象的关系；</p><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p><p>注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p><hr><h1 id="依赖-和-关联的区别"><a href="#依赖-和-关联的区别" class="headerlink" title="依赖 和 关联的区别"></a>依赖 和 关联的区别</h1><blockquote><p>转自<a href="https://www.cnblogs.com/liuzhang/archive/2013/03/17/2964095.html">https://www.cnblogs.com/liuzhang/archive/2013/03/17/2964095.html</a></p></blockquote><p>　依赖(dependency)</p><p>　　可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖；表现在代码层面，为类B作为参数被类A在某个method方法中使用。用带虚线的箭头。</p><p>　　</p><p>　关联(association)</p><p>　　他体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的；表现在代码层面，为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量；</p><p> 依赖和关联区别：我用锤子修了一下桌子，我和锤子之间就是一种依赖，我和我的同事就是一种关联。依赖是一种弱关联，只要一个类用到另一个类，但是和另一个类的关系不是太明显的时候（可以说是“uses”了那个类），就可以把这种关系看成是依赖，依赖也可说是一种偶然的关系，而不是必然的关系。关联是类之间的一种关系，例如老师教学生，老公和老婆这种关系是非常明显的。依赖是比较陌生，关联是我们已经认识熟悉了。</p><h1 id="类间联系"><a href="#类间联系" class="headerlink" title="类间联系"></a>类间联系</h1><p>类与类之间由<strong>弱到强</strong>关系是<br>没关系 &gt; 依赖 &gt; 关联 &gt; 聚合 &gt; 组合。</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cmake 编写 从实战中学习</title>
      <link href="cmake-bian-xie-cong-shi-zhan-zhong-xue-xi/"/>
      <url>cmake-bian-xie-cong-shi-zhan-zhong-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><p>关于cmake 和make 的区别以及什么是cmake这里就不赘述了</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>下面是我学习sylar 大佬的框架课程中日志模块部分，他写的一个cmake 文件。</p><p>其中文件的目录结构为：</p><p>bin –二进制<br>build – 中间文件路径<br>cmake – cmake 函数文件夹<br>CMakeLists.txt – cmake 的定义文件<br>lib – 库的输出路径<br>sylar – 源代码路径<br>tests – 测试代码路径</p><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 2.8)  # 指定使用的版本project(sylar)   # 项目名称 一般和项目文件夹相对应 set(CMAKE_VERBOSE_MAKEFILE ON)  # 显示编译的过程set(CMAKE_CXX_FLAGS "$ENV{CXXFLAGS} -rdynamic -O0 -ggdb -std=c++11 -Wall -Wno-deprecated -Werror -Wno-unused-function")   # 设置 编译选项  set  设置变量的意思set(LIB_SRCsylar/log.cc)  # 设置变量 add_library(sylar SHARED ${LIB_SRC})     # 将LIB_SRC下的文件编译为动态链接库 。  SHARED为共享库 ，不加的话就是静态.aadd_executable(test tests/test.cc)   # test为编译后的可执行程序名称, 后面的就是编译文件add_dependencies(test sylar)  # 这是设置依赖项 target_link_libraries(test sylar)  # 动态链接库 链接 类似于-lsylarinclude_directories(${PROJECT_SOURCE_DIR}/sylar) # 添加头文件的搜索路径 也就是-ISET(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)  # 可执行文件的输出路径SET(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib) # 设置编译后动态库的路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高性能服务器框架 总览</title>
      <link href="gao-xing-neng-fu-wu-qi-kuang-jia-zong-lan/"/>
      <url>gao-xing-neng-fu-wu-qi-kuang-jia-zong-lan/</url>
      
        <content type="html"><![CDATA[<h1 id="基于对sylar-的开源框架的学习"><a href="#基于对sylar-的开源框架的学习" class="headerlink" title="基于对sylar 的开源框架的学习"></a>基于对sylar 的开源框架的学习</h1><p>github  ： <a href="https://github.com/sylar-yin">https://github.com/sylar-yin</a></p><p>基于这个开源框架的学习，整合出自己的高性能服务器框架。</p><p>主要从日志模块、协程调度、配置系统以及HTTP 方面进行学习。</p><p>预计4月份整理出大体文档以及UML图的学习和自己的开源框架。</p><p>立个flag~~</p>]]></content>
      
      
      <categories>
          
          <category> 服务器框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>视频播放器 （服务端）遇到的一些问题（总结）</title>
      <link href="shi-pin-bo-fang-qi-fu-wu-duan-yu-dao-de-yi-xie-wen-ti-zong-jie/"/>
      <url>shi-pin-bo-fang-qi-fu-wu-duan-yu-dao-de-yi-xie-wen-ti-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="相关知识补充"><a href="#相关知识补充" class="headerlink" title="相关知识补充"></a>相关知识补充</h1><h2 id="EPOLL的相关API是线程安全吗"><a href="#EPOLL的相关API是线程安全吗" class="headerlink" title="EPOLL的相关API是线程安全吗?"></a>EPOLL的相关API是线程安全吗?</h2><p>是的。</p><h2 id="EPOLL的设计缺陷"><a href="#EPOLL的设计缺陷" class="headerlink" title="EPOLL的设计缺陷"></a>EPOLL的设计缺陷</h2><p>epoll有一个巨大的设计失误，但凡理解文件描术符是什么的人都能看到这一点。但是如果你回望epoll的历史，你会发现设计者显然不理解文件描述符与文件描述的区别。<br>epoll的缺陷在于它把文件描述符当作内核对象（文件描述）使用。当使用close（）方法清理epoll事件订阅时，问题就出现了。<br>epoll_ctl(EPOLL_CTL_ADD) 并没有注册文件描述符，而是注册了一个文件描述符元组和内核对象的指针。最让人困惑的是事件关注者的生命周期跟文件描述符无关，而与内核对象的生命周期相关.<br>由于这个设计缺陷，对文件描述符调用close()方法可能会，也可能不会取消对epoll事件的订阅。如果close方法删除了内核对象的最后一个指针而让对象释放，epoll事件的订阅即可清除。但如果内核对象有多个指针，多个文件描述符，不管在哪一个进程中，close方法都无法清除订阅，很可能会收到已关闭的文件描述符的事件。</p><h2 id="EPOLL-ONESHOT"><a href="#EPOLL-ONESHOT" class="headerlink" title="EPOLL ONESHOT"></a>EPOLL ONESHOT</h2><p>简单来说就是令EPOLL触发的事件只触发一次，直到下一次调用epoll_ctl进行mod 重置EPOLLONESHOT这个事件才会继续监听事件。可以避免在对一个文件描述符进行读事件的时候客户端又发来请求，这时候如果再分配一个线程来处理请求就会产生错误，如果加锁的话就大大影响多线程并发效率。添加这个事件的好处就是我们可以将缓冲区的内容循环读取干净后再重置，也就是读取过程中EPOLL将不会监听这个文件描述符了。</p><h2 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h2><p>简单来说就是线程阻塞在条件变量上，之后得到信号量了但是没有资源（可能有其他线程也在等这个资源刚好被抢走了），但是线程的确被唤醒了，和我们一开始想的有资源线程就启动所违背，这就是虚假唤醒。<br>避免虚假唤醒一般是：</p><pre class="line-numbers language-none"><code class="language-none">while(资源为空==true)    cond.wait();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p>翻译过来中文就是获取资源的时候就初始化。这种使用方式就是为了避免资源泄露，自动的释放资源。例如下面这段代码：</p><pre class="line-numbers language-none"><code class="language-none">class Lock{  Lock(mutex * mute): mut(mute){     mut.Lock()  }  ~Lock()  {    mute.unLock();  }private:   mutex *mut;}int func(){    static int count=0;    Lock lock(&amp;mutex)    printf("%d",count++);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中就是在离开所在区块的时候就释放锁（通过调用Lock的析构函数）。</p><h1 id="BUG篇"><a href="#BUG篇" class="headerlink" title="BUG篇"></a>BUG篇</h1><p>线程池发布任务的时候需要考虑到唤醒的速度和发布任务的速度不一致的问题。发布任务所在的线程执行完毕时，需要被唤醒的线程可能未必已经唤醒了，这时候如果再来一个任务，可能会将刚刚唤醒的任务重新唤醒一遍，并导致将之前尚未开始的任务覆盖。（已解决）</p><p>解决方案： 在检索到空闲任务的时候直接将空闲任务置为忙，不在任务线程中置为运行态。<br>更好的改进：将线程池独立一个线程里面进行管理任务就绪队列（重新封装的安全队列），发布任务API只是将队列中添加任务，真正将任务从就绪队列中移除，放入工作线程中是在线程池所在的线程中执行的，同时也在这个线程监控线程池实时状态，进行扩充或者缩减。</p><hr><p>纯虚函数被调用，这个问题是在哪里出现的。（已解决）</p><p>原因：线程基类初始化的时候没有将成员全部初始化，其中有一个成员是决定线程是否开始运行，由于没有初始化状态是位置的，所以这个问题出现的很随机。</p><hr><p>第一次的发包都是正确的，但是每个文件描述符第二次发包就很多没有响应到。（已解决）</p><p>解决方案： 问题8的连锁反应。</p><hr><p>SIGEGV 段错误。每次的文件描述符莫名其妙变成负数，之后再调用就变成 出错了，查看堆栈的时候出现这样子（已解决）</p><pre class="line-numbers language-none"><code class="language-none"># 0  0x0000000000763370 in ?? ()# 1  0x000000000040c840 in TCPClient::recvPacket (this=0x698e00)    at TCP/TCPClient.cpp:45# 2  0x0000000000414a55 in ClientTask::run (this=0x762ff0)# 0  0x0000000000759790 in ?? ()# 1  0x000000000040b2a0 in TCPClient::recvPacket (this=0x6e6c50)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决方案：</p><ul><li>由于分配任务是利用多态的，删除时候只删除了基类对象的内存空间，没有释放派生类的，需要在基类对象的析构函数上加上virtual</li><li>线程池缩容的时候由于是简单判断线程的状态，可能出现一种情况，当线程这时候是空闲状态，当线程池要缩容的时候刚好分配任务过来了，就出错了。（已解决。将分配任务和缩容放在同一个线程里管理）</li></ul><hr><p>文件描述符意外关闭的时候 读取SIGPIPE 错误需要正确处理。（已解决）</p><p>解决方案：重新设计一个单例类，进行全局环境的初始化，包括相关信号的捕捉和线程池、端口等的设置。</p><hr><p>问题：出现SIGABRT错误，连续释放指针对象</p><p>解决方案： 对应线程池中的分配任务、扩容、缩容一直都会出现问题，通过将这些放在同一个线程里就都解决了。</p><hr><p>问题：epoll 在移除文件描述符的时候 出现 no such file or dir …  （已解决）</p><p>原因： 多线程的问题，epoll中的移除添加函数中的关键变量是成员变量，多线程的时候会出现意外情况。例如多个线程同时在用同时修改成员变量或者同时使用同一个成员变量。</p><hr><p>当线程池需要缩容的时候就会出现段错误。（已解决）</p><p>解决方案：使用自己封装的安全队列。</p><hr><p>速度太慢了，而且线程池的扩容明明速度不够的时候没有及时响应，但是不知道为什么在一开始的时候等待任务队列会被判定为非空。（已解决）</p><p>原因： 多线程并发的问题，没有加锁。队列不安全。</p><hr><p>为什么每次就只有第一个FD响应请求，其他的FD的请求都没有响应到（已解决）</p><p>原因： 在删除冗余代码的时候没有将break删除掉导致退第一次判断结束后就退出循环了!!(好蠢的错误)</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实大部分的错误都是刚刚接触多线程编程时候带来的错误，包括对于线程安全的认识以及锁、条件变量、信号量等的认识都不是很充分。尤其是第一次遇到这么多问题而且很多问题都是需要和压力测试端一起解决的优点措手不及（以前都是自己单步调试慢慢找到的），现在也学到很多GDB相关调试的知识。</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法复习- 动态规划总结（6）</title>
      <link href="suan-fa-fu-xi-dong-tai-gui-hua-zong-jie-6/"/>
      <url>suan-fa-fu-xi-dong-tai-gui-hua-zong-jie-6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容整合自[动态编程模式][1]  同时加上自己的一些总结</p></blockquote><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>大部分动态规划可以归结为以下五种模型来解决： </p><ol><li><p>最小/最大路径  ： 给定目标，找到达到目标的最小（最大）成本/路径/总和。</p></li><li><p>统计方法总数  ： 给定目标，统计有多少种方法到达目标 </p></li><li><p>合并间隔 ： 给定一组数字，考虑到当前数字以及从左侧和右侧可获得的最佳数值，找到解决问题的最佳方案。</p></li><li><p>决策问题 ： 给定一组值，找到答案，并提供选择或忽略当前值的选项。</p></li><li><p>字符串 ： 回文字符串，最长子序列等问题。</p></li></ol><h2 id="最小-最大路径"><a href="#最小-最大路径" class="headerlink" title="最小/最大路径"></a>最小/最大路径</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>在当前状态之前的所有可能路径中选择最小（最大）路径，然后为当前状态添加权重值。</p><pre><code>routes[i] = min(routes[i-1], routes[i-2], ... , routes[i-k]) + cost[i]</code></pre><p>为目标中的所有值生成最佳解决方案，然后返回目标的值。</p><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><pre class="line-numbers language-none"><code class="language-none">for (int i = 1; i &lt;= target; ++i) {   for (int j = 0; j &lt; ways.size(); ++j) {       if (ways[j] &lt;= i) {           dp[i] = min(dp[i], dp[i - ways[j]]) + cost / path / sum;       }   }} return dp[target]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="LeetCode-上的相关问题"><a href="#LeetCode-上的相关问题" class="headerlink" title="LeetCode 上的相关问题"></a>LeetCode 上的相关问题</h3><p>746.最低价攀登楼梯 Easy</p><pre class="line-numbers language-none"><code class="language-none">for (int i = 2; i &lt;= n; ++i) {   dp[i] = min(dp[i-1], dp[i-2]) + (i == n ? 0 : cost[i]);} return dp[n]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>64.最小路径总和 Medium</p><pre class="line-numbers language-none"><code class="language-none">for (int i = 1; i &lt; n; ++i) {   for (int j = 1; j &lt; m; ++j) {       grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j];   }} return grid[n-1][m-1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>322.硬币找零 Medium</p><pre class="line-numbers language-none"><code class="language-none">for (int j = 1; j &lt;= amount; ++j) {   for (int i = 0; i &lt; coins.size(); ++i) {       if (coins[i] &lt;= j) {           dp[j] = min(dp[j], dp[j - coins[i]] + 1);       }   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>931.最小下降路径总和 Medium</p><p>983.最低票价 Medium</p><p>650.2键键盘 Medium</p><p>279.完美正方形 Medium</p><p>1049.最后一块石头的重量II Medium</p><p>120.三角形 Medium</p><p>474.一和零 Medium</p><p>221.最大广场 Medium</p><p>322.硬币找零 Medium</p><p>1240.用最小的正方形平铺一个矩形 Hard</p><p>174.地下城游戏 Hard</p><p>871.最小加油站数 Hard</p><h2 id="统计方法总数"><a href="#统计方法总数" class="headerlink" title="统计方法总数"></a>统计方法总数</h2><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>记录从0 -&gt; n 的所有情况并进行累加<br>    routes[i] = routes[i-1] + routes[i-2]+ …  + routes[i-k]</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-none"><code class="language-none">for (int i = 1; i &lt;= target; ++i) {   for (int j = 0; j &lt; ways.size(); ++j) {       if (ways[j] &lt;= i) {           dp[i] += dp[i - ways[j]];       }   }} return dp[target]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="LeetCode-上的相关问题-1"><a href="#LeetCode-上的相关问题-1" class="headerlink" title="LeetCode 上的相关问题"></a>LeetCode 上的相关问题</h3><p>类似问题<br>70.爬楼梯 easy</p><p>for (int stair = 2; stair &lt;= n; ++stair) {<br>   for (int step = 1; step &lt;= 2; ++step) {<br>       dp[stair] += dp[stair-step];<br>   }<br>}<br>62.独特的道路 Medium</p><p>for (int i = 1; i &lt; m; ++i) {<br>   for (int j = 1; j &lt; n; ++j) {<br>       dp[i][j] = dp[i][j-1] + dp[i-1][j];<br>   }<br>}<br>1155.目标总数的骰子卷数 Medium</p><p>for (int rep = 1; rep &lt;= d; ++rep) {<br>   vector<int> new_ways(target+1);<br>   for (int already = 0; already &lt;= target; ++already) {<br>       for (int pipe = 1; pipe &lt;= f; ++pipe) {<br>           if (already - pipe &gt;= 0) {<br>               new_ways[already] += ways[already - pipe];<br>               new_ways[already] %= mod;<br>           }<br>       }<br>   }<br>   ways = new_ways;<br>}  //这题真的尼玛难；<br>PS : 注意一些问题指出了重复的次数，在这种情况下，还要增加一个循环来模拟每个重复。</int></p><p>688.国际象棋骑士的概率 Medium</p><p>494.目标总和 Medium</p><p>377.组合和IV Medium</p><p>935.骑士拨号器 Medium</p><p>1223.骰子滚动模拟 Medium</p><p>416.分区相等子集总和 Medium</p><p>808.汤服务 Medium</p><ol start="790"><li>Domino和Tromino平铺 Medium</li></ol><p>801.使序列增加的最小掉期</p><p>673.最长递增子序列数 Medium</p><p>63.独特之路II Medium</p><p>576.超越界限 Medium</p><p>1269.经过一些步骤后留在同一个地方的方式数量 Hard</p><p>1220.元音排列 Hard</p><h2 id="合并间隔"><a href="#合并间隔" class="headerlink" title="合并间隔"></a>合并间隔</h2><h2 id="决策问题"><a href="#决策问题" class="headerlink" title="决策问题"></a>决策问题</h2><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>  [1]: <a href="https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns#">https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns#</a> Minimum-(Maximum)-Path-to-Reach-a-Target</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转）ELF文件装载链接过程及hook原理</title>
      <link href="zhuan-elf-wen-jian-zhuang-zai-lian-jie-guo-cheng-ji-hook-yuan-li/"/>
      <url>zhuan-elf-wen-jian-zhuang-zai-lian-jie-guo-cheng-ji-hook-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>原地址：<a href="https://felixzhang00.github.io/2016/12/24/2016-12-24-ELF%E6%96%87%E4%BB%B6%E8%A3%85%E8%BD%BD%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%8F%8Ahook%E5%8E%9F%E7%90%86/">ELF文件装载链接过程及hook原理</a></p><blockquote><p>这篇文章是我在研究libco 库中的hook 找到的，感觉能解决不少不懂hook是什么以及如何注册系统回调函数等问题吧。把这个学完后对libco 的代码会有更深的理解</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迭代器失效的几种情况总结（转）</title>
      <link href="die-dai-qi-shi-xiao-de-ji-chong-qing-kuang-zong-jie-zhuan/"/>
      <url>die-dai-qi-shi-xiao-de-ji-chong-qing-kuang-zong-jie-zhuan/</url>
      
        <content type="html"><![CDATA[<p>1.对于序列式容器(如vector,deque)，序列式容器就是数组式容器，删除当前的iterator会使后面所有元素的iterator都失效。这是因为vetor,deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。所以不能使用erase(iter++)的方式，还好erase方法可以返回下一个有效的iterator。</p><pre class="line-numbers language-none"><code class="language-none">for (iter = cont.begin(); iter != cont.end();){   (*it)-&gt;doSomething();   if (shouldDelete(*iter))      iter = cont.erase(iter);  //erase删除元素，返回下一个迭代器   else      ++iter;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>迭代器失效：</p><pre class="line-numbers language-none"><code class="language-none">void vectorTest(){    vector&lt;int&gt; container;    for (int i = 0; i &lt; 10; i++)    {        container.push_back(i);    }     vector&lt;int&gt;::iterator iter;     for (iter = container.begin(); iter != container.end(); iter++)    {            if (*iter &gt; 3)              container.erase(iter);    }      for (iter = container.begin(); iter != container.end(); iter++)    {            cout&lt;&lt;*iter&lt;&lt;endl;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>报错是：vectoriterator not incrementable.</p><p><img src="https://img-blog.csdn.net/20151116221017698?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="请输入图片描述"></p><p>迭代器在执行++操作时报错！已经失效的迭代器不能再进行自增运算了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于序列式容器，比如vector，删除当前的iterator会使后面所有元素的iterator都失效。这是因为顺序容器内存是连续分配（分配一个数组作为内存），删除一个元素导致后面所有的元素会向前移动一个位置。（删除了一个元素，该元素后面的所有元素都要挪位置，所以，iter++，已经指向的是未知内存）。</p><p>但是erase方法可以返回下一个有效的iterator。所以代码做如下修改，就OK了。</p><pre class="line-numbers language-none"><code class="language-none">void vectorTest(){    vector&lt;int&gt; container;    for (int i = 0; i &lt; 10; i++)    {        container.push_back(i);    }     vector&lt;int&gt;::iterator iter;     for (iter = container.begin(); iter != container.end();)    {            if (*iter &gt; 3) {iter = container.erase(iter);}else {iter ++;}     }      for (iter = container.begin(); iter != container.end(); iter++)    {            cout&lt;&lt;*iter&lt;&lt;endl;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：vector是一个顺序容器，在内存中是一块连续的内存，当删除一个元素后，内存中的数据会发生移动，以保证数据的紧凑。所以删除一个数据后，其他数据的地址发生了变化，之前获取的迭代器根据原有的信息就访问不到正确的数据。</p><p>所以为了防止vector迭代器失效，常用如下方法：</p><pre class="line-numbers language-none"><code class="language-none">for (iter = container.begin(); iter != container.end(); )    {            if (*iter &gt; 3)              iter = container.erase(iter);    //erase的返回值是删除元素下一个元素的迭代器            else{                iter++;            }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样删除后iter指向的元素后，返回的是下一个元素的迭代器，这个迭代器是vector内存调整过后新的有效的迭代器。</p><p>&nbsp;</p><ol><li>对于关联容器(如map, set,multimap,multiset)，删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响。erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。</li></ol><pre class="line-numbers language-none"><code class="language-none">for (iter = cont.begin(); it != cont.end();){   (*iter)-&gt;doSomething();   if (shouldDelete(*iter))      cont.erase(iter++);   else      ++iter;} void mapTest(){    map&lt;int, string&gt; dataMap;      for (int i = 0; i &lt; 100; i++)    {           string strValue = "Hello, World";             stringstream ss;            ss&lt;&lt;i;            string tmpStrCount;            ss&gt;&gt;tmpStrCount;            strValue += tmpStrCount;            dataMap.insert(make_pair(i, strValue));    }     cout&lt;&lt;"MAP元素内容为："&lt;&lt;endl;     map&lt;int, string&gt;::iterator iter;    for (iter = dataMap.begin(); iter != dataMap.end(); iter++)    {            int nKey = iter-&gt;first;            string strValue = iter-&gt;second;            cout&lt;&lt;strValue&lt;&lt;endl;    }     cout&lt;&lt;"内容开始删除："&lt;&lt;endl;    /////////////////////////////////////////////擦除操作引发迭代器失效    for (iter = dataMap.begin(); iter != dataMap.end();iter++)    {            int nKey = iter-&gt;first;            string strValue = iter-&gt;second;            if (nKey % 2 == 0)           {                dataMap.erase(iter);    }           /* cout&lt;&lt;iter-&gt;second&lt;&lt;endl;*/    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>出错：<br><img src="https://img-blog.csdn.net/20151116221017698?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="请输入图片描述"></p><p>解析：dataMap.erase(iter)之后,iter就已经失效了，所以iter无法自增，即iter++就会出bug.解决方案，就是在iter失效之前，先自增。</p><pre class="line-numbers language-none"><code class="language-none">void mapTest(){    map&lt;int, string&gt; dataMap;      for (int i = 0; i &lt; 100; i++)    {           string strValue = "Hello, World";             stringstream ss;            ss&lt;&lt;i;            string tmpStrCount;            ss&gt;&gt;tmpStrCount;            strValue += tmpStrCount;            dataMap.insert(make_pair(i, strValue));    }     cout&lt;&lt;"MAP元素内容为："&lt;&lt;endl;     map&lt;int, string&gt;::iterator iter;    for (iter = dataMap.begin(); iter != dataMap.end(); iter++)    {            int nKey = iter-&gt;first;            string strValue = iter-&gt;second;            cout&lt;&lt;strValue&lt;&lt;endl;    }     cout&lt;&lt;"内容开始删除："&lt;&lt;endl;    /////////////////////////////////////////////擦除操作引发迭代器失效    for (iter = dataMap.begin(); iter != dataMap.end();)    {            int nKey = iter-&gt;first;            string strValue = iter-&gt;second;            if (nKey % 2 == 0)           {                dataMap.erase(iter++);auto a = iter;    }   else {   iter ++;   }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解析：dataMap.erase(iter++);这句话分三步走，先把iter传值到erase里面，然后iter自增，然后执行erase,所以iter在失效前已经自增了。</p><p>map是关联容器，以红黑树或者平衡二叉树组织数据，虽然删除了一个元素，整棵树也会调整，以符合红黑树或者二叉树的规范，但是单个节点在内存中的地址没有变化，变化的是各节点之间的指向关系。</p><p>所以在map中为了防止迭代器失效，在有删除操作时，常用如下方法：</p><pre class="line-numbers language-none"><code class="language-none">for (iter = dataMap.begin(); iter != dataMap.end(); )    {         int nKey = iter-&gt;first;         string strValue = iter-&gt;second;          if (nKey % 2 == 0)         {               map&lt;int, string&gt;::iterator tmpIter = iter;       iter++;               dataMap.erase(tmpIter);               //dataMap.erase(iter++) 这样也行          }else {      iter++;         }   }&nbsp;map&lt;int, string&gt;::iterator tmpIter =iter; iter++;&nbsp;dataMap.erase(tmpIter);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这几句的意思是,先保留要删除的节点迭代器，再让iter向下一个有意义的节点，然后删除节点。</p><p>所以这个操作结束后iter指向的是下一个有意义的节点，没有失效。</p><p>其实这三句话可以用在一句话代替，就是dataMap.erase(iter++);</p><p>解释是先让iter指向下一个有效的节点，但是返回给erase函数的是原来的iter副本。这个可能跟++这个操作的本身语法相关。</p><p>但是功能跟上面是一样的。</p><p>&nbsp;</p><p>总结：迭代器失效分三种情况考虑，也是非三种数据结构考虑，分别为数组型，链表型，树型数据结构。</p><p>数组型数据结构：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(*iter)(或erase(*iter))，然后在iter++，是没有意义的。解决方法：erase(*iter)的返回值是下一个有效迭代器的值。&nbsp;iter =cont.erase(iter);</p><p>链表型数据结构：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++).</p><p>树形数据结构：&nbsp;使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。</p><p>注意：经过erase(iter)之后的迭代器完全失效，该迭代器iter不能参与任何运算，包括iter++,*ite</p><p>————————————————<br>版权声明：本文为CSDN博主「BYR_jiandong」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/lujiandong1/article/details/49872763">https://blog.csdn.net/lujiandong1/article/details/49872763</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>libco  协程（2）细说协程的应用场景</title>
      <link href="libco-xie-cheng-2-xi-shuo-xie-cheng-de-ying-yong-chang-jing/"/>
      <url>libco-xie-cheng-2-xi-shuo-xie-cheng-de-ying-yong-chang-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h1><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>当我们要买一本书，但是淘宝上没有，我们选择一直刷新界面直到出现这本书。这种就叫做同步。 </p><p>也就是说，如果我们需要的事件没有到来我们需要一直等下去。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>我们要买口罩但是药店没有，这时候我们拜托店长等到有口罩的时候打电话通知我们去买，然后我们继续去忙其他事，这就叫做异步。</p><p>通常，异步的实现是向操作系统注册一个回调函数，当事件发生的时候调用回调函数。</p><h1 id="I-O复用模型（事件驱动模型）"><a href="#I-O复用模型（事件驱动模型）" class="headerlink" title="I/O复用模型（事件驱动模型）"></a>I/O复用模型（事件驱动模型）</h1><p>现在常见的I/O复用模型（如EPOLL,SELECT）都是通过事件回调的方式实现异步操作。具体关于I/O复用模型的内容在<a href="https://banthink.com/index.php/archives/215/">Linux I/O模型</a></p><p>以epoll为例，当事件到来的时候我们对相应的套接字进行read()操作，此时在系统同步调用中，是需要将系统缓冲区的数据拷贝到用户缓冲区中后才会返回，就是一直阻塞在这里。对于单线程程序来说，此时就好像卡住了一样。</p><p>那么如何解决这样的情况?</p><h2 id="引入多线程-多进程"><a href="#引入多线程-多进程" class="headerlink" title="引入多线程/多进程"></a>引入多线程/多进程</h2><p>因为处理数据的函数，都有可能造成阻塞导致整个程序卡住，那么我们可以用另外一个线程/进程来处理这个函数避免主线程卡住导致后续的请求得不到正确的处理。</p><p>主要的核心思想是： 一个线程（主线程）负责监听和分配需要处理的文件描述符，其他的线程去处理实际的数据逻辑，相互不干扰，从而实现了高并发。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>看似完美的方案实际上并不是很完美，首先我们要知道有当连接请求到来的时候我们需要并发的去处理相关请求，处理的线程有会有几个原因导致他不能一直进行下去：</p><ol><li><p>等待客户端发数据</p></li><li><p>数据库读取，因为数据库保存在硬盘之上，硬盘再快也比内存慢，因此从硬盘读取数据出来就会要等。</p></li><li><p>线程本身需要调用另一个服务器上的数据库/API才能获得数据。</p></li></ol><p>以上这几个原因都会导致我们线程卡住。尽管对于第一个问题可以用池化技术，直到有读请求到来的时候才分配线程进行读取，但是当没有请求的时候线程仍然存在仍然需要分配CPU，这样一来会大量浪费CPU的性能。</p><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程相对于其他线程/进程而言，他是一种用户态线程，需要用户手动进行切换调度的。也就是说当协程写入阻塞的时候会导致所在的整个线程都阻塞住，我们所要做的就是要在阻塞前将协程切换出去，等到所请求的I/O非阻塞的时候再切换回来。</p><h2 id="协程-I-O复用模型"><a href="#协程-I-O复用模型" class="headerlink" title="协程+I/O复用模型"></a>协程+I/O复用模型</h2><p>对于上述的方案，我们要如何知道I/O请求是非阻塞的呢? 对于所有的I/O无非就是：硬盘请求的读写，网络请求的读写。所有的读写都设置为非阻塞式的，同时在系统中注册相应的回调函数，当系统将这些请求处理完毕以后，再通过回调函数通知用户处理。</p><p>这样一来，对于一个单线程-多协程的服务器而言，当有大量的请求到来的时候，其浪费在阻塞I/O上面的时间很少，而且相比线程而言避免了CPU线程间切换的开销。</p><h2 id="协程的真正目的"><a href="#协程的真正目的" class="headerlink" title="协程的真正目的"></a>协程的真正目的</h2><p>其实协程的真正目的并不是为了去替换线程的使用，线程有线程的应用层场景，协程有协程的。真正的目的是为了让我们可以像使用同步的方法去写异步的调用。</p><p>怎么说呢? 还是回到刚刚服务器高并发的问题，其实最好的效率是将所有请求都注册一个处理的回调函数，直接在回调函数中进行操作就可以避免超级多的麻烦，但是更麻烦的事情却是这个注册回调函数本身。</p><p>首先是这样完全异步的方法使得我们阅读代码很麻烦，不能像看文章一样顺序感极强，而是这里一个那里一块。</p><p>其次就是在回调函数里面我们需要依靠这段数据获取另外一段数据，怎么办？继续回调。以此类推，回调函数的层次越多越影响代码的维护。</p><hr><p><em>其实本来第二篇打算写协程的封装，但是后面仔细一寻思怎么用在我之前的服务器上呢，怎么想都很奇怪，后来去反复查询协程的应用场景和如何使用，这才发现协程用在服务器上面是要和系统回调绑定起来用的，这样就可以在一个费时操作的时候及时切换出去，实现调度，避免一个协程占用线程太长时间导致其他协程得不到相应，从表现上看起来像是卡住了一样</em></p>]]></content>
      
      
      <categories>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>libco  协程（1）腾讯开源库环境切换分析</title>
      <link href="libco-xie-cheng-1-teng-xun-kai-yuan-ku-huan-jing-qie-huan-fen-xi/"/>
      <url>libco-xie-cheng-1-teng-xun-kai-yuan-ku-huan-jing-qie-huan-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="协程是什么"><a href="#协程是什么" class="headerlink" title="协程是什么?"></a>协程是什么?</h1><p>协程可以理解为用户自定义的一种线程，是在用户态下的线程。近几年协程慢慢取代了线程的地位，线程作为CPU执行调度的最小单位，相较于进程有CPU切换开销小的优点。那么协程凭什么能再某些场景下能够取代线程的地位呢? </p><h1 id="线程和协程的区别"><a href="#线程和协程的区别" class="headerlink" title="线程和协程的区别"></a>线程和协程的区别</h1><p>共同点：一样都拥有独立的堆栈和局部变量，稳定性是一样的，崩溃了同样会影响到整个程序。</p><p>线程：调度是由CPU进行调度的，在不用同步机制的情况下用户并不知道哪个线程先运行。由于调度是由CPU来进行的，在需要频繁的在用户态和内核态之间切换，在访问一些全局变量需要进行加锁。</p><p>协程：调度由用户自主完成，对于自己封装的协程库更需要自己实现一个调度器来实现并发功能。由于是用户自己进行切换的，并不需要像线程一样切换到内核态，只需要保存当前协程的上下文（寄存器），再切换到需要切换到的协程的上下文状态就可以了，有点类似于保存了调用函数状态的函数调用。由于是用户自己进行切换的，在访问一些全局变量上并不会出现多个协程同时对一个变量进行操作的情况，只需要在操作前判断一下状态就可以。</p><h1 id="为什么要用协程"><a href="#为什么要用协程" class="headerlink" title="为什么要用协程"></a>为什么要用协程</h1><p>协程主要实现的功能是能够在将要进行IO操作的时候先切换到其他协程中，等到有IO事件到来的时候再切换回刚刚切换出去的地方继续执行，最大程度的避免了IO阻塞时CPU的浪费，同时也能尽可能的利用CPU的性能。</p><p>但是协程并没有真正意义上实现并发，他对于IO密集的应用场景下的处理比线程更好，但是对于并发要求高，每个线程相互独立的时候协程就比不上线程了。</p><p>为什么在IO密集的时候比线程更好? 这一点在我刚接触协程的时候困扰了我很久，后来我想明白了。</p><p>举个例子。</p><p>我有一个EPOLL服务器，在监听大量的FD请求的同时还做一些其他的操作，当大量IO请求到来的时候，每个请求的时间极短但是存在一些数据是全局的，这时候需要加锁，那么此时CPU在上下文切换和锁机制中的开销就远比实际工作的开销大了。如果换成协程的话可以避免上述两个开销。</p><h1 id="前驱知识-函数调用过程"><a href="#前驱知识-函数调用过程" class="headerlink" title="前驱知识-函数调用过程"></a>前驱知识-函数调用过程</h1><p>在了解协程实现前，需要知道函数调用过程中堆栈的操作。</p><p>堆： 在用户空间中的增长是从低地址到高地址</p><p>栈： 增长是从高地址到低地址</p><p>   ebp EBP是”基址指针”(BASE POINTER), 它最经常被用作高级语言函数调用的”框架指针”(frame pointer).<br>   esp ESP为栈指针，用于指向栈的栈顶（下一个压入栈的活动记录的顶部） 当一个函数内出现函数调用的时候，会在这个函数的汇编代码中更新esp的值，因为存在函数调用意味着有新的活动记录会压栈</p><p>   eax EAX 是”累加器”(accumulator), 它是很多加法乘法指令的缺省寄存器。</p><p>   ebx EBX 是”基地址”(base)寄存器, 在内存寻址时存放基地址。</p><p>   ecx ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。</p><p>   edx EDX 则总是被用来放整数除法产生的余数。</p><p>   esi/edi ESI/EDI分别叫做”源/目标索引寄存器”(source/destination index),因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串.</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>下面的实验环境是在visual stdio 2019下</p><pre class="line-numbers language-none"><code class="language-none"># include &lt;stdio.h&gt;int add(int a,int b){    int sum=0;    sum=a+b;    return sum;}int main(){    int a=3,b=2,sum;    sum=add(a,b);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将断点下在main函数的入口上。</p><p><img src="https://banthink.com/usr/uploads/2020/03/416489951.jpg" alt="函数调用1.jpg"></p><p>在进程空间的栈段，我们所调用的每一段函数都会在栈中拥有一段自己的栈帧（可以理解为函数自己的内部空间，局部变量和寄存器值）。</p><p>如图，main的结尾并不是在随着函数块结束而结束，而是后面还有一段出栈操作，后面会详细讲。</p><p>我们可以看到在调用sum()入口处会先从右到左的将参数压栈，之后的call(将下一个指令的地址压栈并跳转到函数入口处)。</p><p><img src="https://banthink.com/usr/uploads/2020/03/1877499498.jpg" alt="函数调用2.jpg"></p><p>至此，从下图中我们可以看到main的栈帧是从哪里到哪里。在push ebp（保存main函数的栈底，方便后续恢复现场）后，首先是进行一个创建局部变量的空间（大小为0x0cc）,之后再将寄存器的值进行压栈，这就是保存main()的上下文操作。</p><p><img src="https://banthink.com/usr/uploads/2020/03/2786122543.jpg" alt="协程笔记 -14.jpg"></p><p>回到一开始的，main()函数结束后的出栈操作是什么?联想函数调用的过程，实际上就是在恢复现场，其实还有个内置函数用于调用main函数并获取其返回值用于当进程结束退出后收集其状态。</p><p>（一定要记得栈的增长是从高到低的，也就是说EBP 的值永远会比ESP高）</p><h1 id="Libco中的coctx-swap-S（最早版本的）"><a href="#Libco中的coctx-swap-S（最早版本的）" class="headerlink" title="Libco中的coctx_swap.S（最早版本的）"></a>Libco中的coctx_swap.S（最早版本的）</h1><p>在上面了解了函数调用的过程后， 我们就能更好的理解协程是怎么实现的了。</p><p>下述的coctx_swap.S是最早的一个开源版本，但是因为存在一个BUG： 因为在执行coctx_swap过程中esp指针的位置是被改变的。当这个时候发生了一个信号中断(例如SIGINT)，由于此时的栈顶指针不是指向主栈的栈顶，在压栈出栈的过程中会发生错误。后面改成了move操作来代替pop和push就好多了。但是没有用新的是我觉得这个更好理解，思想是一样的。</p><pre class="line-numbers language-none"><code class="language-none">/** Tencent is pleased to support the open source community by making Libco available.* Copyright (C) 2014 THL A29 Limited, a Tencent company. All rights reserved.** Licensed under the Apache License, Version 2.0 (the "License");* you may not use this file except in compliance with the License.* You may obtain a copy of the License at**http://www.apache.org/licenses/LICENSE-2.0** Unless required by applicable law or agreed to in writing,* software distributed under the License is distributed on an "AS IS" BASIS,* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.* See the License for the specific language governing permissions and* limitations under the License.*/.globl coctx_swap   //用来让一个符号（coctx_swap）对链接器可见，可以供其他链接对象模块使用。# if !defined( __APPLE__ ).type  coctx_swap, @function# endifcoctx_swap:# if defined(__i386__)//在执行下面的汇编代码之前已经执行了将参数压栈，将返回地址压栈的操作，当前esp指向的内存的值应该为下一条指令的地址，即调用coctx_swap之后的指令（见co_routine.cpp co_swap函数）leal 4(%esp), %eax //sp   R[eax]=R[esp]+4 R[eax]的值应该为coctx_swap的第一个参数在栈中的地址movl 4(%esp), %esp  //    R[esp]=Mem[R[esp]+4] 将esp所指向的地址改为第一个参数的实际地址。由于coctx_t 是在堆上开辟的空间,所以此时指向的是: | *ss_sp  |   high address| ss_size || regs[7] || regs[6] || regs[5] || regs[4] || regs[3] || regs[2] || regs[1] || regs[0] |   low address--------------   &lt;---ESPleal 32(%esp), %esp //parm a : &amp;regs[7] + sizeof(void*)   push 操作是以esp的值为基准，push一个值,则esp的值减一个单位（因为是按栈区的操作逻辑，从高位往低位分配地址），但ctx是在堆区，所以应将esp指向reg[7]，然后从eax到-4(%eax)push    //保存寄存器值到栈中，实际对应coctx_t-&gt;regs 数组在栈中的位置（参见coctx.h 中coctx_t的定义）此时：| *ss_sp  |   high address| ss_size |--------------   &lt;---ESP| regs[7] || regs[6] || regs[5] || regs[4] || regs[3] || regs[2] || regs[1] || regs[0] |   low addresspushl %eax // 压入的第一个参数的地址pushl %ebp  pushl %esipushl %edipushl %edxpushl %ecxpushl %ebxpushl -4(%eax) //将函数返回地址压栈，即coctx_swap 之后的指令地址，保存返回地址,保存到coctx_t-&gt;regs[0]    //恢复运行目标routine时的环境（各个寄存器的值和栈状态）movl 4(%eax), %esp //parm b -&gt; &amp;regs[0] //切换esp到目标 routine  ctx在栈中的起始地址,这个地址正好对应regs[0],pop一次 esp会加一个单位的值popl %eax  //ret func addr regs[0] 暂存返回地址到 EAX//恢复当时的寄存器状态popl %ebx  // regs(https://banthink.com/usr/uploads/2020/03/416489951.jpg)popl %ecx  // regs(https://banthink.com/usr/uploads/2020/03/2786122543.jpg)popl %edx  // regs(https://banthink.com/usr/uploads/2020/03/1877499498.jpg)popl %edi  // regs[4]popl %esi  // regs[5]popl %ebp  // regs[6]popl %esp  // regs[7]  //将返回地址压栈pushl %eax //将返回地址压栈xorl %eax, %eax  //异或操作 将结果送到eax中(实际就是把EAX清0)//返回，这里返回之后就切换到目标routine了，C++代码中调用coctx_swap的地方之后的代码将得不到立即执行ret  # elif defined(__x86_64__)leaq 8(%rsp),%raxleaq 112(%rdi),%rsppushq %raxpushq %rbxpushq %rcxpushq %rdxpushq -8(%rax) //ret func addrpushq %rsipushq %rdipushq %rbppushq %r8pushq %r9pushq %r12pushq %r13pushq %r14pushq %r15movq %rsi, %rsppopq %r15popq %r14popq %r13popq %r12popq %r9popq %r8popq %rbppopq %rdipopq %rsipopq %rax //ret func addrpopq %rdxpopq %rcxpopq %rbxpopq %rsppushq %raxxorl %eax, %eaxret# endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Libco协程库"><a href="#Libco协程库" class="headerlink" title="Libco协程库"></a>Libco协程库</h1><p>下面以32位的API为例，coctx_make 主要用于构建要切换的协程的上下文。</p><pre class="line-numbers language-none"><code class="language-none"> coctx_t : 目标协程的上下文结构体。struct coctx_t{    char *regs[8],  //存放当前环境的寄存器值    int ss_size,   //栈帧大小    char *ss_sp  //栈帧的栈顶}coctx_pfn_t :函数指针--&gt;typedef void* (*coctx_pfn_t)( void* s, void* s2 )const void *s : 被调函数所在的函数上下文(coctx_t)const void * s2: 被调函数的上下文<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在libco库中的堆是有一个内存管理器进行统一的申请和删除的。也就是说ctx所在的空间实际是堆，但是我们要把它当做栈来使用。</p><pre class="line-numbers language-none"><code class="language-none">int coctx_make( coctx_t *ctx,coctx_pfn_t pfn,const void *s,const void *s1 ){//make room for coctx_paramchar *sp = ctx-&gt;ss_sp + ctx-&gt;ss_size - sizeof(coctx_param_t);//分配参数所需栈空间sp = (char*)((unsigned long)sp &amp; -16L);//将地址低4位置零,地址应该是一个栈区一个存储单位的大小的整数倍。这里涉及到字节对齐的方法，为了加快内存读取效率   //将参数存放在栈内，发生函数调用时，参数是从右往左压栈，即最右边的参数应该在高地址，第一个参数应该在相对的低地址区域coctx_param_t* param = (coctx_param_t*)sp ;//coctx_param_t 的两个参数 s1,s2由于其声明顺序，则s1的地址相对于s2是低地址（其实还会考虑的内存优化，当结构体内部是不同类型参数时，其存储顺序可能与声明顺序不一致，但这里不存在这个问题）param-&gt;s1 = s;param-&gt;s2 = s1;memset(ctx-&gt;regs, 0, sizeof(ctx-&gt;regs));//将寄存器信息初始化为0ctx-&gt;regs[ kESP ] = (char*)(sp) - sizeof(void*);//设置栈顶指针，并留出函数调用结束后返回地址的空间ctx-&gt;regs[ kEIP ] = (char*)pfn;//设置下一条指令的地址return 0;}//------- ss_sp + ss_size       [high address]//|pading| 这里是对齐区域//|s2    |//|s1    |        //|预留IP|//-------  &lt;- sp//|      |//------- ss_sp                 [low address]//在构建完毕后的coctx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>ctx-&gt;regs[ kESP ] = (char*)(sp) - sizeof(void*) </code></pre><p>这一句是为汇编代码中的<br><code>popl %esp  // regs[7]</code><br><code>pushl %eax</code><br>这两句做准备的，因为当pop后ESP所指向的位置就是上图中构建完毕后的coctx的SP所指向的位置，这是后进行push操作，就可以把eax中存储的返回地址压栈而不会覆盖参数s1。（push操作是先压栈，后esp-4）</p><p>Q1：那么此时有个疑问就是sp到ss_sp这段空间是干嘛用的？</p><p>A:这段空间就是上述我自己画的图里面局部变量的位置。但是这里存在一个问题，当栈中所需要的内存空间过大超出了我们预先开辟的ss_size空间的话，可能存在一个<code>越界现象</code>，所以我们一般要尽可能的使得这段空间够大不会越界。（一般也不至于越界）</p><p>Q2： 每个协程实际上用不了默认开辟的空间这么多，不就造成空间浪费?</p><p>A: 是的，这样就引出了共享栈的概念。</p><h1 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h1><p>先解释一下这两个的概念：</p><p>共享栈指的是在所有协程运行的过程中，它们用的任务栈是同一个栈</p><p>独立栈指的是在所有协程运行的过程中，它们用的任务栈是各自的栈，我们上面所涉及的都是独立栈</p><p>那么共享栈的目的实际就是将一个大的空间抽分出来作为共享栈，所有的协程的任务栈都在这个上面，当需要保存自己当前的任务栈时，先重新申请一块大小为当前任务栈的空间，再将任务栈保存进去。然后将共享栈的所有权切换为被调用的协程。</p><p>这样一来，相当于我们将每个保存任务栈的空间都进行了压缩处理，相较于每个协程都使用一个独立栈节约了很多空间，但是我们同时也付出了内存拷贝和额外空间申请的开销，时间换空间。</p><p>至此，现在协程的实现原理都已经搞懂了吧。</p>]]></content>
      
      
      <categories>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程空间地址</title>
      <link href="linux-jin-cheng-kong-jian-di-zhi/"/>
      <url>linux-jin-cheng-kong-jian-di-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>版权声明：本文为CSDN博主「张哲BJUT」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/zhangzhebjut/article/details/39060253">https://blog.csdn.net/zhangzhebjut/article/details/39060253</a></p></blockquote><h1 id="进程空间分布"><a href="#进程空间分布" class="headerlink" title="进程空间分布"></a>进程空间分布</h1><p><img src="https://banthink.com/usr/uploads/2020/03/1610948911.jpg" alt="进程地址空间.jpg"></p><h3 id="程序段-Text"><a href="#程序段-Text" class="headerlink" title="程序段(Text)"></a>程序段(Text)</h3><p>程序代码在内存中的映射，存放函数体的二进制代码。</p><h3 id="初始化过的数据-Data"><a href="#初始化过的数据-Data" class="headerlink" title="初始化过的数据(Data)"></a>初始化过的数据(Data)</h3><p>在程序运行初已经对变量进行初始化的数据。</p><h3 id="未初始化过的数据-BSS"><a href="#未初始化过的数据-BSS" class="headerlink" title="未初始化过的数据(BSS)"></a>未初始化过的数据(BSS)</h3><p>在程序运行初未对变量进行初始化的数据。</p><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈&nbsp;(Stack)"></a>栈&nbsp;(Stack)</h3><p>存储局部、临时变量，函数调用时，存储函数的返回指针，用于控制函数的调用和返回。在程序块开始时自动分配内存,结束时自动释放内存，其操作方式类似于数据结构中的栈。</p><h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆&nbsp;(Heap)"></a>堆&nbsp;(Heap)</h3><p>存储动态内存分配,需要程序员手工分配,手工释放.注意它与数据结构中的堆是两回事，分配方式类似于链表。</p><h1 id="内核空间和用户空间"><a href="#内核空间和用户空间" class="headerlink" title="内核空间和用户空间"></a>内核空间和用户空间</h1><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux的虚拟地址空间范围为0～4G，Linux内核将这4G字节的空间分为两部分，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）供各个进程使用，称为“用户空间。因为每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p><p>&nbsp; &nbsp; Linux使用两级保护机制：0级供内核使用，3级供用户程序使用，每个进程有各自的私有用户空间（0～3G），这个空间对系统中的其他进程是不可见的，最高的1GB字节虚拟内核空间则为所有进程以及内核所共享。</p><p>&nbsp; &nbsp; 内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。 虽然内核空间占据了每个虚拟空间中的最高1GB字节，但映射到物理内存却总是从最低地址（0x00000000），另外，使用虚拟地址可以很好的保护内核空间被用户空间破坏，虚拟地址到物理地址转换过程有操作系统和CPU共同完成(操作系统为CPU设置好页表，CPU通过MMU单元进行地址转换)。&nbsp; &nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 注：多任务操作系统中的每一个进程都运行在一个属于它自己的内存沙盒中，这个沙盒就是虚拟地址空间（virtual address space），在32位模式下，它总是一个4GB的内存地址块。这些虚拟地址通过页表（page table）映射到物理内存，页表由操作系统维护并被处理器引用。每个进程都拥有一套属于它自己的页表。</p><h1 id="进程内存布局"><a href="#进程内存布局" class="headerlink" title="进程内存布局"></a>进程内存布局</h1><p>&nbsp;Linux进程标准的内存段布局，如下图所示，地址空间中的各个条带对应于不同的内存段（memory segment），如：堆、栈之类的。</p><p><img src="https://banthink.com/usr/uploads/2020/03/1610948911.jpg" alt="进程地址空间.jpg"></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>&nbsp; &nbsp; &nbsp;进程地址空间中最顶部的段是栈，大多数编程语言将之用于存储函数参数和局部变量。调用一个方法或函数会将一个新的栈帧（stack frame）压入到栈中，这个栈帧会在函数返回时被清理掉。由于栈中数据严格的遵守FIFO的顺序，这个简单的设计意味着不必使用复杂的数据结构来追踪栈中的内容，只需要一个简单的指针指向栈的顶端即可，因此压栈（pushing）和退栈（popping）过程非常迅速、准确。进程中的每一个线程都有属于自己的栈。</p><p>&nbsp; &nbsp; &nbsp; 通过不断向栈中压入数据，超出其容量就会耗尽栈所对应的内存区域，这将触发一个页故障（page fault），而被Linux的expand_stack()处理，它会调用acct_stack_growth()来检查是否还有合适的地方用于栈的增长。如果栈的大小低于RLIMIT_STACK（通常为8MB），那么一般情况下栈会被加长，程序继续执行，感觉不到发生了什么事情。这是一种将栈扩展到所需大小的常规机制。然而，如果达到了最大栈空间的大小，就会栈溢出（stack overflow），程序收到一个段错误（segmentation fault）。</p><p>&nbsp; &nbsp; &nbsp;注:动态栈增长是唯一一种访问未映射内存区域而被允许的情形，其他任何对未映射内存区域的访问都会触发页错误，从而导致段错误。一些被映射的区域是只读的，因此企图写这些区域也会导致段错误。</p><h2 id="内存映射段"><a href="#内存映射段" class="headerlink" title="内存映射段"></a>内存映射段</h2><p>&nbsp; &nbsp; &nbsp;在栈的下方是内存映射段，内核将文件的内容直接映射到内存。任何应用程序都可以通过Linux的mmap()系统调用或者Windows的CreateFileMapping()/MapViewOfFile()请求这种映射。内存映射是一种方便高效的文件I/O方式，所以它被用来加载动态库。创建一个不对应于任何文件的匿名内存映射也是可能的，此方法用于存放程序的数据。在Linux中，如果你通过malloc()请求一大块内存，C运行库将会创建这样一个匿名映射而不是使用堆内存。“大块”意味着比MMAP_THRESHOLD还大，缺省128KB，可以通过mallocp()调整。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>&nbsp; &nbsp; &nbsp; 与栈一样，堆用于运行时内存分配；但不同的是，堆用于存储那些生存期与函数调用无关的数据。大部分语言都提供了堆管理功能。在C语言中，堆分配的接口是malloc()函数。如果堆中有足够的空间来满足内存请求，它就可以被语言运行时库处理而不需要内核参与，否则，堆会被扩大，通过brk()系统调用来分配请求所需的内存块。堆管理是很复杂的，需要精细的算法来应付我们程序中杂乱的分配模式，优化速度和内存使用效率。处理一个堆请求所需的时间会大幅度的变动。实时系统通过特殊目的分配器来解决这个问题。堆在分配过程中可能会变得零零碎碎，如下图所示：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p><p>一般由程序员分配释放，&nbsp;若程序员不释放，程序结束时可能由OS回收&nbsp;。注意它与数据结构中的堆是两回事，分配方式类似于链表。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p><h2 id="BBS和数据段"><a href="#BBS和数据段" class="headerlink" title="BBS和数据段"></a>BBS和数据段</h2><p>&nbsp; &nbsp; &nbsp; 在C语言中，BSS和数据段保存的都是静态（全局）变量的内容。区别在于BSS保存的是未被初始化的静态变量内容，他们的值不是直接在程序的源码中设定的。BSS内存区域是匿名的，它不映射到任何文件。如果你写static intcntActiveUsers，则cntActiveUsers的内容就会保存到BSS中去。<br>&nbsp; &nbsp; &nbsp;&nbsp;数据段保存在源代码中已经初始化的静态变量的内容。数据段不是匿名的，它映射了一部分的程序二进制镜像，也就是源代码中指定了初始值的静态变量。所以，如果你写static int cntActiveUsers=10，则cntActiveUsers的内容就保存在了数据段中，而且初始值是10。尽管数据段映射了一个文件，但它是一个私有内存映射，这意味着更改此处的内存不会影响被映射的文件。<br>&nbsp; &nbsp; &nbsp; 你可以通过阅读文件/proc/pid_of_process/maps来检验一个Linux进程中的内存区域。记住：一个段可能包含许多区域。比如，每个内存映射文件在mmap段中都有属于自己的区域，动态库拥有类似BSS和数据段的额外区域。有时人们提到“数据段”，指的是全部的数据段+BSS+堆。</p><p>&nbsp; &nbsp; &nbsp;你还可以通过nm和objdump命令来察看二进制镜像，打印其中的符号，它们的地址，段等信息。最后需要指出的是，前文描述的虚拟地址布局在linux中是一种“灵活布局”，而且作为默认方式已经有些年头了，它假设我们有值RLIMT_STACK。但是，当没有该值得限制时，Linux退回到“经典布局”，如下图所示：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p><h1 id="栈与堆的区别"><a href="#栈与堆的区别" class="headerlink" title="栈与堆的区别"></a>栈与堆的区别</h1><p><img src="https://banthink.com/usr/uploads/2020/03/1032280628.png" alt="堆栈区别.png"></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从 epoll 和 select 的应用场景来更好的了解他们</title>
      <link href="cong-epoll-he-select-de-ying-yong-chang-jing-lai-geng-hao-de-liao-jie-ta-men/"/>
      <url>cong-epoll-he-select-de-ying-yong-chang-jing-lai-geng-hao-de-liao-jie-ta-men/</url>
      
        <content type="html"><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><table><thead><tr><th>·</th><th>select</th><th>epoll</th></tr></thead><tbody><tr><td>实现机制</td><td>轮询+内存拷贝+集合</td><td>callback+红黑树+mmap+就绪链表</td></tr><tr><td>主要消耗</td><td>内存拷贝和大量的轮询</td><td>callback函数</td></tr><tr><td>最大监测FD数</td><td>32位系统1024</td><td>nolimit</td></tr><tr><td>兼容性、跨平台性</td><td>POSIX标准</td><td>Linux特有</td></tr><tr><td>FD增加的影响</td><td>性能线性下降</td><td>几乎无影响</td></tr><tr><td>消息传递方式</td><td>内存拷贝</td><td>内存映射</td></tr></tbody></table><p>表格取自  <a href="https://blog.csdn.net/woyimibayi/article/details/79196629">基于表格形式的select，poll，epoll对比-IO多路复用函数的应用场景</a></p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>从上面的比较可以总结：</p><p>select 主要的消耗在于重复的内存拷贝和大量的轮询操作上</p><p>epoll  主要的消耗是向内核注册的回调函数上面，文件描述符十分活跃的时候，CPU需要不断的切换上下文，将活跃的FD挂载在链表上，由于有链表的存在使得epoll和poll都可以突破1024</p><p>在一开始学习的时候，以为在客户端连接的情况下epoll 都是最好的选择，其实并不然。</p><p>当文件描述符在1024以内的时候，select所带来的开支并不会总是epoll 小。</p><p>为什么呢?</p><p>假设如下场景： 当连接数在1024的时候，这1024条连接全部都是活跃的，时刻都有请求到来，这时候如果使用的是EPOLL，由于EPOLL是事件驱动的，虽然相比于SELECT 避免了FD集合拷贝和轮询的开销，但是频繁的回调函数切换比前者开销更大，同时还需要将活跃的FD插入到链表并将链表拷贝到用户态中，更影响效率。</p><p>反观select ，每次拷贝的文件描述符集合大小都是固定的，且轮询操作并不需要涉及到函数切换，在FD活跃的情况下远比EPOLL效率高。</p><p>由于限制select效率的最大问题是两次内存拷贝（从用户态到内核态，从内核态到用户态），由于活跃文件描述符过多，EPOLL优势并不明显，相反事件驱动所带来的消耗远比减少一次内存拷贝要来的多。（EPOLL的内存拷贝发生在将就绪链表中的socket拷贝到用户态）</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库的存储引擎 事务 索引</title>
      <link href="shu-ju-ku-de-cun-chu-yin-qing-shi-wu-suo-yin/"/>
      <url>shu-ju-ku-de-cun-chu-yin-qing-shi-wu-suo-yin/</url>
      
        <content type="html"><![CDATA[<p><img src="https://banthink.com/usr/uploads/2020/03/3936346851.jpg" alt="存储引擎.jpg"></p><p><img src="https://banthink.com/usr/uploads/2020/03/997137897.jpg" alt="事务.jpg"></p><p><img src="https://banthink.com/usr/uploads/2020/03/2152586984.jpg" alt="索引1.jpg"></p><p><img src="https://banthink.com/usr/uploads/2020/03/800072992.jpg" alt="索引2.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于TCP连接方面的一些问题</title>
      <link href="guan-yu-tcp-lian-jie-fang-mian-de-yi-xie-wen-ti/"/>
      <url>guan-yu-tcp-lian-jie-fang-mian-de-yi-xie-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP连接只能由客户端主动关闭连接吗"><a href="#TCP连接只能由客户端主动关闭连接吗" class="headerlink" title="TCP连接只能由客户端主动关闭连接吗?"></a>TCP连接只能由客户端主动关闭连接吗?</h2><p>不是，服务端可以主动关闭连接的。</p><h2 id="滑动窗口和拥塞控制中的拥塞窗口是一个概念吗"><a href="#滑动窗口和拥塞控制中的拥塞窗口是一个概念吗" class="headerlink" title="滑动窗口和拥塞控制中的拥塞窗口是一个概念吗?"></a>滑动窗口和拥塞控制中的拥塞窗口是一个概念吗?</h2><p>滑动窗口和拥塞窗口是在解决两个正交的问题，只不过方法上都是在调整主机发送数据包的速率。滑动窗口是解决Flow Control的问题，就是如果接收端和发送端对数据包的处理速度不同，如何让双方达成一致。而拥塞窗口是解决多主机之间共享网络时出现的拥塞问题的一个修正。客观来说网络信道带宽不可能允许所有主机同时全速通信，所以如果全部主机都全速发送数据包，导致网络流量超过可用带宽，那么由于TCP的设计数据包会大量丢失，于是由于重传机制的触发会进一步加剧拥塞，潜在的导致网络不可用。</p><h2 id="TCP是怎么保证数据包的有序传递的"><a href="#TCP是怎么保证数据包的有序传递的" class="headerlink" title="TCP是怎么保证数据包的有序传递的?"></a>TCP是怎么保证数据包的有序传递的?</h2><p>数据包是不一定先发先到，但是对于TCP有一点特殊，若我们接受的数据包是在应用层，并且应用层用的是TCP的传输协议的话，这个顺序是保证，这个顺序的保证是在<strong>传输层</strong>保证的，举个例子：</p><p>client发生数据A,B给server，使用的TCP传输，client发送毫无疑问是先发送A，然后发送B，但是有些搞网络的同学可能会有这个疑问，A跟B在物理层走的链路不一样，传输速度不一样，B是会比A先到达Server,这个是没有错的，但是这个数据包被接受是在网络层跟传输层，请记住网络跟传输层的作用，网络层是保证同一个包的完整，就是说若你的传输层发出的包过大，在网络层（也就是IP层）会被分包，同时在Sever的网络接受的时候会被组包，有一个完整的包才会交给传输层，若包不完整是会丢弃，同时他也不保证你的包的是否达到，数据包的保证是在传输层做的，就是说若传输层(TCP协议才会，UDP并不保证)没有收到对方的确认包，会有超时重传，每个数据包也是有序列号的，同时，传输层就是根据这个<strong>序列号</strong>来保证A,B包的顺序，即使B比A先到达了，TCP也会是等A到达之后，先把A提交给应用层，再把B的数据提交给应用层，从而保证了，同一条TCP链接，先发的包先到</p><p>注：这个顺序的保证是传输层做的，TCP这个协议保证的，UDP并不保证，网络层接收包的顺序是错乱的。</p><p><img src="https://banthink.com/usr/uploads/2020/03/2544926238.png" alt="有序发包.png"></p><h2 id="发送不定长数据的时候，包尾的作用是什么"><a href="#发送不定长数据的时候，包尾的作用是什么" class="headerlink" title="发送不定长数据的时候，包尾的作用是什么"></a>发送不定长数据的时候，包尾的作用是什么</h2><p>包尾： 和包头一起过滤非法包，那么什么是非法包呢？ 例如接收到的包头中标明数据体的长度是m，但是实际发送的数据包大小为M(M&gt;m),如果没有包尾存在就会认为接收了m长度数据是正确的，但是实际整个包都是错误的，应该丢弃。所以需要加入包尾保证包体大小</p><h2 id="保护消息边界和流"><a href="#保护消息边界和流" class="headerlink" title="保护消息边界和流"></a>保护消息边界和流</h2><p>那么什么是保护消息边界和流呢?</p><p>保护消息边界，就是指传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包。而面向流则是指无保护消息保护边界的，如果发送端连续发送数据，接收端有可能在一次接收动作中，会接收两个或者更多的数据包。</p><p>例如，我们连续发送三个数据包，大小分别是2k，4k ，8k,这三个数据包，都已经到达了接收端的网络堆栈中，如果使用UDP协议，不管我们使用多大的接收缓冲区去接收数据，我们必须有三次接收动作，才能够把所有的数据包接收完.而使用TCP协议，我们只要把接收的缓冲区大小设置在14k以上，我们就能够一次把所有的数据包接收下来，只需要有一次接收动作。</p><p>注意：</p><p>这就是因为UDP协议的保护消息边界使得每一个消息都是独立的。而流传输却把数据当作一串数据流，他不认为数据是一个一个的消息。所以有很多人在使用tcp协议通讯的时候，并不清楚tcp是基于流的传输，当连续发送数据的时候，他们时常会认识tcp会丢包。其实不然，因为当他们使用的缓冲区足够大时，他们有可能会一次接收到两个甚至更多的数据包，而很多人往往会忽视这一点，只解析检查了第一个数据包，而已经接收的其他数据包却被忽略了。所以大家如果要作这类的网络编程的时候,必须要注意这一点。</p><p>结论：</p><p>（1）TCP为了保证可靠传输，尽量减少额外开销（每次发包都要验证），因此采用了流式传输，面向流的传输，相对于面向消息的传输，可以减少发送包的数量，从而减少了额外开销。但是，对于数据传输频繁的程序来讲，使用TCP可能会容易粘包。当然，对接收端的程序来讲，如果机器负荷很重，也会在接收缓冲里粘包。这样，就需要接收端额外拆包，增加了工作量。因此，这个特别适合的是数据要求可靠传输，但是不需要太频繁传输的场合（两次操作间隔100ms，具体是由TCP等待发送间隔决定的，取决于内核中的socket的写法）</p><p>（2）UDP，由于面向的是消息传输，它把所有接收到的消息都挂接到缓冲区的接受队列中，因此，它对于数据的提取分离就更加方便，但是，它没有粘包机制，因此，当发送数据量较小的时候，就会发生数据包有效载荷较小的情况，也会增加多次发送的系统发送开销（系统调用，写硬件等）和接收开销。因此，应该最好设置一个比较合适的数据包的包长，来进行UDP数据的发送。（UDP最大载荷为1472，因此最好能每次传输接近这个数的数据量，这特别适合于视频，音频等大块数据的发送，同时，通过减少握手来保证流媒体的实时性）</p><h2 id="TCP连接中如果客户端突然断线怎么办"><a href="#TCP连接中如果客户端突然断线怎么办" class="headerlink" title="TCP连接中如果客户端突然断线怎么办"></a>TCP连接中如果客户端突然断线怎么办</h2><p>如果套接字中开启了keepactive，且断线的时间超出了keepactive时间，TCP是会检测到客户端出错并主动关闭连接。但是如果在keepactive时间内，且此期间服务器并没有对这条连接进行数据传输，那么TCP是仍然认为这条连接是有效的，赶紧连线还能抢救一下。</p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>序列化工具  protobuf 介绍</title>
      <link href="xu-lie-hua-gong-ju-protobuf-jie-shao/"/>
      <url>xu-lie-hua-gong-ju-protobuf-jie-shao/</url>
      
        <content type="html"><![CDATA[<p>以下内容大部分转载自<a href="https://www.cnblogs.com/autyinjing/p/6495103.html">https://www.cnblogs.com/autyinjing/p/6495103.html</a>  Protobuf学习 - 入门</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p> Google Protocol Buffer(简称 Protobuf)是一种轻便高效的结构化数据存储格式，平台无关、语言无关、可扩展，可用于通讯协议和数据存储等领域。</p><h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><p>　　- 平台无关，语言无关，可扩展；（尤为重要）<br>　　- 提供了友好的动态库，使用简单；<br>　　- 解析速度快，比对应的XML快约20-100倍；<br>　　- 序列化数据非常简洁、紧凑，与XML相比，其序列化之后的数据量约为1/3到1/10。</p><h2 id="为什么相比简单的struct-结构protobuf能够实现高效存储"><a href="#为什么相比简单的struct-结构protobuf能够实现高效存储" class="headerlink" title="为什么相比简单的struct 结构protobuf能够实现高效存储"></a>为什么相比简单的struct 结构protobuf能够实现高效存储</h2><p>采用对数据进行二进制压缩，因为数据在机器语言层面上的表现都是二进制，而简单的 struct 结构体中包含的基本类型如int ，在32位机器中占32位，然而当我们实际传输的时候并不是这32位都用到，protobuf就是将这一情况进行压缩达到的高效序列化数据。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre class="line-numbers language-none"><code class="language-none">源码下载地址： https://github.com/google/protobuf 需要安装依赖的库： autoconf automake libtool curl make g++ unzip  ./autogen.sh./configuremakemake checksudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>和早期QT需要手动编写ui文件后用程序生成.h、.cpp一样，我们同样需要编写proto文件，在里面定义结构化的数据</p><p>proto文件内容如下: </p><pre class="line-numbers language-none"><code class="language-none">// Filename: test.proto  注释同样用方式同C++syntax="proto2";  //声明使用的编译器版本为v2。package addressbook;  //声明包名，类似于namespace//import "src/demo.proto"; //类似于C++中的includemessage Person {     //类似于C++中的class    required string name = 1;/* 1 是字段的标识号，在消息定义中，每个字段都有唯一的一个数字标识号，这些标识号是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。标识号的范围在：1 ~ 229 - 1，其中[19000－19999]为Protobuf预留，不能使用。*/    required int32 id = 2;    optional string email = 3;/*三种字段修饰符 required : 必须要设置的optional : 可以有0或1个值repeated : 可以重复任意多次(包括0)*/    enum PhoneType {        MOBILE = 0;        HOME = 1;        WORK = 2;    }  //类内声明，同C++    message PhoneNumber {        required string number = 1;        optional PhoneType type = 2 [default = HOME];  //设置默认值为HOME    }    repeated PhoneNumber phone = 4;}message AddressBook {    repeated Person person_info = 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将proto转换成C++类的声明就很容易上手理解了。</p><p>接下来需要将proto编译成.h 和.cc 文件供用户程序调用</p><p>protoc是proto文件的编译器，目前可以将proto文件编译成C++、Java、Python三种代码文件，编译格式如下：</p><pre class="line-numbers language-none"><code class="language-none">protoc  --cpp_out=. test.proto-I=&lt;pkg locate&gt;   import 中引用的proto文件如果不在同一目录需要用这个来引用--cpp_out=&lt;output locate&gt; 编译成C++ 代码文件输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的命令会生成xxx.pb.h 和 xxx.pb.cc两个C++文件。</p><h1 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h1><p>现在编写一个C++ 文件 </p><pre class="line-numbers language-none"><code class="language-none"># include &lt;iostream&gt;# include "test.pb.h"int main(int argc, const char* argv[]){    addressbook::AddressBook person;    addressbook::Person* pi = person.add_person_info();    pi-&gt;set_name("aut");    pi-&gt;set_id(1219);    std::cout &lt;&lt; "before clear(), id = " &lt;&lt; pi-&gt;id() &lt;&lt; std::endl;    pi-&gt;clear_id();    std::cout &lt;&lt; "after  clear(), id = " &lt;&lt; pi-&gt;id() &lt;&lt; std::endl;    pi-&gt;set_id(1087);    if (!pi-&gt;has_email())        pi-&gt;set_email("autyinjing@126.com");    addressbook::Person::PhoneNumber* pn = pi-&gt;add_phone();    pn-&gt;set_number("021-8888-8888");    pn = pi-&gt;add_phone();    pn-&gt;set_number("138-8888-8888");    pn-&gt;set_type(addressbook::Person::MOBILE);    uint32_t size = person.ByteSize();    unsigned char byteArray[size];    person.SerializeToArray(byteArray, size);    addressbook::AddressBook help_person;    help_person.ParseFromArray(byteArray, size);    addressbook::Person help_pi = help_person.person_info(0);    std::cout &lt;&lt; "*****************************" &lt;&lt; std::endl;    std::cout &lt;&lt; "id:    " &lt;&lt; help_pi.id() &lt;&lt; std::endl;    std::cout &lt;&lt; "name:  " &lt;&lt; help_pi.name() &lt;&lt; std::endl;    std::cout &lt;&lt; "email: " &lt;&lt; help_pi.email() &lt;&lt; std::endl;    for (int i = 0; i &lt; help_pi.phone_size(); ++i)    {        auto help_pn = help_pi.mutable_phone(i);        std::cout &lt;&lt; "phone_type: " &lt;&lt; help_pn-&gt;type() &lt;&lt; std::endl;        std::cout &lt;&lt; "phone_number: " &lt;&lt; help_pn-&gt;number() &lt;&lt; std::endl;    }    std::cout &lt;&lt; "*****************************" &lt;&lt; std::endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试输出结果： </p><pre class="line-numbers language-none"><code class="language-none">g++ main.cc xxx.pb.cc  -lprotobuf -pthread <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://banthink.com/usr/uploads/2020/03/4270790034.png" alt="Screenshot_2020年03月08日21时23分14秒.png"></p><h1 id="C-API"><a href="#C-API" class="headerlink" title="C++ API"></a>C++ API</h1><p>　　protoc为message的每个required字段和optional字段都定义了以下几个函数（不限于这几个）：</p><pre class="line-numbers language-none"><code class="language-none">TypeName xxx() const;  　　　　    //获取字段的值bool has_xxx();   　　 　　　　    //判断是否设值void set_xxx(const TypeName&amp;);   //设值void clear_xxx(); 　　 　　　　　　//使其变为默认值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为每个repeated字段定义了以下几个：</p><pre class="line-numbers language-none"><code class="language-none">TypeName* add_xxx();        //增加结点TypeName xxx(int) const;    //获取指定序号的结点，类似于C++的"[]"运算符TypeName* mutable_xxx(int); //类似于上一个，但是获取的是指针int xxx_size();         　  //获取结点的数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，下面几个是常用的序列化函数：</p><pre class="line-numbers language-none"><code class="language-none">bool SerializeToOstream(std::ostream * output) const; //输出到输出流中bool SerializeToString(string * output) const;        //输出到stringbool SerializeToArray(void * data, int size) const;   //输出到字节流<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>与之对应的反序列化函数：</p><pre class="line-numbers language-none"><code class="language-none">bool ParseFromIstream(std::istream * input); 　　  //从输入流解析bool ParseFromString(const string &amp; data);   　　  //从string解析bool ParseFromArray(const void * data, int size); //从字节流解析<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他常用的函数：</p><pre class="line-numbers language-none"><code class="language-none">bool IsInitialized();    //检查是否所有required字段都被设值size_t ByteSize() const; //获取二进制字节序的大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>官方API文档地址： <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">https://developers.google.com/protocol-buffers/docs/reference/overview</a></p><h1 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h1><p><img src="https://banthink.com/usr/uploads/2020/03/3193276138.png" alt="标量类型.png"></p><h1 id="还有什么？"><a href="#还有什么？" class="headerlink" title="还有什么？"></a>还有什么？</h1><ol><li><p>编码风格<br>　　- 花括号的使用(参考上面的proto文件)<br>　　- 数据类型使用驼峰命名法：AddressBook, PhoneType<br>　　- 字段名小写并使用下划线连接：person_info, email_addr<br>　　- 枚举量使用大写并用下划线连接：FIRST_VALUE, SECOND_VALUE</p></li><li><p>适用场景</p></li></ol><p>　　“Protocol Buffers are not designed to handle large messages.”。protobuf对于1M以下的message有很高的效率，但是当message是大于1M的大块数据时，protobuf的表现不是很好，请合理使用。</p><p>总结：本文介绍了protobuf的基本使用方法和编码规则，还有很多内容尚未涉及，比如：反射机制、扩展、Oneof、RPC等等，更多内容需参考官方文档。</p>]]></content>
      
      
      <categories>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>言简意赅的讲述KMP算法（附C++实现）</title>
      <link href="yan-jian-yi-gai-de-jiang-shu-kmp-suan-fa-fu-c-shi-xian/"/>
      <url>yan-jian-yi-gai-de-jiang-shu-kmp-suan-fa-fu-c-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="wiki-介绍"><a href="#wiki-介绍" class="headerlink" title="wiki 介绍"></a>wiki 介绍</h1><p>在计算机科学中，Knuth-Morris-Pratt字符串查找算法（简称为KMP算法）可在一个主文本字符串S内查找一个词W的出现位置。此算法通过运用对这个词在不匹配时本身就包含足够的信息来确定下一个匹配将在哪里开始的发现，从而避免重新检查先前匹配的字符。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先我们可以用常规思路去考虑如果自己实现一个这样的算法应该如何实现</p><p>主字符串:S<br>词:W</p><ol><li>将两个字符串S和W进行匹配，分别从0，0位置开始匹配</li><li>当出现不匹配的情况，重新从1，0位置开始匹配，相当于跳过主字符串的第0位重新匹配一遍。</li><li>以此类推</li></ol><p>这样的算法很容易可以看出需要O(n2)的时间复杂度，但是也很容易想到</p><p>那么KMP算法的时间复杂度是O(n) 是如何做到的呢？ </p><p>我们再一次回顾刚刚的算法，我们进行优化，其中最需要优化的部分就是第2步：当不匹配的时候S跳过1位再重新匹配，这样会出现前面n位其实已经匹配了但是一旦只移1位会导致全部错位，我们更希望从最相似的地方开始重新匹配。这就是KMP算法。</p><h1 id="部分匹配表-PMT"><a href="#部分匹配表-PMT" class="headerlink" title="部分匹配表(PMT)"></a>部分匹配表(PMT)</h1><p>所谓的部分匹配表，实际上表中存放的就是字符串前后缀公共字段最长长度值。</p><p>什么是前缀后缀</p><p>aba<br>前缀:a，ab<br>后缀:a，ba<br>也就是说，前/后缀是包含第一个/最后一个且不包含整个字符串的子序列。</p><p>上面的公共字段的最长长度值为1。</p><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><pre class="line-numbers language-none"><code class="language-none">i：S的下标j：W的下标<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>延续刚刚的思路，当出现不匹配的情况时，我们将S理解为前缀，W理解为后缀，这时候W应该移动到上一个相同的位置的最长最公共字段的位置。也就是<code>j=PMT[j-1]</code></p><p>这样就避免了大量错位的情况，也使得算法的时间复杂度降到O(n)</p><p>下面是一组动图可以结合理解。</p><p><img src="https://banthink.com/usr/uploads/2020/02/3665326887.gif" alt="dcfkb-93xg1.gif"></p><h1 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h1><pre class="line-numbers language-none"><code class="language-none">vector&lt;int&gt; getNext(string&amp; str){    vector&lt;int&gt; next(str.size()+1);    next[0]=-1;    int i=0,j=-1;    while(i&lt;str.size())    {        if(j==-1||str[i]==str[j])        {            ++i;            ++j;            next[i]=j;        }else            j=next[j];    }    return next;}int KMP(string str1,string str2){    int i=0,j=0;    vector&lt;int&gt; next=getNext(str1);    while(i&lt;str1.size()&amp;&amp;j&lt;str2.size())    {        if(j==-1||str1[i]==str2[j])        {            i++;            j++;        }else             j=next[j];    }    if(j==str2.size())        return i-j;    else        return -1;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体的PMT表的生成<br>（对着代码看阅读体验更佳）</p><p><img src="https://banthink.com/usr/uploads/2020/02/2857081805.gif" alt="PMT.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 表的基本操作</title>
      <link href="mysql-biao-de-ji-ben-cao-zuo/"/>
      <url>mysql-biao-de-ji-ben-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="创建语句"><a href="#创建语句" class="headerlink" title="创建语句"></a>创建语句</h1><h1 id="插入语句"><a href="#插入语句" class="headerlink" title="插入语句"></a>插入语句</h1><h1 id="修改语句"><a href="#修改语句" class="headerlink" title="修改语句"></a>修改语句</h1><h1 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h1><pre class="line-numbers language-none"><code class="language-none">SELECT [column name] FROM [table name] (WHERE [expression])column name : 结果表的列名table name  : 选取的表 expression  : 约束前面生成的表中的内容.通俗来讲就是根据表达式来显示结果。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>交叉连接： 实际上就是两者表的笛卡尔积 。 使用CROSS JOIN </p><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接查询操作<strong>只列出与连接条件匹配的数据行</strong>，使用 INNER JOIN 或者直接使用 JOIN 进行连接。</p><pre class="line-numbers language-none"><code class="language-none">SELECT student.name,score.codeFROM student JOIN score ON score.code=student.code;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>左连接、右连接的具体说明可以看下图，其实左连接就是先将两个表的列都拼接起来，接着将左边的表中的行全部输出，右边的表只输出符合条件的行。右连接就相反。</p><p><img src="https://banthink.com/usr/uploads/2020/02/3861284523.jpg" alt="数据库连接.jpg"></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>1.组合两张表</p><pre class="line-numbers language-none"><code class="language-none">表1: Person+-------------+---------+| 列名         | 类型     |+-------------+---------+| PersonId    | int     || FirstName   | varchar || LastName    | varchar |+-------------+---------+PersonId 是上表主键表2: Address+-------------+---------+| 列名         | 类型    |+-------------+---------+| AddressId   | int     || PersonId    | int     || City        | varchar || State       | varchar |+-------------+---------+AddressId 是上表主键&nbsp;编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供&nbsp;person 的以下信息：&nbsp;FirstName, LastName, City, State来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/combine-two-tables著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>答案</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT FirstName,LastName,City,State FROM PERSON P LEFT JOIN ADDRESS A ON P.PERSONID=A.PERSONID  ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2.第二高的薪水</p><pre class="line-numbers language-none"><code class="language-none">编写一个 SQL 查询，获取 Employee&nbsp;表中第二高的薪水（Salary）&nbsp;。+----+--------+| Id | Salary |+----+--------+| 1  | 100    || 2  | 200    || 3  | 300    |+----+--------+例如上述&nbsp;Employee&nbsp;表，SQL查询应该返回&nbsp;200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。+---------------------+| SecondHighestSalary |+---------------------+| 200                 |+---------------------+来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/second-highest-salary著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>答案</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT IFNULL((SELECT DISTINCT Salary FROM EMPLOYEE ORDER BY SALARY DESC LIMIT 1, 1),NULL) AS SecondHighestSalary;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>解析 ：</strong><br>limit n,m 跳过第n条记录返回m条记录</p><p>从最外面一层看，<code>SELECT IFNULL(...) AS SecondHighestSalary</code> 就是将函数IFNULL()中返回的列改名为SecondHighestSalary输出，其实有没有<code>AS </code> 没区别，加了会比较清楚直观，一般把这种需要重命名的列用空格间隔后面跟上新名字就好了。</p><p><code>SELECT DISTINCT Salary FROM EMPLOYEE ORDER BY SALARY DESC LIMIT 1, 1</code> </p><p>这一句是全部里面最关键的，<code>DISTINCT</code>关键字是去重复行。<br>以下是执行步骤：<br>1.对Salary列进行排序（DESC降序）<br>2. <code>LIMIT 1,1 </code>对排序后的结果取第二个值。<br>3. 返回列的结果给<code>IFNULL</code><br>4. <code>IFNULL</code> 判断列的值是否为<code>NULL</code>，为<code>NULL</code>则改为<code>NULL</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GDB 调试  从入门到大概会用</title>
      <link href="gdb-diao-shi-cong-ru-men-dao-da-gai-hui-yong/"/>
      <url>gdb-diao-shi-cong-ru-men-dao-da-gai-hui-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。或许，各位比较喜欢那种图形界面方式的，像VC、BCB等IDE的调试，但如果你是在UNIX平台下做软件，你会发现GDB这个调试工具有比VC、BCB的图形化调试器更强大的功能。所谓“寸有所长，尺有所短”就是这个道理。</p><p>一般来说，GDB主要帮忙你完成下面四个方面的功能：</p><p>&nbsp;&nbsp;&nbsp; 1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。<br>&nbsp;&nbsp;&nbsp; 2、可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）<br>&nbsp;&nbsp;&nbsp; 3、当程序被停住时，可以检查此时你的程序中所发生的事。<br>&nbsp;&nbsp;&nbsp; 4、动态的改变你程序的执行环境。</p><p>从上面看来，GDB和一般的调试工具没有什么两样，基本上也是完成这些功能，不过在细节上，你会发现GDB这个调试工具的强大，大家可能比较习惯了图形化的调试工具，但有时候，命令行的调试工具却有着图形化工具所不能完成的功能。让我们一一看来。</p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="GDB控制"><a href="#GDB控制" class="headerlink" title="GDB控制"></a>GDB控制</h2><pre class="line-numbers language-none"><code class="language-none">r 开始运行程序直到断点.continue  :   继续运行程序直到下一个断点（类似于VS里的F5）next  :  逐过程步进，不会进入子函数（类似VS里的F10）setp  :  逐语句步进，会进入子函数（类似VS里的F11）until    : 运行至当前语句块结束finish  :  运行至函数结束并跳出，并打印函数的返回值（类似VS的Shift+F11）return: 强制从当前函数返回quit(q) 退出kill [filename]终止正在调试的程序load [filename] : 动态载入一个可执行文件到调试器make  : 使你能不退出 gdb 就可以重新产生可执行文件shell [...]: 使你能不离开 gdb 就执行 UNIX shell 命令list 显示当前位置的上下文list [linenum]/[filename:linenum]  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变量显示"><a href="#变量显示" class="headerlink" title="变量显示"></a>变量显示</h2><pre class="line-numbers language-none"><code class="language-none">print(p): 打印变量或表达式结果print [variable]print [function]whatis/ptype   [variable]: 显示变量的值和类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="断点控制"><a href="#断点控制" class="headerlink" title="断点控制"></a>断点控制</h2><pre class="line-numbers language-none"><code class="language-none">catch让程序在发生某种事件（fork、异常throw、异常catch、动态库加载等）的时候停止运行eg: catch forkbreak 在进入指定函数时停住，C++中可以使用class::function或function(type,type)格式来指定函数名break [linenum] : 在指定行号停住break [filename:linenum]: 在指定文件指定行号停下break [function] : 在指定函数停下break [filename:linenum]: 在指定文件的指定函数停下break *[address] : 在程序运行的内存地址处停下break if [condition] : condition表示条件，在条件成立时停住。比如在循环体中，可以设置break if i=100，表示当i为100时停住程序delete [breakpoints] [range…]: 删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围(如:3-7)。其简写命令为d，比删除更好的一种方法是disable停止点。disable了的停止点，gdb不会删除，当还需要时，enable即可，就好像回收站一样clear [line/function]： 删除一个断点，这个命令需要指定代码行或者函数名作为参数，若不指定则删除所有的disable[n] : 禁止断点功能，这个命令需要禁止的断点在断点列表索引值作为参数enable [n] xbreak在当前函数的退出的点上设置一个断点condition [n] [expression] : 在断点n满足expression时停止ignore [n] [count]   : 忽略某个断点制定的次数。例：ignore 4 23 忽略断点4的23次运行，在第24次的时候中断info break[n] : 断点号为n的断点info b : 所有断点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变量赋值与监测"><a href="#变量赋值与监测" class="headerlink" title="变量赋值与监测"></a>变量赋值与监测</h2><pre class="line-numbers language-none"><code class="language-none">watch [variable] : 使你能监视一个变量的值而不管它何时被改变rwatch [variable] :  指定一个变量，如果这个变量被读，则暂停程序运行，在调试器中显示信息，并等待下一个调试命令。参考rwatch和watch命令awatch [variable] : 指定一个变量，如果这个变量被读或者被写，则暂停程序运行，在调试器中显示信息，并等待下一个调试命令。参考rwatch和watch命令set [variable] : 设置变量的值。例如：set nval=54 将把54保存到nval变量中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内存检测"><a href="#内存检测" class="headerlink" title="内存检测"></a>内存检测</h2><h3 id="x-n-f-u-addr"><a href="#x-n-f-u-addr" class="headerlink" title="x/[n/f/u] [addr]"></a>x/[n/f/u] [addr]</h3><p>使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下：</p><p>x/[n/f/u] [addr]</p><p>n、f、u是可选的参数。</p><p>n是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。</p><p>f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果 地址是指令地址，那么格式可以是i。</p><p>u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字 节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</p><p><addr>表示一个内存地址。</addr></p><p>n/f/u三个参数可以一起使用。例如：</p><p>命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要做到这样，你可以使用GDB的数据显示格式：</p><p>上面的u可以替换成：</p><p>d 按十进制格式显示变量</p><p>x 按十六进制格式显示变量</p><p>a 按十六进制格式显示变量</p><p>u 按十进制格式显示无符号整型</p><p>o 按八进制格式显示变量</p><p>t 按二进制格式显示变量</p><p>c 按字符格式显示变量</p><p>f 按浮点数格式显示变量</p><p>s 按字符串格式显示变量</p><p>i 按指令地址显示变量(汇编)</p><p>h可以替换成：</p><p>b表示单字节，h表示双字节，w表示四字 节，g表示八字节</p><h1 id="寄存器与汇编"><a href="#寄存器与汇编" class="headerlink" title="寄存器与汇编"></a>寄存器与汇编</h1><pre class="line-numbers language-none"><code class="language-none">info registers [寄存器] : 查看寄存器值，后面不跟寄存器的话就是查看所有寄存器disassemble \m : 查看当前的汇编代码stepi : 汇编代码的stepnexti : 汇编代码的nextset $[寄存器]=[value] ：设置寄存器值x/[n/f/u] $[寄存器] ：把寄存器中的值作为地址，查看地址上的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><pre class="line-numbers language-none"><code class="language-none">tui :  GUI显示layout：用于分割窗口，可以一边查看代码，一边测试：layout src：显示源代码窗口layout asm：显示反汇编窗口layout regs：显示源代码/反汇编和CPU寄存器窗口layout split：显示源代码和反汇编窗口Ctrl + L：刷新窗口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="专题"><a href="#专题" class="headerlink" title="专题"></a>专题</h1><h2 id="栈帧溢出"><a href="#栈帧溢出" class="headerlink" title="栈帧溢出"></a>栈帧溢出</h2><pre class="line-numbers language-none"><code class="language-none">bt(Backtrace) :  查看堆栈情况 ,可以用来调试栈帧溢出的情况frame n|f n :查看其调用函数的信息,n为栈的层次，然后可以用其他命令（info）查看此级别的变量信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="多线程多进程"><a href="#多线程多进程" class="headerlink" title="多线程多进程"></a>多线程多进程</h2><p>1、 设置follow-fork-mode (fork追踪模式)以及detach-on-fork（指示GDB在fork之后是否断开某个进程的调试）即可。</p><p>这两个参数的设置命令分别是：set follow-fork-mode [parent|child]，set detach-on-fork [on|off]。两者结合起来构成了GDB的调试模式：</p><pre class="line-numbers language-none"><code class="language-none">follow-fork-mode  detach-on-fork    说明    parent              on          GDB默认的调试模式：只调试主进程    child               on          只调试子进程    parent              off         同时调试两个进程，gdb跟主进程，子进程block在fork位置    child               off         同时调试两个进程，gdb跟子进程，主进程block在fork位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、 利用info threads/inferiors 来查看线程/进程情况<br>3、 thread [n] 切换线程<br>4、 inferior [n] 切换进程<br>5、 set scheduler-locking on/off 打开/冻结 其他线程，只执行当前所在线程</p><h2 id="为停止点设定运行命令"><a href="#为停止点设定运行命令" class="headerlink" title="为停止点设定运行命令"></a>为停止点设定运行命令</h2><p>可以使用gdb提供的command命令来设置停止点的运行命令。也就是说，当运行的程序在被停住时，我们可以让其自动运行一些别的命令，这很有利行自动化调试。</p><pre class="line-numbers language-none"><code class="language-none">commands [bnum]... command-list ...end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为断点号bnum指定一个命令列表。当程序被该断点停住时，gdb会依次运行命令列表中的命令。<br>例如：</p><pre class="line-numbers language-none"><code class="language-none">break foo if x&gt;0commandsprintf "x is %d/n",xcontinueend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>断点设置在函数foo中，断点条件是x&gt;0，如果程序被断住后，也就是一旦x的值在foo函数中大于0，gdb会自动打印出x的值，并继续运行程序。<br>如果要清除断点上的命令序列，那么只要简单地执行一下commands命令，并直接在输入end就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程的区别（转）</title>
      <link href="jin-cheng-he-xian-cheng-de-qu-bie-zhuan/"/>
      <url>jin-cheng-he-xian-cheng-de-qu-bie-zhuan/</url>
      
        <content type="html"><![CDATA[<h1 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a>进程和线程的区别？</h1><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><ol><li><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</p></li><li><p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p></li><li><p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p></li><li><p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p></li><li><p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p></li></ol><h1 id="线程与进程总结："><a href="#线程与进程总结：" class="headerlink" title="线程与进程总结："></a>线程与进程总结：</h1><h2 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1.进程和线程"></a>1.进程和线程</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述:"></a>1.1 概述:</h3><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</p><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p><p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p><p>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。</p><p>在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。</p><h3 id="1-2-区别"><a href="#1-2-区别" class="headerlink" title="1.2 区别:"></a>1.2 区别:</h3><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><ol><li><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</p></li><li><p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p></li><li><p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p></li><li><p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p></li><li><p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p></li></ol><h3 id="1-3-优缺点"><a href="#1-3-优缺点" class="headerlink" title="1.3 优缺点:"></a>1.3 优缺点:</h3><p>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p><h2 id="2-多进程，多线程"><a href="#2-多进程，多线程" class="headerlink" title="2.多进程，多线程"></a>2.多进程，多线程</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述:"></a>2.1 概述:</h3><p>进程就是一个程序运行的时候被CPU抽象出来的，一个程序运行后被抽象为一个进程，但是线程是从一个进程里面分割出来的，由于CPU处理进程的时候是采用时间片轮转的方式，所以要把一个大个进程给分割成多个线程，例如：网际快车中文件分成100部分 10个线程 文件就被分成了10份来同时下载 1-10 占一个线程 11-20占一个线程,依次类推,线程越多,文件就被分的越多,同时下载 当然速度也就越快</p><p>进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序只是一组指令的有序集合，它本身没有任何运行的含义，只是一个静态实体。而进程则不同，它是程序在某个数据集上的执行，是一个动态实体。它因创建而产生，因调度而运行，因等待资源或事件而被处于等待状态，因完成任务而被撤消，反映了一个程序在一定的数据集上运行的全部动态过程。进程是操作系统分配资源的单位。在Windows下，进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。线程(Thread)是进程的一个实体，是CPU调度和分派的基本单位。线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p><p>线程和进程的关系是：线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。线程可与属于同一进程的其它线程共享进程所拥有的全部资源，但是其本身基本上不拥有系统资源，只拥有一点在运行中必不可少的信息(如程序计数器、一组寄存器和栈)。</p><p>在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多任务。现代的操作系统几乎都是多任务操作系统，能够同时管理多个进程的运行。 多任务带来的好处是明显的，比如你可以边听mp3边上网，与此同时甚至可以将下载的文档打印出来，而这些任务之间丝毫不会相互干扰。那么这里就涉及到并行的问题，俗话说，一心不能二用，这对计算机也一样，原则上一个CPU只能分配给一个进程，以便运行这个进程。我们通常使用的计算机中只有一个CPU，也就是说只有一颗心，要让它一心多用，同时运行多个进程，就必须使用并发技术。实现并发技术相当复杂，最容易理解的是“时间片轮转进程调度算法”，它的思想简单介绍如下：在操作系统的管理下，所有正在运行的进程轮流使用CPU，每个进程允许占用CPU的时间非常短(比如10毫秒)，这样用户根本感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样。但实际上在任何一个时间内有且仅有一个进程占有CPU。</p><p>如果一台计算机有多个CPU，情况就不同了，如果进程数小于CPU数，则不同的进程可以分配给不同的CPU来运行，这样，多个进程就是真正同时运行的，这便是并行。但如果进程数大于CPU数，则仍然需要使用并发技术。</p><p>在Windows中，进行CPU分配是以线程为单位的，一个进程可能由多个线程组成，这时情况更加复杂，但简单地说，有如下关系：</p><p>总线程数&lt;= CPU数量：并行运行</p><p>总线程数&gt; CPU数量：并发运行</p><p>并行运行的效率显然高于并发运行，所以在多CPU的计算机中，多任务的效率比较高。但是，如果在多CPU计算机中只运行一个进程(线程)，就不能发挥多CPU的优势。</p><p> 多任务操作系统(如Windows)的基本原理是:操作系统将CPU的时间片分配给多个线程,每个线程在操作系统指定的时间片内完成(注意,这里的多个线程是分属于不同进程的).操作系统不断的从一个线程的执行切换到另一个线程的执行,如此往复,宏观上看来,就好像是多个线程在一起执行.由于这多个线程分属于不同的进程,因此在我们看来,就好像是多个进程在同时执行,这样就实现了多任务.</p><h3 id="2-2-分类"><a href="#2-2-分类" class="headerlink" title="2.2 分类"></a>2.2 分类</h3><p>根据进程与线程的设置，操作系统大致分为如下类型：</p><p>(1) 单进程、单线程，MS-DOS大致是这种操作系统；</p><p>(2) 多进程、单线程，多数UNIX(及类UNIX的LINUX)是这种操作系统；</p><p>(3) 多进程、多线程，Win32(Windows NT/2000/XP等)、Solaris 2.x和OS/2都是这种操作系统；</p><p>(4) 单进程、多线程，VxWorks是这种操作系统。</p><h3 id="2-3-引入线程带来的主要好处："><a href="#2-3-引入线程带来的主要好处：" class="headerlink" title="2.3 引入线程带来的主要好处："></a>2.3 引入线程带来的主要好处：</h3><p>(1) 在进程内创建、终止线程比创建、终止进程要快；</p><p>(2) 同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。</p><p>转<a href="https://www.cnblogs.com/lmule/archive/2010/08/18/1802774.html">https://www.cnblogs.com/lmule/archive/2010/08/18/1802774.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IPC- 消息队列 详解</title>
      <link href="ipc-xiao-xi-dui-lie-xiang-jie/"/>
      <url>ipc-xiao-xi-dui-lie-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux下进程间通信方式："><a href="#Linux下进程间通信方式：" class="headerlink" title="Linux下进程间通信方式："></a>Linux下进程间通信方式：</h1><p>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><p>有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><p>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p><p>套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p><h1 id="System-V-与-POSIX的区别"><a href="#System-V-与-POSIX的区别" class="headerlink" title="System V 与 POSIX的区别"></a>System V 与 POSIX的区别</h1><p>System V IPC存在时间比较老，许多系统都支持，但是接口复杂，并且可能各平台上实现略有区别（如ftok的实现及限制）。</p><p>POSIX是新标准，现在多数UNIX也已实现，我觉得如果只是开发的话，那么还是POSIX好，因为语法简单，并且各平台上实现都一样。</p><h1 id="一、什么是消息队列"><a href="#一、什么是消息队列" class="headerlink" title="一、什么是消息队列"></a>一、什么是消息队列</h1><p>消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 &nbsp;每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p><p>Linux用宏MSGMAX和MSGMNB来限制一条消息的最大长度和一个队列的最大长度。</p><h2 id="1、每种进程通信方式实现方式和功能不一样，带来适用的场景也有所不同"><a href="#1、每种进程通信方式实现方式和功能不一样，带来适用的场景也有所不同" class="headerlink" title="1、每种进程通信方式实现方式和功能不一样，带来适用的场景也有所不同"></a>1、每种进程通信方式实现方式和功能不一样，带来适用的场景也有所不同</h2><p>消息队列是链表队列，它通过内核提供一个struct msqid_ds *msgque[MSGMNI]向量维护内核的一个消息队列列表，因此linux系统支持的最大消息队列数由msgque数组大小来决定，每一个msqid_ds表示一个消息队列，并通过msqid_ds.msg_first、msg_last维护一个先进先出的msg链表队列，当发送一个消息到该消息队列时，把发送的消息构造成一个msg结构对象，并添加到msqid_ds.msg_first、msg_last维护的链表队列，同样，接收消息的时候也是从msg链表队列尾部查找到一个msg_type匹配的msg节点，从链表队列中删除该msg节点，并修改msqid_ds结构对象的数据。</p><h2 id="2、消息队列的数据结构"><a href="#2、消息队列的数据结构" class="headerlink" title="2、消息队列的数据结构"></a>2、消息队列的数据结构</h2><p>struct msqid_ds *msgque[MSGMNI]向量：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msgque[MSGMNI]是一个msqid_ds结构的指针数组，每个msqid_ds结构指针代表一个系统消息队列，msgque[MSGMNI]的大小为MSGMNI=128，也就是说系统最多有MSGMNI=128个消息队列。</p><h2 id="3、消息队列Key的获取："><a href="#3、消息队列Key的获取：" class="headerlink" title="3、消息队列Key的获取："></a>3、消息队列Key的获取：</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在程序中若要使用消息队列，必须要能知道消息队列key,因为应用进程无法直接访问内核消息队列中的数据结构，因此需要一个消息队列的标识，让应用进程知道当前操作的是哪个消息队列，同时也要保证每个消息队列key值的唯一性</p><p><a href="http://blog.csdn.net/stonecao/article/details/10364287">http://blog.csdn.net/stonecao/article/details/10364287</a></p><h1 id="二、消息队列与命名管道的比较"><a href="#二、消息队列与命名管道的比较" class="headerlink" title="二、消息队列与命名管道的比较"></a>二、消息队列与命名管道的比较</h1><p>消息队列跟命名管道有不少的相同之处，通过与命名管道一样，消息队列进行通信的进程可以是不相关的进程，同时它们都是通过发送和接收的方式来传递数据的。在命名管道中，发送数据用write，接收数据用read，则在消息队列中，发送数据用msgsnd，接收数据用msgrcv。而且它们对每个数据都有一个最大长度的限制。</p><p>与命名管道相比，消息队列的优势在于:<br>1、消息队列也可以独立于发送和接收进程而存在，从而消除了在同步命名管道的打开和关闭时可能产生的困难。</p><p>2、同时通过发送消息还可以避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法。</p><p>3、接收程序可以通过消息类型有选择地接收数据，而不是像命名管道中那样，只能默认地接收。</p><h1 id="SYSTEM-V-消息队列"><a href="#SYSTEM-V-消息队列" class="headerlink" title="SYSTEM V 消息队列"></a>SYSTEM V 消息队列</h1><h2 id="1、创建或者使用消息队列：msgget函数"><a href="#1、创建或者使用消息队列：msgget函数" class="headerlink" title="1、创建或者使用消息队列：msgget函数"></a>1、创建或者使用消息队列：msgget函数</h2><p>该函数用来创建和访问一个消息队列。它的原型为：</p><pre class="line-numbers language-none"><code class="language-none">int msgget(key_t, key, int msgflg);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与其他的IPC机制一样，程序必须提供一个键来命名某个特定的消息队列。msgflg是一个权限标志，表示消息队列的访问权限，它与文件的访问权限一样。msgflg可以与IPC_CREAT做或操作，表示当key所命名的消息队列不存在时创建一个消息队列，如果key所命名的消息队列存在时，IPC_CREAT标志会被忽略，而只返回一个标识符。</p><p>在程序中若要使用消息队列，必须要能知道消息队列key,因为应用进程无法直接访问内核消息队列中的数据结构，因此需要一个消息队列的标识，让应用进程知道当前操作的是哪个消息队列，同时也要保证每个消息队列key值的唯一性。</p><p>申请一块内存，创建一个新的消息队列（数据结构msqid_ds)，将其初始化后加入到msgque向量表中的某个空位置处，返回标示符。或者在msgque向量表中找键值为key的消息队列。</p><h2 id="2、将消息添加到消息队列中"><a href="#2、将消息添加到消息队列中" class="headerlink" title="2、将消息添加到消息队列中"></a>2、将消息添加到消息队列中</h2><pre class="line-numbers language-none"><code class="language-none">int msgsend(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>msgid是由msgget函数返回的消息队列标识符。</p><p>msg_ptr是一个指向准备发送消息的指针，但是消息的数据结构却有一定的要求，指针msg_ptr所指向的消息结构一定要是以一个长整型成员变量开始的结构体，接收函数将用这个成员来确定消息的类型。所以消息结构要定义成这样：</p><pre class="line-numbers language-none"><code class="language-none">struct my_message{      long int message_type;      /* The data you wish to transfer*/  };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>msg_sz是msg_ptr指向的消息的长度，注意是消息的长度，而不是整个结构体的长度，也就是说msg_sz是不包括长整型消息类型成员变量的长度，也就是在使用的时候需要sizeof(struct my_message)- sizeof(long)</p><p>msgflg用于控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情。<br>如果调用成功，消息数据的一分副本将被放到消息队列中，并返回0，失败时返回-1.</p><h2 id="3、从一个消息队列中获取消息"><a href="#3、从一个消息队列中获取消息" class="headerlink" title="3、从一个消息队列中获取消息"></a>3、从一个消息队列中获取消息</h2><pre class="line-numbers language-none"><code class="language-none">int msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>msgid, msg_ptr, msg_st的作用也函数msgsnd函数的一样。</p><p>msgtype可以实现一种简单的接收优先级。如果msgtype为0，就获取队列中的第一个消息。如果它的值大于零，将获取具有相同消息类型的第一个信息。如果它小于零，就获取类型等于或小于msgtype的绝对值的第一个消息。</p><p>msgflg用于控制当队列中没有相应类型的消息可以接收时将发生的事情。</p><p>调用成功时，该函数返回放到接收缓存区中的字节数，消息被复制到由msg_ptr指向的用户分配的缓存区中，然后删除消息队列中的对应消息。失败时返回-1.</p><h2 id="4、消息队列控制函数"><a href="#4、消息队列控制函数" class="headerlink" title="4、消息队列控制函数"></a>4、消息队列控制函数</h2><pre class="line-numbers language-none"><code class="language-none">int msgctl(int msgid, int command, struct msgid_ds *buf);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>command是将要采取的动作，它可以取3个值</p><pre class="line-numbers language-none"><code class="language-none">&nbsp; &nbsp;&nbsp;IPC_STAT：把msgid_ds结构中的数据设置为消息队列的当前关联值，即用消息队列的当前关联值覆盖msgid_ds的值。&nbsp; &nbsp; IPC_SET：如果进程有足够的权限，就把消息列队的当前关联值设置为msgid_ds结构中给出的值&nbsp; &nbsp; IPC_RMID：删除消息队列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>buf是指向msgid_ds结构的指针，它指向消息队列模式和访问权限的结构。msgid_ds结构至少包括以下成员：</p><pre class="line-numbers language-none"><code class="language-none">struct msgid_ds  {      uid_t shm_perm.uid;      uid_t shm_perm.gid;      mode_t shm_perm.mode;  };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功时返回0，失败时返回-1.</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: recv.cpp&gt; Author: &gt; Mail: &gt; Created Time: 2020年02月12日 星期三 09时29分12秒 ************************************************************************/# include&lt;iostream&gt;# include &lt;signal.h&gt;# include &lt;sys/wait.h&gt;# include &lt;stdio.h&gt;# include &lt;unistd.h&gt;# include &lt;string.h&gt;# include &lt;stdlib.h&gt;# include &lt;sys/types.h&gt;# include &lt;sys/ipc.h&gt;# include &lt;sys/msg.h&gt;# include &lt;errno.h&gt;# define MSGKEY 1024using namespace std; typedef void Sigfunc(int);struct msgstru{    long msgtype;    char msgtext[2048];};void sig_chld(int signo){    pid_t pid;    int stat;    if((pid=waitpid(-1,&amp;stat,WNOHANG))&gt;0)        cout&lt;&lt;pid&lt;&lt;"  child terminated\n"&lt;&lt;endl;    return ;}Sigfunc* signal_bind(int signo,Sigfunc* func){       struct sigaction act,oact;    act.sa_handler=func;    sigemptyset(&amp;act.sa_mask);    act.sa_flags=0;    act.sa_flags|=SA_RESTART;    if(sigaction(signo,&amp;act,&amp;oact)&lt;=0)        return SIG_ERR;    return oact.sa_handler;}void childproc(){    struct msgstru msgs;    int msgid;    char str[512];    msgid=msgget(MSGKEY,IPC_EXCL);    if(msgid&lt;0){        printf("msq not existed ! errno = %d [%s]/n",errno,strerror(errno));        exit(-1);        }    while(1)    {        int ret_val=msgrcv(msgid,&amp;msgs,sizeof(msgstru)-sizeof(long),getpid(),0);              //这里接受的消息类型是和进程id号一样的才会接受                if(ret_val&lt;0&amp;&amp;errno==EIDRM)        {            cout&lt;&lt;getpid()&lt;&lt;" msq deleted."&lt;&lt;endl;            printf("errno = %d [%s]/n",errno,strerror(errno));            exit(-1);        }        printf("text = [%s] pid = [%d]\n",msgs.msgtext,getpid());    }}int main(){    int i,cpid;    signal_bind(SIGCHLD,sig_chld);//绑定信号  用于父进程回收子进程    for( i = 0 ;i &lt; 5;i++ )    {        cpid=fork();        if(cpid&lt; 0 )            printf("fork failed\n");        else if(cpid == 0)            childproc();        else             cout&lt;&lt;"process "&lt;&lt;cpid&lt;&lt;"  created."&lt;&lt;endl;            }    while(1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: send.cpp&gt; Author: &gt; Mail: &gt; Created Time: 2020年02月12日 星期三 09时20分41秒 ************************************************************************/# include&lt;iostream&gt;# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;# include &lt;string.h&gt;# include &lt;sys/types.h&gt;# include &lt;sys/ipc.h&gt;# include &lt;sys/msg.h&gt;# include &lt;errno.h&gt;# define MSGKEY 1024using namespace std;struct msgstru{    long msgtype;    char msgtext[2048];};intmain(){    struct msgstru  msgs;    int msg_type;    char str[256];    int ret_val;    int msqid;    msqid=msgget(MSGKEY,IPC_EXCL);    if(msqid&lt;0){        msqid=msgget(MSGKEY,IPC_CREAT|0666);        if(msqid&lt;0){            printf("failed to created msq | errno =%d [%s]\n",errno,strerror(errno));            exit(-1);        }    }    while(1){        cout&lt;&lt;"input message type (end : 0): ";        cin&gt;&gt;msg_type;        if(!msg_type) break;        cout&lt;&lt;"input message to be sent :";        cin&gt;&gt;str;        msgs.msgtype = msg_type;        strcpy(msgs.msgtext,str);        ret_val=msgsnd(msqid,&amp;msgs,sizeof(msgs.msgtext),IPC_NOWAIT);        if(ret_val&lt;0){            printf("failed to created msq | errno =%d [%s]\n",errno,strerror(errno));            exit(-1);        }    }    msgctl(msqid,IPC_RMID,0);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://banthink.com/usr/uploads/2020/02/1434125824.jpg" alt="消息队列.jpg"></p><p><img src="https://banthink.com/usr/uploads/2020/02/1186840956.jpg" alt="消息队列2.jpg"></p><h2 id="消息队列在内核的实现（转）"><a href="#消息队列在内核的实现（转）" class="headerlink" title="消息队列在内核的实现（转）"></a>消息队列在内核的实现（转）</h2><h3 id="1-struct-msg-queue"><a href="#1-struct-msg-queue" class="headerlink" title="1. struct msg_queue"></a>1. struct msg_queue</h3><p>消息队列在内核中用下面的数据结构表示</p><pre class="line-numbers language-none"><code class="language-none">// Linux 3.4: _msg_sm.hstruct msg_queue {    struct list_head list_elem;    struct msg_mgr *msg_mgr;    u32 max_msgs;       /* Node message depth */    u32 msgq_id;        /* Node environment pointer */    struct list_head msg_free_list; /* Free MsgFrames ready to be filled */        /* Filled MsgFramess waiting to be read */    struct list_head msg_used_list;    void *arg;      /* Handle passed to mgr on_exit callback */    struct sync_object *sync_event; /* Signalled when message is ready */    struct sync_object *sync_done;  /* For synchronizing cleanup */    struct sync_object *sync_done_ack;  /* For synchronizing cleanup */    struct ntfy_object *ntfy_obj;   /* For notification of message ready */    bool done;      /* TRUE &lt;==&gt; deleting the object */    u32 io_msg_pend;    /* Number of pending MSG_get/put calls */};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到消息队列实际上就是一个链表。</p><h3 id="2-分配获取消息队列"><a href="#2-分配获取消息队列" class="headerlink" title="2. 分配获取消息队列"></a>2. 分配获取消息队列</h3><p>首先上层应用通过调用 msgget 来进行系统调用，然后陷入内核：</p><pre class="line-numbers language-none"><code class="language-none">int msgget(key, msgflg)    key_t key;    int msgflg;{    return INLINE_SYSCALL (ipc, 5, IPCOP_msgget, key, msgflg, 0, NULL);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>消息队列的内核实现机制和共享内存几乎相同：在内核开辟一片内存空间存放消息队列，不同的进程使用这个消息队列（内存空间）来通信，与共享内存使用相同的一组回调函数 ipc_ops。</p><p>msgget 的基本的调用过程如下：</p><p><img src="https://banthink.com/usr/uploads/2020/02/1886149388.jpg" alt="msgget.jpg"></p><p>比较重要的是最后一步回调 newque 函数，这个函数在内核中分配了一个消息队列 msg：</p><p><img src="https://banthink.com/usr/uploads/2020/02/3873593735.jpg" alt="newque.jpg"></p><h3 id="3-发送消息"><a href="#3-发送消息" class="headerlink" title="3. 发送消息"></a>3. 发送消息</h3><p>上层的 msgsnd 系统调用最后会调用到内核的 do_msgsnd 函数，过程如下：</p><p><img src="https://banthink.com/usr/uploads/2020/02/3269798239.jpg" alt="sendmsg.jpg"></p><p>具体的过程这里就不分析了，主要就是在链表中添加一项。</p><h3 id="4-接受消息"><a href="#4-接受消息" class="headerlink" title="4. 接受消息"></a>4. 接受消息</h3><p>上层的 msgrcv 系统调用最后会调用到内核的 do_msgrcv 函数，过程如下：</p><p><img src="https://banthink.com/usr/uploads/2020/02/330021123.jpg" alt="rcvmsg.jpg"></p><p>同样接收消息会从链表中删除一项，具体的过程可以根据这个路线仔细分析。</p><p>作者：程序小歌<br>链接：<a href="https://www.jianshu.com/p/7598e5ed5200">https://www.jianshu.com/p/7598e5ed5200</a><br>来源：简书</p><h1 id="POSIX-标准消息队列"><a href="#POSIX-标准消息队列" class="headerlink" title="POSIX 标准消息队列"></a>POSIX 标准消息队列</h1><h2 id="1、mq-open来创建非默认个数大小消息队列："><a href="#1、mq-open来创建非默认个数大小消息队列：" class="headerlink" title="1、mq_open来创建非默认个数大小消息队列："></a>1、mq_open来创建非默认个数大小消息队列：</h2><p>函数原型</p><pre class="line-numbers language-none"><code class="language-none">mqd_t mq_open(const char *name, int&nbsp;oflag, mode_t&nbsp;mode, struct mq_attr *attr);&nbsp;第4个参数为 mq_attr 指针&nbsp;struct mq_attr{&nbsp;&nbsp;&nbsp;&nbsp;long mq_flags;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long mq_maxmsg;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long mq_msgsize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long mq_curmsgs;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;当第四个参数为空指针时，就使用默认属性。&nbsp;&nbsp;</p><p>当指向mq_attr结构的指针作为参数时，允许我们在该函数的实际操作时创建一个新队列时，给它指定mq_maxmsg和mq_msgsize属性.mq_open忽略该结构的另外两个成员.</p><p>（1）attr.mq_maxmsg 不能超过文件 /proc/sys/fs/mqueue/msg_max 中的数值；</p><p>（2）attr.mq_msgsize不能超过 /proc/sys/fs/mqueue/msgsize_max 的数值；</p><p>（3）消息队列名称前面必须加上斜杆。</p><p>在POSIX消息队列中 msg_max 默认为 10 ，msgsize_max 默认为8192 ，否则会报错！！！</p><p>可以在 /proc/sys/fs/mqueue# cat msg_max&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/proc/sys/fs/mqueue# cat msgsize_max</p><p>查看</p><p>修改的话，要使用：echo&nbsp;1000 &gt;&nbsp;/proc/sys/fs/mqueue/msg_max往里面写。</p><h2 id="2、获取消息队列的属性"><a href="#2、获取消息队列的属性" class="headerlink" title="2、获取消息队列的属性"></a>2、获取消息队列的属性</h2><p>一个进程在发送和接收消息之前，需要了解消息对象的属性，如消息的最大长度。以便设定接收和发送的buffer大小。 </p><pre class="line-numbers language-none"><code class="language-none">mqd_t mq_getattr(mqd_t mqdes, struct mq_attr *attr);参数：&nbsp;Mqdes：打开消息队列时获取的描述符。&nbsp;Attr：指向结构struct mq_attr的指针，用来获取消息队列的四个属性&nbsp;struct mq_attr {&nbsp;&nbsp; &nbsp; long mq_flags; &nbsp; &nbsp;// 0或者O_NONBLOCK&nbsp;&nbsp; &nbsp; long mq_maxmsg; //队列中包含的消息数的最大限制数 &nbsp;&nbsp; &nbsp; long mq_msgsize; //每个消息大小的最大限制数&nbsp;&nbsp; &nbsp;long mq_curmsgs; &nbsp;//当前队列中的消息数&nbsp;}&nbsp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、设置消息队列属性"><a href="#3、设置消息队列属性" class="headerlink" title="3、设置消息队列属性"></a>3、设置消息队列属性</h2><p>我们可以设置消息队列的属性，实际只能设置flag标志，说明队列中没有消息时，接收消息的进程是否在队列上继续等待。&nbsp;</p><pre class="line-numbers language-none"><code class="language-none">mqd_t mq_setattr(mqd_t mqdes, struct mq_attr *newattr, struct mq_attr *oldattr);&nbsp;参数：&nbsp;Mqdes：打开消息队列时获取的描述符。&nbsp;Attr：指向结构struct mq_attr的指针，用来获取消息队列的最大消息个数和最大消息长度。放到数据结构的mq_maxmsg和mq_msgsize中。&nbsp;struct mq_attr {&nbsp;&nbsp; &nbsp; long mq_flags; &nbsp; &nbsp;// 0或者O_NONBLOCK，只能设置这个&nbsp;&nbsp; &nbsp;long mq_maxmsg; //队列中包含的消息数的最大限制数&nbsp;&nbsp; &nbsp; long mq_msgsize; //每个消息大小的最大限制数 &nbsp;&nbsp;&nbsp; &nbsp; long mq_curmsgs; &nbsp;//当前队列中的消息数&nbsp;}&nbsp;oldattr：用来保存设置之前的attr值，可以为NULL.&nbsp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、发送消息"><a href="#4、发送消息" class="headerlink" title="4、发送消息"></a>4、发送消息</h2><p>进程在打开消息队列后，可以使用下面的函数发送消息&nbsp;</p><pre class="line-numbers language-none"><code class="language-none">int mq_send(mqd_t mqdes, const char *ptr, size_t len, unsigned int prio);&nbsp;参数：&nbsp;mqdes: 打开消息队列时获得的描述符。&nbsp;ptr: 指向发送缓冲区的指针，发送缓冲区存放了要发送的数据。&nbsp;Len: 要发送的数据的长度。 prio ：消息的优先级；它是一个小于 MQ_PRIO_MAX 的数，数值越大，优先级越高。&nbsp;prio: POSIX 消息队列在调用 mq_receive 时总是返回队列中 最高优先级的最早消息 。如果消息不需要设定优先级，那么可以在 mq_send 是置 prio 为 0 ， mq_receive 的 prio 置为 NULL 。 &nbsp;返回值：发送成功，返回0，失败，返回-1. &nbsp; &nbsp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、接收消息"><a href="#5、接收消息" class="headerlink" title="5、接收消息"></a>5、接收消息</h2><p>进程在打开消息队列后，可以使用下面的函数接收消息。&nbsp;</p><pre class="line-numbers language-none"><code class="language-none">ssize_t mq_receive(mqd_t mqdes, char *ptr, size_t len, unsigned int *prio);&nbsp;参数：&nbsp;mqdes: 打开消息队列时获得的描述符。&nbsp;ptr: 指向接收缓冲区的指针。接收缓冲区用来存放收到的消息。&nbsp;Len: 接收缓冲区的长度。 len不能小于mq_msgsize，否则会返回EMSGSIZE prio ：消息的优先级；它是一个小于 MQ_PRIO_MAX 的数，数值越大，优先级越高。 POSIX 消息队列在调用 mq_receive 时总是返回队列中 最高优先级的最早消息 。如果消息不需要设定优先级，那么可以在 mq_send 是置 prio 为 0 ， mq_receive 的 prio 置为 NULL 。 返回值：&nbsp;&nbsp;接收成功，返回0，失败，返回-1.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6、消息队列的关闭"><a href="#6、消息队列的关闭" class="headerlink" title="6、消息队列的关闭"></a>6、消息队列的关闭</h2><p>mqd_t mq_close(mqd_t mqdes); 关闭消息队列，但不能删除它 成功返回0，失败返回-1 &nbsp;&nbsp;</p><h2 id="7、删除消息队列"><a href="#7、删除消息队列" class="headerlink" title="7、删除消息队列"></a>7、删除消息队列</h2><p>&nbsp;mqd_t mq_unlink(const char *name); 成功返回0，失败返回-1&nbsp;<br>当某个进程还没有关闭此消息队列时，调用mq_unlink时，不会马上删除队列，当最后一个进程关闭队列时，该队列被删除,实际就是引用计数为0的时候会删除。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-none"><code class="language-none">编译： gcc -o consumer consumer.c -lrt gcc -o producer producer.c -lrt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">/* * *       Filename:  producer.c * *    Description:  生产者进程 * *        Version:  1.0 *        Created:  09/30/2011 04:52:23 PM *       Revision:  none *       Compiler:  gcc(g++) * *         Author:  |Zhenghe Zhang|, |zhenghe.zhang@gmail.com| *        Company:  |Shenzhen XXX Technology Co., Ltd.| * */ # include &lt;stdio.h&gt;# include &lt;mqueue.h&gt;# include &lt;sys/stat.h&gt;# include &lt;stdlib.h&gt;# include &lt;unistd.h&gt;# include &lt;time.h&gt;# include &lt;string.h&gt; # define MAXSIZE     10   //定义buf大小# define BUFFER      8192 //定义Msg大小 struct MsgType{    int len;    char buf[MAXSIZE];    char x;    short y;}; int main() {     /*消息队列*/    mqd_t msgq_id;    struct MsgType msg;     unsigned int prio = 1;    unsigned int send_size = BUFFER;     struct mq_attr msgq_attr;    const char *file = "/posix";     /*mq_open() for creating a new queue (using default attributes) */    /*mq_open() 创建一个新的 POSIX 消息队列或打开一个存在的队列*/    msgq_id = mq_open(file, O_RDWR | O_CREAT, S_IRWXU | S_IRWXG, NULL);    if(msgq_id == (mqd_t)-1)    {        perror("mq_open");        exit(1);    }     /* getting the attributes from the queue        --  mq_getattr() */    if(mq_getattr(msgq_id, &amp;msgq_attr) == -1)    {        perror("mq_getattr");        exit(1);    }     printf("Queue \"%s\":\n\t- stores at most %ld messages\n\t- \        large at most %ld bytes each\n\t- currently holds %ld messages\n",         file, msgq_attr.mq_maxmsg, msgq_attr.mq_msgsize, msgq_attr.mq_curmsgs);       /*setting the attributes of the queue        --  mq_setattr() */    /*mq_setattr() 设置消息队列的属性，设置时使用由 newattr 指针指向的 mq_attr 结构的信息。*/    /*属性中只有标志 mq_flasgs 里的 O_NONBLOCK 标志可以更改，其它在 newattr 内的域都被忽略 */    if(mq_setattr(msgq_id, &amp;msgq_attr, NULL) == -1)    {        perror("mq_setattr");        exit(1);    }        int i = 0;     while(i &lt; 10)     {        msg.len = i;        memset(msg.buf, 0, MAXSIZE);        sprintf(msg.buf, "0x%x", i);        msg.x = (char)(i + 'a');        msg.y = (short)(i + 100);         printf("msg.len = %d, msg.buf = %s, msg.x = %c, msg.y = %d\n", msg.len, msg.buf, msg.x, msg.y);         /*sending the message      --  mq_send() */        /*mq_send() 把 msg_ptr 指向的消息加入由 mqdes 引用的消息队列里。*/        /*参数 msg_len 指定消息 msg_ptr 的长度：这个长度必须小于或等于队列 mq_msgsize 属性的值。零长度的消息是允许。*/        if(mq_send(msgq_id, (char*)&amp;msg, sizeof(struct MsgType), prio) == -1)        {            perror("mq_send");            exit(1);        }         i++;        sleep(1);       }     sleep(30); //等待消费者进程退出     /*closing the queue        -- mq_close() */    /*mq_close() 关闭消息队列描述符 mqdes。如果调用进程在消息队列 mqdes 绑定了通知请求，*/    /*那么这个请求被删除，此后其它进程就可以绑定通知请求到此消息队列。*/    if(mq_close(msgq_id) == -1)    {        perror("mq_close");        exit(1);    }     /*mq_unlink() 删除名为 name 的消息队列。消息队列名将被直接删除。*/    /*消息队列本身在所有引用这个队列的描述符被关闭时销毁。*/    if(mq_unlink(file) == -1)    {        perror("mq_unlink");        exit(1);    }     return 0; } /* * *       Filename:  consumer.c * *    Description:  消费者进程 * *        Version:  1.0 *        Created:  09/30/2011 04:52:23 PM *       Revision:  none *       Compiler:  gcc(g++) * *         Author:  |Zhenghe Zhang|, |zhenghe.zhang@gmail.com| *        Company:  |Shenzhen XXX Technology Co., Ltd.| * */ # include &lt;stdio.h&gt;# include &lt;mqueue.h&gt;# include &lt;sys/stat.h&gt;# include &lt;stdlib.h&gt;# include &lt;unistd.h&gt;# include &lt;time.h&gt;# include &lt;string.h&gt; # define MAXSIZE     10   //定义buf大小# define BUFFER      8192 //定义Msg大小 struct MsgType{    int len;    char buf[MAXSIZE];    char x;    short y;}; int main() {     /*消息队列*/    mqd_t msgq_id;    struct MsgType msg;     unsigned int sender;    struct mq_attr msgq_attr;     unsigned int recv_size = BUFFER;    const char *file = "/posix";     /* mq_open() for opening an existing queue */    msgq_id = mq_open(file, O_RDWR);    if(msgq_id == (mqd_t)-1)    {        perror("mq_open");        exit(1);    }     /* getting the attributes from the queue        --  mq_getattr() */    if(mq_getattr(msgq_id, &amp;msgq_attr) == -1)    {        perror("mq_getattr");        exit(1);    }     printf("Queue \"%s\":\n\t- stores at most %ld messages\n\t- \        large at most %ld bytes each\n\t- currently holds %ld messages\n",         file, msgq_attr.mq_maxmsg, msgq_attr.mq_msgsize, msgq_attr.mq_curmsgs);     if(recv_size &lt; msgq_attr.mq_msgsize)        recv_size = msgq_attr.mq_msgsize;     int i = 0;    while(i &lt; 10) //运行一个consumenr，为 10 ，同时运行两个consumer进程，为 5      {        msg.len = -1;        memset(msg.buf, 0, MAXSIZE);        msg.x = ' ';        msg.y = -1;         /* getting a message */         /*mq_receive() 从由描述符 mqdes 引用的队列时删除优先级最高的最老的消息，并把放置到 msg_ptr 的缓存区内。*/        /*参数 msg_len 指定缓冲区 msg_ptr 的大小：它必须大于队列的 mq_msgsize 属性(参数 mq_getattr)。*/         /*如果 prio 不是 NULL，那么它指向的内存用于返回收到消息相关的优先级。*/        if (mq_receive(msgq_id, (char*)&amp;msg, recv_size, &amp;sender) == -1)         {            perror("mq_receive");            exit(1);        }         printf("msg.len = %d, msg.buf = %s, msg.x = %c, msg.y = %d\n", msg.len, msg.buf, msg.x, msg.y);         i++;        sleep(2);     }     if(mq_close(msgq_id) == -1)    {        perror("mq_close");        exit(1);    }     return 0; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>通过LeetCode来了解   回溯算法</title>
      <link href="tong-guo-leetcode-lai-liao-jie-hui-su-suan-fa/"/>
      <url>tong-guo-leetcode-lai-liao-jie-hui-su-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，<br>尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目<br>标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称.</p><p>通常回溯算法需要搭配上剪支,否则时间复杂度会很高(因为是遍历每一种题目所要求的可能结果)</p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>广度优先算法实际在二叉树中就是层序遍历,通常是利用一个队列来存储每一层的节点进行遍历,在图中的话需要增加一个存储访问标识的数组.</p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>深度优先算法在二叉树中对应的是前、中、后序遍历,通常是用递归的方法来遍历.在图中的话需要在递归函数的参数中传递一个存储访问标识的数组.</p><h1 id="LeetCode-46-全排列"><a href="#LeetCode-46-全排列" class="headerlink" title="LeetCode - 46 全排列"></a>LeetCode - 46 全排列</h1><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p><p>示例:</p><p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/permutations">https://leetcode-cn.com/problems/permutations</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这就是一个很典型的回溯题目，需要将所有可能的结果都枚举出来并返回.我们可以用DFS 或者 BFS 都可以。实际上感觉在回溯的题目中这两种办法都能解决问题只是复杂程度不一样。</p><blockquote><p>图片来源 <a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">liweiwei1419</a><br><img src="https://banthink.com/usr/uploads/2020/02/2119825742.png" alt="0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png"></p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-none"><code class="language-none">class Solution {public:    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {        vector&lt;vector&lt;int&gt; &gt; ret;        vector&lt;int&gt; tmp;  //用于临时存放每一种排列组合        vector&lt;bool&gt; used(nums.size(),false);   //这个数组用来存储访问过的数组下标        DFS(ret,nums,tmp,used);         return ret;        }    void DFS(vector&lt;vector&lt;int&gt; &gt;&amp;ret ,vector&lt;int&gt; &amp;nums,vector&lt;int&gt; &amp;tmp,vector&lt;bool&gt;&amp; visited)        {        if(tmp.size()==nums.size())           {            ret.push_back(tmp);            return ;        }/* 1 . 遍历nums中的每一个数并且递归到底   2 . 递归返回后需要将刚刚访问过的下标中visited中删除, 这是为了下一种排列组合    */        for(int i=0;i&lt;nums.size();i++)        {            if(visited[i])            {                 continue;            }            tmp.push_back(nums[i]);            visited[i]=true;            DFS(ret,nums,tmp,visited);            visited[i]=false;            tmp.pop_back();        }    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux epoll模型详解及源码分析 ( 转)</title>
      <link href="linuxepoll-mo-xing-xiang-jie-ji-yuan-ma-fen-xi-zhuan/"/>
      <url>linuxepoll-mo-xing-xiang-jie-ji-yuan-ma-fen-xi-zhuan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自 <a href="https://blog.csdn.net/zhaobryant/article/details/80557262">CSDN Linux epoll模型详解及源码分析</a></p></blockquote><h1 id="epoll简介"><a href="#epoll简介" class="headerlink" title="epoll简介"></a>epoll简介</h1><p>epoll是当前在Linux下开发大规模并发网络程序的热门选择，epoll在Linux2.6内核中正式引入，和select相似，都是IO多路复用（IO multiplexing）技术。</p><h1 id="EPOLL-特点"><a href="#EPOLL-特点" class="headerlink" title="EPOLL 特点"></a>EPOLL 特点</h1><h2 id="支持一个进程打开较大数目的文件描述符（fd）"><a href="#支持一个进程打开较大数目的文件描述符（fd）" class="headerlink" title="支持一个进程打开较大数目的文件描述符（fd）"></a>支持一个进程打开较大数目的文件描述符（fd）</h2><p>select模型对一个进程所打开的文件描述符是有一定限制的，其由FD_SETSIZE设置，默认为1024/2048。这对于那些需要支持上万连接数目的高并发服务器来说显然太少了，这个时候，可以选择两种方案：一是可以选择修改FD_SETSIZE宏然后重新编译内核，不过这样做也会带来网络效率的下降；二是可以选择多进程的解决方案（传统的Apache方案），不过虽然Linux中创建线程的代价比较小，但仍然是不可忽视的，加上进程间数据同步远不及线程间同步的高效，所以也不是一种完美的方案。</p><p>但是，epoll则没有对描述符数目的限制，它所支持的文件描述符上限是整个系统最大可以打开的文件数目，例如，在1GB内存的机器上，这个限制大概为10万左右。</p><h2 id="IO效率不会随文件描述符（fd）的增加而线性下降"><a href="#IO效率不会随文件描述符（fd）的增加而线性下降" class="headerlink" title="IO效率不会随文件描述符（fd）的增加而线性下降"></a>IO效率不会随文件描述符（fd）的增加而线性下降</h2><p>传统的select/poll的一个致命弱点就是当你拥有一个很大的socket集合时，不过任一时间只有部分socket是活跃的，select/poll每次调用都会线性扫描整个socket集合，这将导致IO处理效率呈现线性下降。</p><p>但是，epoll不存在这个问题，它只会对活跃的socket进行操作，这是因为在内核实现中，epoll是根据每个fd上面的callback函数实现的。因此，只有活跃的socket才会主动去调用callback函数，其他idle状态socket则不会。在这一点上，epoll实现了一个伪AIO，其内部推动力在内核。</p><p>在一些benchmark中，如果所有的socket基本上都是活跃的，如高速LAN环境，epoll并不比select/poll效率高，相反，过多使用epoll_ctl，其效率反而还有稍微下降。但是，一旦使用idle connections模拟WAN环境，epoll的效率就远在select/poll之上了。</p><h2 id="使用mmap加速内核与用户空间的消息传递"><a href="#使用mmap加速内核与用户空间的消息传递" class="headerlink" title="使用mmap加速内核与用户空间的消息传递"></a>使用mmap加速内核与用户空间的消息传递</h2><p>无论是select，poll还是epoll，它们都需要内核把fd消息通知给用户空间。因此，如何避免不必要的内存拷贝就很重要了。对于该问题，epoll通过内核与用户空间mmap(映射)同一块内存来实现。</p><h2 id="内核微调"><a href="#内核微调" class="headerlink" title="内核微调"></a>内核微调</h2><p>这一点其实不算epoll的优点了，而是整个Linux平台的优点，Linux赋予开发者微调内核的能力。比如，内核TCP/IP协议栈使用内存池管理sk_buff结构，那么，可以在运行期间动态调整这个内存池大小（skb_head_pool）来提高性能，该参数可以通过使用echo xxxx &gt; /proc/sys/net/core/hot_list_length来完成。再如，可以尝试使用最新的NAPI网卡驱动架构来处理数据包数量巨大但数据包本身很小的特殊场景。</p><h1 id="epoll-API"><a href="#epoll-API" class="headerlink" title="epoll API"></a>epoll API</h1><p>epoll只有epoll_create、epoll_ctl和epoll_wait这三个系统调用。其定义如下：</p><pre class="line-numbers language-none"><code class="language-none"># include &lt;sys/epoll.h&gt;int epoll_create(int size);int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h2><p>int epoll_create(int size);</p><p>可以调用epoll_create方法创建一个epoll的句柄。</p><p>需要注意的是，当创建好epoll句柄后，它就会占用一个fd值。在使用完epoll后，必须调用close函数进行关闭，否则可能导致fd被耗尽。</p><h2 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h2><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p><p>epoll的事件注册函数，它不同于select是在监听事件时告诉内核要监听什么类型的事件，而是通过epoll_ctl注册要监听的事件类型。</p><p>第一个参数epfd：epoll_create函数的返回值。</p><p>第二个参数events：表示动作类型。有三个宏来表示：</p><ul><li>EPOLL_CTL_ADD：注册新的fd到epfd中；</li><li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</li><li>EPOLL_CTL_DEL：从epfd中删除一个fd。</li></ul><p>第三个参数fd：需要监听的fd。</p><p>第四个参数event：告诉内核需要监听什么事件。</p><p>struct epoll_event结构如下所示：</p><pre class="line-numbers language-none"><code class="language-none">// 保存触发事件的某个文件描述符相关的数据typedef union epoll_data {    void *ptr;    int fd;    __uint32_t u32;    __uint64_t u64;} epoll_data_t;// 感兴趣的事件和被触发的事件struct epoll_event {    __uint32_t events; // Epoll events    epoll_data_t data; // User data variable};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上所示，对于Epoll Events，其可以是以下几个宏的集合：</p><p>EPOLLIN：表示对应的文件描述符可读（包括对端Socket）；</p><p>EPOLLOUT：表示对应的文件描述符可写；</p><p>EPOLLPRI：表示对应的文件描述符有紧急数据可读（带外数据）；</p><p>EPOLLERR：表示对应的文件描述符发生错误；</p><p>EPOLLHUP：表示对应的文件描述符被挂断；</p><p>EPOLLET：将EPOLL设为边缘触发（Edge Triggered），这是相对于水平触发（Level Triggered）而言的。</p><p>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket，需要再次</p><h1 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h1><p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</p><p>收集在epoll监控的事件中已经发生的事件。参数events是分配好的epoll_event结构体数组，epoll将会把发生的事件赋值到events数组中（events不可以是空指针，内核只负责把数据赋值到这个event数组中，不会去帮助我们在用户态分配内存）。maxevents告诉内核这个events数组有多大，这个maxevents的值不能大于创建epoll_create时的size。参数timeout是超时时间（毫秒）。如果函数调用成功，则返回对应IO上已准备好的文件描述符数目，如果返回0则表示已经超时。</p><h1 id="epoll工作模式"><a href="#epoll工作模式" class="headerlink" title="epoll工作模式"></a>epoll工作模式</h1><h2 id="LT模式（Level-Triggered，水平触发）"><a href="#LT模式（Level-Triggered，水平触发）" class="headerlink" title="LT模式（Level Triggered，水平触发）"></a>LT模式（Level Triggered，水平触发）</h2><p>该模式是epoll的缺省工作模式，其同时支持阻塞和非阻塞socket。内核会告诉开发者一个文件描述符是否就绪，如果开发者不采取任何操作，内核仍会一直通知。</p><h2 id="ET模式（Edge-Triggered，边缘触发）"><a href="#ET模式（Edge-Triggered，边缘触发）" class="headerlink" title="ET模式（Edge Triggered，边缘触发）"></a>ET模式（Edge Triggered，边缘触发）</h2><p>该模式是一种高速处理模式，当且仅当状态发生变化时才会获得通知。在该模式下，其假定开发者在接收到一次通知后，会完整地处理该事件，因此内核将不再通知这一事件。注意，缓冲区中还有未处理的数据不能说是状态变化，因此，在ET模式下，开发者如果只读取了一部分数据，其将再也得不到通知了。正确的做法是，开发者自己确认读完了所有的字节（一直调用read/write直到出错EAGAGIN为止）。</p><p>Nginx默认采用的就是ET（边缘触发）。</p><h1 id="epoll高效性探讨"><a href="#epoll高效性探讨" class="headerlink" title="epoll高效性探讨"></a>epoll高效性探讨</h1><p>epoll的高效性主要体现在以下三个方面：</p><p>（1）select/poll每次调用都要传递所要监控的所有fd给select/poll系统调用，这意味着每次调用select/poll时都要将fd列表从用户空间拷贝到内核，当fd数目很多时，这会造成性能低效。对于epoll_wait，每次调用epoll_wait时，其不需要将fd列表传递给内核，epoll_ctl不需要每次都拷贝所有的fd列表，只需要进行增量式操作。因此，在调用epoll_create函数之后，内核已经在内核开始准备数据结构用于存放需要监控的fd了。其后，每次epoll_ctl只是对这个数据结构进行简单的维护操作即可。</p><p>（2）内核使用slab机制，为epoll提供了快速的数据结构。在内核里，一切都是文件。因此，epoll向内核注册了一个文件系统，用于存储所有被监控的fd。当调用epoll_create时，就会在这个虚拟的epoll文件系统中创建一个file节点。epoll在被内核初始化时，同时会分配出epoll自己的内核告诉cache区，用于存放每个我们希望监控的fd。这些fd会以红黑树的形式保存在内核cache里，以支持快速查找、插入和删除。这个内核高速cache，就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配好想要的size的内存对象，每次使用时都使用空闲的已分配好的对象。</p><p>（3）当调用epoll_ctl往epfd注册百万个fd时，epoll_wait仍然能够快速返回，并有效地将发生的事件fd返回给用户。原因在于，当我们调用epoll_create时，内核除了帮我们在epoll文件系统新建file节点，同时在内核cache创建红黑树用于存储以后由epoll_ctl传入的fd外，还会再建立一个list链表，用于存储准备就绪的事件。当调用epoll_wait时，仅仅观察这个list链表中有无数据即可。如果list链表中有数据，则返回这个链表中的所有元素；如果list链表中没有数据，则sleep然后等到timeout超时返回。所以，epoll_wait非常高效，而且，通常情况下，即使我们需要监控百万计的fd，但大多数情况下，一次也只返回少量准备就绪的fd而已。因此，每次调用epoll_wait，其仅需要从内核态复制少量的fd到用户空间而已。那么，这个准备就绪的list链表是怎么维护的呢？过程如下：当我们执行epoll_ctl时，除了把fd放入到epoll文件系统里file对象对应的红黑树之外，还会给内核中断处理程序注册一个回调函数，其告诉内核，如果这个fd的中断到了，就把它放到准备就绪的list链表中。</p><p>如此，一棵红黑树、一张准备就绪的fd链表以及少量的内核cache，就帮我们解决了高并发下fd的处理问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>执行epoll_create时，创建了红黑树和就绪list链表；</p><p>执行epoll_ctl时，如果增加fd，则检查在红黑树中是否存在，存在则立即返回，不存在则添加到红黑树<br>中，然后向内核注册回调函数，用于当中断事件到来时向准备就绪的list链表中插入数据。</p><p>执行epoll_wait时立即返回准备就绪链表里的数据即可。</p><h1 id="epoll源码分析"><a href="#epoll源码分析" class="headerlink" title="epoll源码分析"></a>epoll源码分析</h1><p>eventpoll_init过程：</p><pre class="line-numbers language-none"><code class="language-none">static int __init eventpoll_init(void){    int error;    init_MUTEX(&amp;epsem);    /* Initialize the structure used to perform safe poll wait head wake ups */    ep_poll_safewake_init(&amp;psw);    /* Allocates slab cache used to allocate "struct epitem" items */    epi_cache = kmem_cache_create("eventpoll_epi", sizeof(struct epitem),            0, SLAB_HWCACHE_ALIGN|EPI_SLAB_DEBUG|SLAB_PANIC,            NULL, NULL);    /* Allocates slab cache used to allocate "struct eppoll_entry" */    pwq_cache = kmem_cache_create("eventpoll_pwq",            sizeof(struct eppoll_entry), 0,            EPI_SLAB_DEBUG|SLAB_PANIC, NULL, NULL);    /*     * Register the virtual file system that will be the source of inodes     * for the eventpoll files     */    error = register_filesystem(&amp;eventpoll_fs_type);    if (error)        goto epanic;    /* Mount the above commented virtual file system */    eventpoll_mnt = kern_mount(&amp;eventpoll_fs_type);    error = PTR_ERR(eventpoll_mnt);    if (IS_ERR(eventpoll_mnt))        goto epanic;    DNPRINTK(3, (KERN_INFO "[%p] eventpoll: successfully initialized.\n",            current));    return 0;epanic:    panic("eventpoll_init() failed\n");}1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，epoll用slab分配器kmem_cache_create分配内存用于存放struct epitem和struct eppoll_entry。</p><p>当向系统中添加一个fd时，就会创建一个epitem结构体，这是内核管理epoll的基本数据结构：</p><p>````<br>/*</p><ul><li><p>Each file descriptor added to the eventpoll interface will</p></li><li><p>have an entry of this type linked to the hash.</p></li><li><p>/<br>struct epitem {<br>   /* RB-Tree node used to link this structure to the eventpoll rb-tree */<br>   struct rb_node rbn;   // 用于主结构管理的红黑树</p><p>   /* List header used to link this structure to the eventpoll ready list */<br>   struct list_head rdllink;  // 事件就绪队列</p><p>   /* The file descriptor information this item refers to */<br>   struct epoll_filefd ffd; // 用于主结构中的链表</p><p>   /* Number of active wait queue attached to poll operations */<br>   int nwait; // 事件个数</p><p>   /* List containing poll wait queues */<br>   struct list_head pwqlist; // 双向链表，保存着被监控文件的等待队列</p><p>   /* The “container” of this item */<br>   struct eventpoll *ep;  // 该项属于哪个主结构体</p><p>   /* The structure that describe the interested events and the source fd */<br>   struct epoll_event event; // 注册的感兴趣的时间</p><p>   /*</p><pre><code>* Used to keep track of the usage count of the structure. This avoids* that the structure will desappear from underneath our processing.*/</code></pre><p>   atomic_t usecnt;</p><p>   /* List header used to link this item to the “struct file” items list */<br>   struct list_head fllink;</p><p>   /* List header used to link the item to the transfer list */<br>   struct list_head txlink;</p><p>   /*</p><pre><code>* This is used during the collection/transfer of events to userspace* to pin items empty events set.*/</code></pre><p>   unsigned int revents;<br>};</p><pre class="line-numbers language-none"><code class="language-none">对于每个epfd，其对应的数据结构为：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>/*</p></li><li><p>This structure is stored inside the “private_data” member of the file</p></li><li><p>structure and rapresent the main data sructure for the eventpoll</p></li><li><p>interface.</p></li><li><p>/<br>struct eventpoll {<br>   /* Protect the this structure access */<br>   rwlock_t lock;</p><p>   /*</p><pre><code>* This semaphore is used to ensure that files are not removed* while epoll is using them. This is read-held during the event* collection loop and it is write-held during the file cleanup* path, the epoll file exit code and the ctl operations.*/</code></pre><p>   struct rw_semaphore sem;</p><p>   /* Wait queue used by sys_epoll_wait() */<br>   wait_queue_head_t wq;</p><p>   /* Wait queue used by file-&gt;poll() */<br>   wait_queue_head_t poll_wait;</p><p>   /* List of ready file descriptors */<br>   struct list_head rdllist;  // 准备就绪的事件链表</p><p>   /* RB-Tree root used to store monitored fd structs */<br>   struct rb_root rbr;   // 用于管理所有fd的红黑树（根节点）<br>};</p></li></ul><pre class="line-numbers language-none"><code class="language-none">eventpoll在epoll_create时创建：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>/*</p><ul><li><p>It opens an eventpoll file descriptor by suggesting a storage of “size”</p></li><li><p>file descriptors. The size parameter is just an hint about how to size</p></li><li><p>data structures. It won’t prevent the user to store more than “size”</p></li><li><p>file descriptors inside the epoll interface. It is the kernel part of</p></li><li><p>the userspace epoll_create(2).</p></li><li><p>/<br>asmlinkage long sys_epoll_create(int size)<br>{<br>   int error, fd;<br>   struct eventpoll *ep;<br>   struct inode *inode;<br>   struct file *file;</p><p>   DNPRINTK(3, (KERN_INFO “[%p] eventpoll: sys_epoll_create(%d)\n”,</p><pre><code>        current, size));</code></pre><p>   /*</p><pre><code>* Sanity check on the size parameter, and create the internal data* structure ( "struct eventpoll" ).*/</code></pre><p>   error = -EINVAL;<br>   if (size &lt;= 0 || (error = ep_alloc(&amp;ep)) != 0)  // ep_alloc为eventpoll分配内存并初始化</p><pre><code>   goto eexit_1;</code></pre><p>   /*</p><pre><code>* Creates all the items needed to setup an eventpoll file. That is,* a file structure, and inode and a free file descriptor.*/</code></pre><p>   error = ep_getfd(&amp;fd, &amp;inode, &amp;file, ep); // 创建于eventpoll相关的数据结构，包括file、inode和fd等信息<br>   if (error)</p><pre><code>   goto eexit_2;</code></pre><p>   DNPRINTK(3, (KERN_INFO “[%p] eventpoll: sys_epoll_create(%d) = %d\n”,</p><pre><code>        current, size, fd));</code></pre><p>   return fd;</p></li></ul><p>eexit_2:<br>    ep_free(ep);<br>    kfree(ep);<br>eexit_1:<br>    DNPRINTK(3, (KERN_INFO “[%p] eventpoll: sys_epoll_create(%d) = %d\n”,<br>             current, size, error));<br>    return error;<br>}</p><pre class="line-numbers language-none"><code class="language-none">如上，内核中维护了一棵红黑树，大致结构如下：下面是epoll_ctl函数过程：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>/*</p><ul><li><p>The following function implements the controller interface for</p></li><li><p>the eventpoll file that enables the insertion/removal/change of</p></li><li><p>file descriptors inside the interest set.  It represents</p></li><li><p>the kernel part of the user space epoll_ctl(2).</p></li><li><p>/<br>asmlinkage long<br>sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event)<br>{<br>   int error;<br>   struct file *file, *tfile;<br>   struct eventpoll *ep;<br>   struct epitem *epi;<br>   struct epoll_event epds;</p><p>   DNPRINTK(3, (KERN_INFO “[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p)\n”,</p><pre><code>        current, epfd, op, fd, event));</code></pre><p>   error = -EFAULT;<br>   if (ep_op_hash_event(op) &amp;&amp;</p><pre><code>   copy_from_user(&amp;epds, event, sizeof(struct epoll_event)))   goto eexit_1;</code></pre><p>   /* Get the “struct file *” for the eventpoll file */<br>   error = -EBADF;<br>   file = fget(epfd);  // 获取epfd对应的文件<br>   if (!file)</p><pre><code>   goto eexit_1;</code></pre><p>   /* Get the “struct file *” for the target file */<br>   tfile = fget(fd);  // 获取fd对应的文件<br>   if (!tfile)</p><pre><code>   goto eexit_2;</code></pre><p>   /* The target file descriptor must support poll */<br>   error = -EPERM;<br>   if (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)</p><pre><code>   goto eexit_3;</code></pre><p>   /*</p><pre><code>* We have to check that the file structure underneath the file descriptor* the user passed to us _is_ an eventpoll file. And also we do not permit* adding an epoll file descriptor inside itself.*/</code></pre><p>   error = -EINVAL;<br>   if (file == tfile || !is_file_epoll(file))</p><pre><code>   goto eexit_3;</code></pre><p>   /*</p><pre><code>* At this point it is safe to assume that the "private_data" contains* our own data structure.*/</code></pre><p>   ep = file-&gt;private_data;</p><p>   down_write(&amp;ep-&gt;sem);</p><p>   /* Try to lookup the file inside our hash table */<br>   epi = ep_find(ep, tfile, fd);  // 在哈希表中查询，防止重复添加</p><p>   error = -EINVAL;<br>   switch (op) {<br>   case EPOLL_CTL_ADD:  // 添加节点，调用ep_insert函数</p><pre><code>   if (!epi) {       epds.events |= POLLERR | POLLHUP;       error = ep_insert(ep, &amp;epds, tfile, fd);   } else       error = -EEXIST;   break;</code></pre><p>   case EPOLL_CTL_DEL:  // 删除节点，调用ep_remove函数</p><pre><code>   if (epi)       error = ep_remove(ep, epi);   else       error = -ENOENT;   break;</code></pre><p>   case EPOLL_CTL_MOD:  // 修改节点，调用ep_modify函数</p><pre><code>   if (epi) {       epds.events |= POLLERR | POLLHUP;       error = ep_modify(ep, epi, &amp;epds);   } else       error = -ENOENT;   break;</code></pre><p>   }</p><p>   /*</p><pre><code>* The function ep_find() increments the usage count of the structure* so, if this is not NULL, we need to release it.*/</code></pre><p>   if (epi)</p><pre><code>   ep_release_epitem(epi);</code></pre><p>   up_write(&amp;ep-&gt;sem);</p></li></ul><p>eexit_3:<br>    fput(tfile);<br>eexit_2:<br>    fput(file);<br>eexit_1:<br>    DNPRINTK(3, (KERN_INFO “[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p) = %d\n”,<br>             current, epfd, op, fd, event, error));</p><pre><code>return error;</code></pre><p>}</p><pre class="line-numbers language-none"><code class="language-none">对于ep_insert函数，基本代码如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>static int ep_insert(struct eventpoll *ep, struct epoll_event *event,<br>             struct file *tfile, int fd)<br>{<br>    int error, revents, pwake = 0;<br>    unsigned long flags;<br>    struct epitem *epi;<br>    struct ep_pqueue epq;</p><pre><code>error = -ENOMEM;// 分配一个epitem结构体来保存每个加入的fdif (!(epi = kmem_cache_alloc(epi_cache, SLAB_KERNEL)))    goto eexit_1;/* Item initialization follow here ... */// 初始化结构体ep_rb_initnode(&amp;epi-&gt;rbn);INIT_LIST_HEAD(&amp;epi-&gt;rdllink);INIT_LIST_HEAD(&amp;epi-&gt;fllink);INIT_LIST_HEAD(&amp;epi-&gt;txlink);INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);epi-&gt;ep = ep;ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);epi-&gt;event = *event;atomic_set(&amp;epi-&gt;usecnt, 1);epi-&gt;nwait = 0;/* Initialize the poll table using the queue callback */epq.epi = epi;// 安装poll回调函数init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);/* * Attach the item to the poll hooks and get current event bits. * We can safely use the file* here because its usage count has * been increased by the caller of this function. */// 将当前item添加至poll hook中，然后获取当前event位revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);/* * We have to check if something went wrong during the poll wait queue * install process. Namely an allocation for a wait queue failed due * high memory pressure. */if (epi-&gt;nwait &lt; 0)    goto eexit_2;/* Add the current item to the list of active epoll hook for this file */spin_lock(&amp;tfile-&gt;f_ep_lock);list_add_tail(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);spin_unlock(&amp;tfile-&gt;f_ep_lock);/* We have to drop the new item inside our item list to keep track of it */write_lock_irqsave(&amp;ep-&gt;lock, flags);/* Add the current item to the rb-tree */ep_rbtree_insert(ep, epi);/* If the file is already "ready" we drop it inside the ready list */if ((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink)) {    list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);    /* Notify waiting tasks that events are available */    if (waitqueue_active(&amp;ep-&gt;wq))        wake_up(&amp;ep-&gt;wq);    if (waitqueue_active(&amp;ep-&gt;poll_wait))        pwake++;}write_unlock_irqrestore(&amp;ep-&gt;lock, flags);/* We have to call this outside the lock */if (pwake)    ep_poll_safewake(&amp;psw, &amp;ep-&gt;poll_wait);DNPRINTK(3, (KERN_INFO "[%p] eventpoll: ep_insert(%p, %p, %d)\n",         current, ep, tfile, fd));return 0;</code></pre><p>eexit_2:<br>    ep_unregister_pollwait(ep, epi);</p><pre><code>/* * We need to do this because an event could have been arrived on some * allocated wait queue. */write_lock_irqsave(&amp;ep-&gt;lock, flags);if (ep_is_linked(&amp;epi-&gt;rdllink))    ep_list_del(&amp;epi-&gt;rdllink);write_unlock_irqrestore(&amp;ep-&gt;lock, flags);kmem_cache_free(epi_cache, epi);</code></pre><p>eexit_1:<br>    return error;<br>}</p><pre class="line-numbers language-none"><code class="language-none">其中，init_poll_funcptr和tfile-&gt;f_op-&gt;poll将ep_ptable_queue_proc注册到epq.pt中的qproc中。ep_ptable_queue_proc函数设置了等待队列的ep_poll_callback回调函数。在设备硬件数据到来时，硬件中断函数唤醒该等待队列上等待的进程时，会调用唤醒函数ep_poll_callback。ep_poll_callback函数主要的功能是将被监视文件的等待事件就绪时，将文件对应的epitem实例添加到就绪队列中，当用户调用epoll_wait时，内核会将就绪队列中的事件报告给用户。epoll_wait的实现如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>/*</p><ul><li><p>Implement the event wait interface for the eventpoll file. It is the kernel</p></li><li><p>part of the user space epoll_wait(2).</p></li><li><p>/<br>asmlinkage long sys_epoll_wait(int epfd, struct epoll_event __user *events,</p><pre><code>              int maxevents, int timeout)</code></pre><p>{<br>   int error;<br>   struct file *file;<br>   struct eventpoll *ep;</p><p>   DNPRINTK(3, (KERN_INFO “[%p] eventpoll: sys_epoll_wait(%d, %p, %d, %d)\n”,</p><pre><code>        current, epfd, events, maxevents, timeout));</code></pre><p>   /* The maximum number of event must be greater than zero */<br>   if (maxevents &lt;= 0 || maxevents &gt; MAX_EVENTS) // 检查maxevents参数</p><pre><code>   return -EINVAL;</code></pre><p>   /* Verify that the area passed by the user is writeable */<br>   // 检查用户空间传入的events指向的内存是否可写<br>   if (!access_ok(VERIFY_WRITE, events, maxevents * sizeof(struct epoll_event))) {</p><pre><code>   error = -EFAULT;   goto eexit_1;</code></pre><p>   }</p><p>   /* Get the “struct file *” for the eventpoll file */<br>   error = -EBADF;<br>   file = fget(epfd); // 获取epfd对应的eventpoll文件的file实例，file结构是在epoll_create中创建的<br>   if (!file)</p><pre><code>   goto eexit_1;</code></pre><p>   /*</p><pre><code>* We have to check that the file structure underneath the fd* the user passed to us _is_ an eventpoll file.*/</code></pre><p>   error = -EINVAL;<br>   if (!is_file_epoll(file))</p><pre><code>   goto eexit_2;</code></pre><p>   /*</p><pre><code>* At this point it is safe to assume that the "private_data" contains* our own data structure.*/</code></pre><p>   ep = file-&gt;private_data;</p><p>   /* Time to fish for events … */<br>   // 核心处理函数<br>   error = ep_poll(ep, events, maxevents, timeout);</p></li></ul><p>eexit_2:<br>    fput(file);<br>eexit_1:<br>    DNPRINTK(3, (KERN_INFO “[%p] eventpoll: sys_epoll_wait(%d, %p, %d, %d) = %d\n”,<br>             current, epfd, events, maxevents, timeout, error));</p><pre><code>return error;</code></pre><p>}</p><pre class="line-numbers language-none"><code class="language-none">其中，调用ep_poll函数，具体流程如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,<br>           int maxevents, long timeout)<br>{<br>    int res, eavail;<br>    unsigned long flags;<br>    long jtimeout;<br>    wait_queue_t wait;</p><pre><code>/* * Calculate the timeout by checking for the "infinite" value ( -1 ) * and the overflow condition. The passed timeout is in milliseconds, * that why (t * HZ) / 1000. */jtimeout = (timeout &lt; 0 || timeout &gt;= EP_MAX_MSTIMEO) ?    MAX_SCHEDULE_TIMEOUT : (timeout * HZ + 999) / 1000;</code></pre><p>retry:<br>    write_lock_irqsave(&amp;ep-&gt;lock, flags);</p><pre><code>res = 0;if (list_empty(&amp;ep-&gt;rdllist)) {    /*     * We don't have any available event to return to the caller.     * We need to sleep here, and we will be wake up by     * ep_poll_callback() when events will become available.     */    init_waitqueue_entry(&amp;wait, current);    add_wait_queue(&amp;ep-&gt;wq, &amp;wait);    for (;;) {        /*         * We don't want to sleep if the ep_poll_callback() sends us         * a wakeup in between. That's why we set the task state         * to TASK_INTERRUPTIBLE before doing the checks.         */        set_current_state(TASK_INTERRUPTIBLE);        if (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)            break;        if (signal_pending(current)) {            res = -EINTR;            break;        }        write_unlock_irqrestore(&amp;ep-&gt;lock, flags);        jtimeout = schedule_timeout(jtimeout);        write_lock_irqsave(&amp;ep-&gt;lock, flags);    }    remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);    set_current_state(TASK_RUNNING);}/* Is it worth to try to dig for events ? */eavail = !list_empty(&amp;ep-&gt;rdllist);write_unlock_irqrestore(&amp;ep-&gt;lock, flags);/* * Try to transfer events to user space. In case we get 0 events and * there's still timeout left over, we go trying again in search of * more luck. */if (!res &amp;&amp; eavail &amp;&amp;    !(res = ep_events_transfer(ep, events, maxevents)) &amp;&amp; jtimeout)    goto retry;return res;</code></pre><p>}</p><p>```</p><p>ep_send_events函数用于向用户空间发送就绪事件。ep_send_events函数将用户传入的内存简单封装到ep_send_events_data结构中，然后调用ep_scan_ready_list将就绪队列中的事件传入用户空间的内存。</p><p>六、参考<br>Epoll详解及源码分析——CSDN博客</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解select 模型     （源码分析 ）</title>
      <link href="shen-ru-li-jie-select-mo-xing-yuan-ma-fen-xi/"/>
      <url>shen-ru-li-jie-select-mo-xing-yuan-ma-fen-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 本篇主要参照 [深入select多路复用内核源码加驱动实现][1] 和 [Linux内核select源码剖析][2]</p></blockquote><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>下面这些是用户态下可调用的API函数</p><pre class="line-numbers language-none"><code class="language-none"># include &lt;sys/select.h&gt;int select(int nfds, fd_set *readfds, fd_set *writefds,            fd_set *exceptfds, struct timeval *timeout);void FD_CLR(int fd, fd_set *set);int  FD_ISSET(int fd, fd_set *set);void FD_SET(int fd, fd_set *set);void FD_ZERO(fd_set *set);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中以大写的FD_为前缀的函数并非系统调用，而是几个对fd_set进行相关位操作的宏，对应原型定义如下<strong>（/usr/include/sys/select.h和/usr/include/bits/select.h）</strong>：</p><pre class="line-numbers language-none"><code class="language-none">typedef long int __fd_mask; # define __NFDBITS       (8 * (int) sizeof (__fd_mask))# define __FD_ELT(d)     ((d) / __NFDBITS)# define __FD_MASK(d)    ((__fd_mask) 1 &lt;&lt; ((d) % __NFDBITS)) /* fd_set for select and pselect.  */ typedef struct   {     /* XPG4.2 requires this member name.  Otherwise avoid the name        from the global namespace.  */ # ifdef __USE_XOPEN     __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS]; # define __FDS_BITS(set) ((set)-&gt;fds_bits) # else     __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS]; # define __FDS_BITS(set) ((set)-&gt;__fds_bits) # endif   } fd_set; /* Maximum number of file descriptors in `fd_set'.  */# define FD_SETSIZE              __FD_SETSIZE  //这是指定 最大数量的文件描述符 // sys/select.h# define FD_SET(fd, fdsetp)      __FD_SET (fd, fdsetp)# define FD_CLR(fd, fdsetp)      __FD_CLR (fd, fdsetp)# define FD_ISSET(fd, fdsetp)    __FD_ISSET (fd, fdsetp)# define FD_ZERO(fdsetp)         __FD_ZERO (fdsetp) // bits/select.h# define __FD_ZERO(fdsp) \  do {                                                                        \    int __d0, __d1;                                                           \    __asm__ __volatile__ ("cld; rep; " __FD_ZERO_STOS                         \                          : "=c" (__d0), "=D" (__d1)                          \                          : "a" (0), "0" (sizeof (fd_set)                     \                                          / sizeof (__fd_mask)),              \                            "1" (&amp;__FDS_BITS (fdsp)[0])                       \                          : "memory");                                        \  } while (0) //实际调用的宏# define __FD_SET(d, set) \     ((void) (__FDS_BITS (set)[__FD_ELT (d)] |= __FD_MASK (d)))# define __FD_CLR(d, set) \   ((void) (__FDS_BITS (set)[__FD_ELT (d)] &amp;= ~__FD_MASK (d)))# define __FD_ISSET(d, set) \   ((__FDS_BITS (set)[__FD_ELT (d)] &amp; __FD_MASK (d)) != 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面可以看到fd_set结构体的定义实际包含的是fds_bits位数组，其大小固定，由FD_SETSIZE指定（/usr/include/bits/typesizes.h中），在当前内核中数值为1024，可见每次select系统调用可监听处理的文件描述符最大数量为1024。<br>其中宏定义体中如__FD_SET对应的（void），作用为消除编译器对类型不一致相关的警告，并无其它附加意义。</p><p>言归正传，找到用户态下select系统调用入口为为：</p><p>SYSCALL_DEFINE5(select, int, n, fd_set __user *, inp, fd_set __user *, outp,<br>        fd_set __user *, exp, struct timeval __user *, tvp)<br>{<br>    struct timespec end_time, *to = NULL;<br>    struct timeval tv;<br>    int ret;</p><pre><code>if (tvp) {    if (copy_from_user(&amp;tv, tvp, sizeof(tv)))        return -EFAULT;    to = &amp;end_time;    if (poll_select_set_timeout(to,            tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),            (tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))        return -EINVAL;}ret = core_sys_select(n, inp, outp, exp, to);ret = poll_select_copy_remaining(&amp;end_time, tvp, 1, ret);return ret;</code></pre><p>}</p><h2 id="sys-select"><a href="#sys-select" class="headerlink" title="sys_select"></a>sys_select</h2><p>言归正传，找到用户态下select系统调用入口为为：</p><p>这里主要做的事情：</p><ol><li>将用户设置的超时时间从用户态拷贝到内核态</li><li>对时间进行转换</li><li>调用core_sys_select</li><li>将剩余时间拷贝到用户进程时间<pre class="line-numbers language-none"><code class="language-none"># undef __NFDBITS# define __NFDBITS    (8 * sizeof(unsigned long))# undef __FD_SETSIZE# define __FD_SETSIZE    1024# undef __FDSET_LONGS# define __FDSET_LONGS    (__FD_SETSIZE/__NFDBITS) typedef struct {    unsigned longfds_bits [__FDSET_LONGS];   //1024个bit。可以看到可以支持1024个描述符} __kernel_fd_set;//系统调用（内核态）//参数为 maxfd, r_fds, w_fds, e_fds, timeout。asmlinkage long sys_select(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct timeval __user *tvp){    s64 timeout = -1;    struct timeval tv;    int ret;    //将超时时间换成jiffies    if (tvp) {        if (copy_from_user(&amp;tv, tvp, sizeof(tv))) //将用户态参数拷贝到内核态            return -EFAULT;         if (tv.tv_sec &lt; 0 || tv.tv_usec &lt; 0)            return -EINVAL;         /* Cast to u64 to make GCC stop complaining */        if ((u64)tv.tv_sec &gt;= (u64)MAX_INT64_SECONDS)            timeout = -1;    /* infinite */        else {            timeout = ROUND_UP(tv.tv_usec, USEC_PER_SEC/HZ);            timeout += tv.tv_sec * HZ;        }    }    // (***) 调用 core_sys_select    ret = core_sys_select(n, inp, outp, exp, &amp;timeout);    //将剩余时间拷贝回用户空间进程    if (tvp) {        struct timeval rtv;        if (current-&gt;personality &amp; STICKY_TIMEOUTS) //判断当前环境是否支持修改超时时间（不确定）            goto sticky;        rtv.tv_usec = jiffies_to_usecs(do_div((*(u64*)&amp;timeout), HZ));        rtv.tv_sec = timeout;        if (timeval_compare(&amp;rtv, &amp;tv) &gt;= 0)            rtv = tv;        if (copy_to_user(tvp, &amp;rtv, sizeof(rtv))) {sticky:            /*             * 如果应用程序将timeval值放在只读存储中，             * 我们不希望在成功完成select后引发错误（修改timeval）             * 但是，因为没修改timeval，所以我们不能重启这个系统调用。             */            if (ret == -ERESTARTNOHAND)                ret = -EINTR;        }    }    return ret;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="core-sys-select"><a href="#core-sys-select" class="headerlink" title="core_sys_select"></a>core_sys_select</h2><p>上面的都是时间方面的准备工作 , 对于需要监听的集合的操作是通过core_sys_select 来进行的</p><pre class="line-numbers language-none"><code class="language-none">//主要的工作在这个函数中完成staticint core_sys_select(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, s64 *timeout){    fd_set_bits fds;    /*  fd_set_bits 结构如下：     typedef struct {         unsigned long *in, *out, *ex;         unsigned long *res_in, *res_out, *res_ex;    } fd_set_bits;    这个结构体中定义的全是指针，这些指针都是用来指向描述符集合的。     */    void *bits;    int ret, max_fds;    unsigned int size;    struct fdtable *fdt;    /* Allocate small arguments on the stack to save memory and be faster 先尝试使用栈（因为栈省内存且快速）*/    long stack_fds[SELECT_STACK_ALLOC/sizeof(long)];  // SELECT_STACK_ALLOC=256    //执行后stack_fds= 32  (sizeof(long)=8)    ret = -EINVAL;    if (n &lt; 0)   //传入的描述符无效         goto out_nofds;    /* max_fds can increase, so grab it once to avoid race */     //最大描述符是会改变的,加锁避免竞争    rcu_read_lock(); //rcu锁    fdt = files_fdtable(current-&gt;files); //读取文件描述符表    /*  struct fdtable 结构如下：    struct fdtable {       unsigned int max_fds;       struct file **fd;       ...    };     */    max_fds = fdt-&gt;max_fds; //从files结构中获取最大值（当前进程能够处理的最大文件数目）    rcu_read_unlock();    if (n &gt; max_fds)// 如果传入的n大于当前进程最大的文件描述符，给予修正        n = max_fds;    /* 我们需要使用6倍于最大描述符的描述符个数,     * 分别是in/out/exception（参见fd_set_bits结构体）,     * 并且每份有一个输入和一个输出(用于结果返回) */    size = FDS_BYTES(n);// 以一个文件描述符占一bit来计算，传递进来的这些fd_set需要用掉多少个字    bits = stack_fds;    if (size &gt; sizeof(stack_fds) / 6) { // 除以6，因为每个文件描述符需要6个bitmaps上的位。        //栈不能满足，先前的尝试失败，只能使用kmalloc方式        /* Not enough space in on-stack array; must use kmalloc */        ret = -ENOMEM;        bits = kmalloc(6 * size, GFP_KERNEL);        if (!bits)            goto out_nofds;    }    //设置fds    fds.in      = bits;    fds.out     = bits +   size;    fds.ex      = bits + 2*size;    fds.res_in  = bits + 3*size;    fds.res_out = bits + 4*size;    fds.res_ex  = bits + 5*size;    // get_fd_set仅仅调用copy_from_user从用户空间拷贝了fd_se    if ((ret = get_fd_set(n, inp, fds.in)) ||        (ret = get_fd_set(n, outp, fds.out)) ||        (ret = get_fd_set(n, exp, fds.ex)))        goto out;    // 对这些存放返回状态的字段清0    zero_fd_set(n, fds.res_in);    zero_fd_set(n, fds.res_out);    zero_fd_set(n, fds.res_ex);    // 执行do_select，完成监控功能    ret = do_select(n, &amp;fds, timeout);    if (ret &lt; 0) // 有错误        goto out;    if (!ret) {  // 超时返回，无设备就绪        ret = -ERESTARTNOHAND;        if (signal_pending(current))            goto out;        ret = 0;    }    if (set_fd_set(n, inp, fds.res_in) ||        set_fd_set(n, outp, fds.res_out) ||        set_fd_set(n, exp, fds.res_ex))        ret = -EFAULT;out:    if (bits != stack_fds)        kfree(bits);out_nofds:    return ret;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>![core_select.png][3]</p><h2 id="do-select"><a href="#do-select" class="headerlink" title="do_select"></a>do_select</h2><p>到目前为止,之前所有的准备工作都已经做完了,现在我们需要到真正运行的do_select 中一探究竟.但是在此之前，我们需要知道源码中比较重要的四个结构体：</p><pre class="line-numbers language-none"><code class="language-none">struct poll_wqueuesstruct poll_table_pagestruct poll_table_entrystruct poll_table_struct。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每一个调用select()系统调用的应用进程都会存在一个struct poll_wqueues结构体，用来统一辅佐实现这个进程中所有待监测的fd的轮询工作，后面所有的工作和都这个结构体有关，所以它非常重要。</p><pre class="line-numbers language-none"><code class="language-none">struct poll_wqueues {       poll_table pt;       struct poll_table_page *table;       struct task_struct *polling_task; //保存当前调用select的用户进程struct task_struct结构体       int triggered;            // 当前用户进程被唤醒后置成1，以免该进程接着进睡眠       int error;                 // 错误码       int inline_index;        // 数组inline_entries的引用下标       struct poll_table_entry inline_entries[N_INLINE_POLL_ENTRIES];};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上结构体<strong>poll_wqueues</strong>内嵌的<strong>poll_table_entry</strong>数组<strong>inline_entries[]</strong> 的大小是有限的，如果空间不够用，后续会动态申请物理内存页以链表的形式挂载<strong>poll_wqueues.table</strong>上统一管理。接下来的两个结构体就和这项内容密切相关：</p><pre class="line-numbers language-none"><code class="language-none">struct poll_table_page { // 申请的物理页都会将起始地址强制转换成该结构体指针       struct poll_table_page   *next;      // 指向下一个申请的物理页       struct poll_table_entry  *entry;     // 指向entries[]中首个待分配(空的) poll_table_entry地址       struct poll_table_entry  entries[0]; // 该page页后面剩余的空间都是待分配的poll_table_entry结构体};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对每一个fd调用<strong>fop-&gt;poll() =&gt; poll_wait() =&gt; __pollwait()<strong>都会先从</strong>poll_wqueues.inline_entries[]<strong>中分配一个</strong>poll_table_entry</strong>结构体，直到该数组用完才会分配物理页挂在链表指针<strong>poll_wqueues.table</strong>上然后才会分配一个<strong>poll_table_entry</strong>结构体（poll_get_entry函数）。</p><p>poll_table_entry具体用处：函数__pollwait声明如下：</p><pre class="line-numbers language-none"><code class="language-none">static void __pollwait(struct file *filp, wait_queue_head_t *wait_address, poll_table *p);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数调用时需要3个参数，第一个是特定fd对应的file结构体指针，第二个就是特定fd对应的硬件驱动程序中的等待队列头指针，第3个是调用select()的应用进程中poll_wqueues结构体的poll_table项（该进程监测的所有fd调用fop-&gt;poll函数都用这一个poll_table结构体）。</p><pre class="line-numbers language-none"><code class="language-none">struct poll_table_entry {       struct file     *filp;                 // 指向特定fd对应的file结构体;       unsigned long   key;                   // 等待特定fd对应硬件设备的事件掩码，如POLLIN、 POLLOUT、POLLERR;       wait_queue_t    wait;                  // 代表调用select()的应用进程，等待在fd对应设备的特定事件 (读或者写)的等待队列头上的等待队列项;       wait_queue_head_t   *wait_address;     // 设备驱动程序中特定事件的等待队列头(该fd执行fop-&gt;poll，需要等待时在哪等，所以叫等待地址)；};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)# define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)# define POLLEX_SET (POLLPRI)int do_select(int n, fd_set_bits *fds, s64 *timeout){    struct poll_wqueues table;    /*     struct poll_wqueues {          poll_table pt;          struct poll_table_page *table;          struct task_struct *polling_task; //保存当前调用select的用户进程struct task_struct结构体          int triggered;         // 当前用户进程被唤醒后置成1，以免该进程接着进睡眠          int error;             // 错误码          int inline_index;      // 数组inline_entries的引用下标          struct poll_table_entry inline_entries[N_INLINE_POLL_ENTRIES];    };     */    poll_table *wait;    int retval, i;    rcu_read_lock();    //根据已经设置好的fd位图检查用户打开的fd, 要求对应fd必须打开, 并且返回最大的fd。    retval = max_select_fd(n, fds);    rcu_read_unlock();    if (retval &lt; 0)        return retval;    n = retval;    /* 一些重要的初始化：       poll_wqueues.poll_table.qproc函数指针初始化，       该函数是驱动程序中poll函数（fop-&gt;poll）实现中必须要调用的poll_wait()中使用的函数。  */    poll_initwait(&amp;table);/*void poll_initwait(struct poll_wqueues *pwq){    // 设置回调函数 __pollwait    init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait);    pwq-&gt;error = 0;    pwq-&gt;table = NULL;    pwq-&gt;inline_index = 0;}static inline void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc){    pt-&gt;qproc = qproc;}这个函数实现很关键，这里 init_poll_funcptr 初始化回调函数为 __pollwait, 后面轮询会回调这个函数，然后通过这个函数把进程添加到对应的监听文件等待队列，当有事件到来时，就会唤醒这个进程。*/    wait = &amp;table.pt;   //这里把 wait 设置为这个回调函数的指针    if (!*timeout)//当 timeout=0 的时候把wait设置为 0，这个可以实现非阻塞的功能        wait = NULL;           retval = 0;    for (;;) {        unsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;        long __timeout;        set_current_state(TASK_INTERRUPTIBLE);        inp = fds-&gt;in; outp = fds-&gt;out; exp = fds-&gt;ex;        rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;        // 所有n个fd的循环        for (i = 0; i &lt; n; ++rinp, ++routp, ++rexp) {            unsigned long in, out, ex, all_bits, bit = 1, mask, j;            unsigned long res_in = 0, res_out = 0, res_ex = 0;            const struct file_operations *f_op = NULL;            struct file *file = NULL;             // 先取出当前循环周期中的32（设long占32位）个文件描述符对应的bitmaps            in = *inp++; out = *outp++; ex = *exp++;            all_bits = in | out | ex;// 组合一下，有的fd可能只监测读，或者写，或者err，或者同时都监测            if (all_bits == 0) {                i += __NFDBITS; //如果这个字没有待查找的描述符, 跳过这个长字(32位，__NFDBITS=32)，取下一个32个fd的循环中                continue;            }            // 本次32个fd的循环中有需要监测的状态存在            for (j = 0; j &lt; __NFDBITS; ++j, ++i, bit &lt;&lt;= 1) {                int fput_needed;                if (i &gt;= n)                   break;                if (!(bit &amp; all_bits)) // bit每次循环后左移一位的作用在这里，用来跳过没有状态监测的fd                   continue;                file = fget_light(i, &amp;fput_needed);//得到file结构指针，并增加引用计数字段f_count                if (file) {// 如果file存在（这个文件描述符对应的文件确实打开了）                    f_op = file-&gt;f_op;                    mask = DEFAULT_POLLMASK;                // 这里会调用 struct file*实现的poll函数进行轮询                    if (f_op &amp;&amp; f_op-&gt;poll) //这个文件对应的驱动程序提供了poll函数（fop-&gt;poll）。                        mask = (*f_op-&gt;poll)(file, retval ? NULL : wait);//调用驱动程序中的poll函数。                    /*  调用驱动程序中的poll函数，以evdev驱动中的evdev_poll()为例                     *  该函数会调用函数poll_wait(file, &amp;evdev-&gt;wait, wait)，                     *  继续调用__pollwait()回调来分配一个poll_table_entry结构体，                     *  该结构体有一个内嵌的等待队列项，                     *  设置好wake时调用的回调函数后将其添加到驱动程序中的等待队列头中。  */                    fput_light(file, fput_needed);  // 释放file结构指针，实际就是减小他的一个引用计数字段f_count。                    //记录结果。poll函数返回的mask是设备的状态掩码。                    if ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) {                        res_in |= bit; //如果是这个描述符可读, 将这个位置位                        retval++;   //返回描述符个数加1                    }                    if ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) {                        res_out |= bit;                        retval++;                    }                    if ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) {                        res_ex |= bit;                        retval++;                    }                }                /*                 *  cond_resched()将判断是否有进程需要抢占当前进程，                 *  如果是将立即发生调度，这只是为了增加强占点。                 *  （给其他紧急进程一个机会去执行，增加了实时性）                 *  在支持抢占式调度的内核中（定义了CONFIG_PREEMPT），                 *  cond_resched是空操作。                 */                cond_resched();            }            //返回结果            if (res_in)                *rinp = res_in;            if (res_out)                *routp = res_out;            if (res_ex)               *rexp = res_ex;        }        wait = NULL;        if (retval || !*timeout || signal_pending(current)) // signal_pending(current)检查当前进程是否有信号要处理            break;        if(table.error) {            retval = table.error;            break;        }         if (*timeout &lt; 0) {            /* Wait indefinitely 无限期等待*/            __timeout = MAX_SCHEDULE_TIMEOUT;        } elseif (unlikely(*timeout &gt;= (s64)MAX_SCHEDULE_TIMEOUT - 1)) {            /* Wait for longer than MAX_SCHEDULE_TIMEOUT. Do it in a loop */            __timeout = MAX_SCHEDULE_TIMEOUT - 1;            *timeout -= __timeout;        } else {            __timeout = *timeout;            *timeout = 0;       }         /* schedule_timeout 用来让出CPU；          * 在指定的时间用完以后或者其它事件到达并唤醒进程（比如接收了一个信号量）时，          * 该进程才可以继续运行  */        __timeout = schedule_timeout(__timeout);        if (*timeout &gt;= 0)            *timeout += __timeout;    }    __set_current_state(TASK_RUNNING);    poll_freewait(&amp;table);    return retval;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>![do_select.png][4]</p><blockquote><p>引用自论[select的实现][5]</p></blockquote><p>上面的实现看起来一上来就是轮询，假设所有的文件描述符都没有数据可以读写，会怎么样呢? 理论上应该需要监听所有的文件描述符，当有其中一个有数据到来时就唤醒进程。那么哪个地方把进程添加到文件描述符对应的监听列表呢?</p><p>对于 tcp 的文件描述符, 他的 poll 函数实现（跟我们上面的poll不是一个东西），调用了sock_poll, 里面又调用了 tcp_poll, tcp_poll 里面会执行下面步骤:</p><p>调用 poll_wait<br>查询当前文件描述符的状态，是否可读写。</p><pre class="line-numbers language-none"><code class="language-none">unsigned int tcp_poll(struct file *file, struct socket *sock, poll_table *wait){    ...    poll_wait(file, sk-&gt;sk_sleep, wait);    ...}static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p){    if (p &amp;&amp; wait_address)        p-&gt;qproc(filp, wait_address, p);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回到上面的问题，就是通过 poll_wait 函数把当前进程挂到 sk-&gt;sk_sleep 这个队列里面来，当有读写事件到来时，就会唤醒这个队列里面的进程，让他们重新运行，来轮询读写数据。</p><p>而这个 qproc 函数就是上面 poll_initwait 函数初始化的回调函数 __pollwait。</p><pre class="line-numbers language-none"><code class="language-none">static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,                poll_table *p){    struct poll_table_entry *entry = poll_get_entry(p);    if (!entry)        return;    get_file(filp);    entry-&gt;filp = filp;    entry-&gt;wait_address = wait_address;    init_waitqueue_entry(&amp;entry-&gt;wait, current);    // 新添加的进程添加到设备事件触发等待队列    add_wait_queue(wait_address, &amp;entry-&gt;wait);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数实现就是把当前进程挂到 sk-&gt;sleep 队列。 上面还可以看到调用回调函数的条件必须是 wait_address 和 p 不为空，也就是说如果不想把文件描述挂到监听列表，只需要把 p 这个参数设置为 NULL.</p><p>因为进程挂到某一个文件的监听列表，只要挂一次即可。所以第一次循环之后把所有的文件描述符挂一遍之后就会把这个参数设置为 NULL。</p><p>还有两种情况也会把这个参数设置为 NULL:</p><p>1、 已经有文件描述符有读写事件，不需要再挂，因为一遍轮询就会退出，取消所有监听。</p><pre class="line-numbers language-none"><code class="language-none">if (f_op &amp;&amp; f_op-&gt;poll)    mask = (*f_op-&gt;poll)(file, retval ? NULL : wait);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2、 最上面提到的, timeout = 0, 会把 wait 参数为 NULL, 即不会有挂载行为，轮询一遍立即返回，不等待事件到来，类似 non-blocking 的效果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的叙述，我们能看到每一次轮询调用select都需要将 集合 从用户态拷贝到内核态中，当有时间发生的时候又需要再拷贝回来.当监听的数量多的时候这样效率极低，同时也需要重新将进程挂载到监听的文件描述符中.</p><p>同时返回回来的时候并不知道有哪些事件有响应需要再重新轮询一遍.再次降低了效率.</p><h2 id="EPOLL-的改进"><a href="#EPOLL-的改进" class="headerlink" title="EPOLL 的改进"></a>EPOLL 的改进</h2><p>进程挂载到监听的文件描述符只会挂一次。<br>用专门的链表来存储有事件到来的文件描述符，返回给用户进程，只需要拷贝这个链表。<br>使用红黑树来管理文件描述符，可以做到快速添加监听的文件描述符。</p><h1 id="惊群效应"><a href="#惊群效应" class="headerlink" title="惊群效应"></a>惊群效应</h1><p>简言之，惊群现象就是多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只可能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群。</p><p>这是因为这些进程都处在同一个监听等待队列中,当有事件响应的时候，内核会通知这个队列并唤醒队列中的所有进程。</p><h2 id="惊群效应到底消耗了什么？"><a href="#惊群效应到底消耗了什么？" class="headerlink" title="惊群效应到底消耗了什么？"></a>惊群效应到底消耗了什么？</h2><ol><li>系统对用户进程/线程频繁地做无效的调度，上下文切换系统性能大打折扣。</li><li>为了确保只有一个进程得到资源，用户必须对资源操作进行加锁保护，进一步加大了系统开销。<br>&nbsp; &nbsp;&nbsp;&nbsp;是不是还是觉得不够深入，概念化？看下面：</li></ol><p>1、上下文切换（context&nbsp; switch）过高会导致cpu像个搬运工，频繁地在寄存器和运行队列之间奔波，更多的时间花在了进程（线程）切换，而不是在真正工作的进程（线程）上面。直接的消耗包括cpu寄存器要保存和加载（例如程序计数器）、系统调度器的代码需要执行。间接的消耗在于多核cache之间的共享数据。</p><p>看一下：wiki上下文切换</p><p>2、通过锁机制解决惊群效应是一种方法，在任意时刻只让一个进程（线程）处理等待的事件。但是锁机制也会造成cpu等资源的消耗和性能损耗。目前一些常见的服务器软件有的是通过锁机制解决的，比如nginx（它的锁机制是默认开启的，可以关闭）；还有些认为惊群对系统性能影响不大，没有去处理，比如lighttpd。</p><p>  [1]: <a href="https://my.oschina.net/fileoptions/blog/911091?tdsourcetag=s_pctim_aiomsg#">https://my.oschina.net/fileoptions/blog/911091?tdsourcetag=s_pctim_aiomsg#</a> h1_1<br>  [2]: <a href="http://www.pandademo.com/2016/11/linux-kernel-select-source-dissect/?tdsourcetag=s_pctim_aiomsg">http://www.pandademo.com/2016/11/linux-kernel-select-source-dissect/?tdsourcetag=s_pctim_aiomsg</a><br>  [3]: <a href="https://banthink.com/usr/uploads/2020/02/2227498139.png">https://banthink.com/usr/uploads/2020/02/2227498139.png</a><br>  [4]: <a href="https://banthink.com/usr/uploads/2020/02/1227669105.png">https://banthink.com/usr/uploads/2020/02/1227669105.png</a><br>  [5]: <a href="http://www.hulkdev.com/posts/select-io">http://www.hulkdev.com/posts/select-io</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux  I/O模型</title>
      <link href="linux-io-mo-xing/"/>
      <url>linux-io-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是I-O复用"><a href="#什么是I-O复用" class="headerlink" title="什么是I/O复用"></a>什么是I/O复用</h1><p>在客户阻塞（例如标准输入）的时候,服务器进程被杀死.这时候服务器进程虽然正确的给客户端发送了一个FIN，但是客户进程正阻塞在标准输入的过程无法读到这个EOF。这样的进程需要一种预先告知内核的能力，使内核一旦发现进程准备的一个或多个I/O准备就绪就通知进程. 这种能力被称为I/O复用</p><h1 id="常见的I-O-模型"><a href="#常见的I-O-模型" class="headerlink" title="常见的I/O 模型"></a>常见的I/O 模型</h1><ol><li>阻塞式I/O模型</li><li>非阻塞式I/O模型 (轮询访问) </li><li>I/O复用</li><li>信号驱动式I/O(SIGIO)    (例如 SIGIO) </li><li>异步I/O </li></ol><h2 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h2><p>select/poll/epoll 三种模型都是I/O复用模型。</p><p><img src="https://banthink.com/usr/uploads/2020/02/3858956023.jpg" alt="IO复用模型.jpg"></p><h2 id="信号驱动I-O-模型"><a href="#信号驱动I-O-模型" class="headerlink" title="信号驱动I/O 模型"></a>信号驱动I/O 模型</h2><p>利用SIGIO 信号实现</p><p><img src="https://banthink.com/usr/uploads/2020/02/1966609206.jpg" alt="信号驱动IO.jpg"></p><h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p><img src="https://banthink.com/usr/uploads/2020/02/2045081155.jpg" alt="异步IO.jpg"></p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p><img src="https://banthink.com/usr/uploads/2020/02/2815249748.jpg" alt="IO模型区别.jpg"></p><h1 id="Select模型"><a href="#Select模型" class="headerlink" title="Select模型"></a>Select模型</h1><p>select模型：将所有发生请求的客户端（建议1024以下）进行监听，采用的是轮询模型。<br>int select(int nfds,fd_set <em>readfds,fd_set</em> writefds,fd_set *exceptfds,struct timeval *timeout);</p><p>描述：调用此函数监听文件描述符集合中是否有读写请求，如果有，将传入参数进行置位再传出。需要进行轮询操作（while），才能达到实时监听的效果</p><p>nfds:所监听的文件描述符中，最大的文件描述符+1</p><p>readfds:监控有读数据到达文件描述符集合，传入传出参数</p><p>writefds:监控写数据到达文件描述符集合，传入传出参数</p><p>exceptfds:监控异常发生到达文件描述符集合，如带外数据到达异常，传入传出参数</p><p>timeout:定时阻塞监控事件，3中情况：</p><ol><li>NULL。永远等下去</li><li>设置timeval，等待固定时间</li><li>设置timeval里时间均为0.检查描述字后立即返回，轮询</li></ol><p>返回值：监听集合中满足条件的总数。失败返回-1</p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>理解select模型的关键在于理解fd_set类型,这个类型就是多个整型字的集合,每个bit代表一个文件描述符</p><p>当select函数执行后,系统会重新设置fd_set中的内容,接下来会对有响应的文件描述符置位.（意味着我们每一次调用select 的时候都需要将fd集合拷贝到内核态然后内核对里面进行修改.）</p><p><img src="https://banthink.com/usr/uploads/2020/02/4011600080.jpg" alt="select.jpg"></p><p>select缺点：<br>（1）每次调⽤用select，都需要把fd集合从⽤用户态拷贝到内核态，这个开销在fd很多时会很⼤大<br>（2）同时每次调⽤用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很⼤大<br>（3）select⽀支持的⽂文件描述符数量太⼩小了，默认是1024</p><p>代码</p><pre class="line-numbers language-none"><code class="language-none">/* server.c */# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;# include &lt;string.h&gt;# include &lt;netinet/in.h&gt;   # include "wrap.h"# define MAXLINE 80# define SERV_PORT 8000int main(int argc, char *argv[]){int i, maxi, maxfd, listenfd, connfd, sockfd;int nready, client[FD_SETSIZE]; /* FD_SETSIZE 默认为 1024 */ssize_t n;fd_set rset, allset;char buf[MAXLINE];char str[INET_ADDRSTRLEN]; /* # define INET_ADDRSTRLEN 16 */socklen_t cliaddr_len;struct sockaddr_in cliaddr, servaddr;listenfd = Socket(AF_INET, SOCK_STREAM, 0);bzero(&amp;servaddr, sizeof(servaddr));servaddr.sin_family = AF_INET;servaddr.sin_addr.s_addr = htonl(INADDR_ANY);servaddr.sin_port = htons(SERV_PORT);bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));listen(listenfd, 20); /* 默认最大128 */maxfd = listenfd; /* 初始化 */maxi = -1; /* client[]的下标 */for (i = 0; i &lt; FD_SETSIZE; i++)client[i] = -1; /* 用-1初始化client[] */FD_ZERO(&amp;allset);FD_SET(listenfd, &amp;allset); /* 构造select监控文件描述符集 */for ( ; ; ) {rset = allset; /* 每次循环时都从新设置select监控信号集 */nready = select(maxfd+1, &amp;rset, NULL, NULL, NULL);if (nready &lt; 0)perr_exit("select error"); if (FD_ISSET(listenfd, &amp;rset)) { /* new client connection */cliaddr_len = sizeof(cliaddr);connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);printf("received from %s at PORT %d\n",inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)),ntohs(cliaddr.sin_port));for (i = 0; i &lt; FD_SETSIZE; i++)if (client[i] &lt; 0) {client[i] = connfd; /* 保存accept返回的文件描述符到client[]里 */break;}/* 达到select能监控的文件个数上限 1024 */if (i == FD_SETSIZE) {fputs("too many clients\n", stderr);exit(1);}FD_SET(connfd, &amp;allset); /* 添加一个新的文件描述符到监控信号集里 */if (connfd &gt; maxfd)maxfd = connfd; /* select第一个参数需要 */if (i &gt; maxi)maxi = i; /* 更新client[]最大下标值 */if (--nready == 0)continue; /* 如果没有更多的就绪文件描述符继续回到上面select阻塞监听,负责处理未处理完的就绪文件描述符 */}for (i = 0; i &lt;= maxi; i++) { /* 检测哪个clients 有数据就绪 */if ( (sockfd = client[i]) &lt; 0)continue;if (FD_ISSET(sockfd, &amp;rset)) {if ( (n = Read(sockfd, buf, MAXLINE)) == 0) {/* 当client关闭链接时，服务器端也关闭对应链接 */Close(sockfd);FD_CLR(sockfd, &amp;allset); /* 解除select监控此文件描述符 */client[i] = -1;} else {int j;for (j = 0; j &lt; n; j++)buf[j] = toupper(buf[j]);Write(sockfd, buf, n);}if (--nready == 0)break;}}}close(listenfd);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP 套接字编程</title>
      <link href="tcp-tao-jie-zi-bian-cheng/"/>
      <url>tcp-tao-jie-zi-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h1><h1 id="include-lt-sys-socket-h-gt"><a href="#include-lt-sys-socket-h-gt" class="headerlink" title="include <sys/socket.h>"></a>include &lt;sys/socket.h&gt;</h1><p>int socket(int family,int type,int protocol)</p><p>@family:协议族,为0的时候系统根据后两个参数选择协议. 常用AF_INET<br>@type: 套接字类型,这边区分套接字是TCP还是UDP .如果是TCP就用SOCK_STREAM, 数据报套接字SOCK_DGRAM是UDP使用<br>@protocol: IPPROTO_TCP/IPROTO_UDP/IPROTO_SCTP  分别对应三种传输协议.如果是TCP直接写0也可以<br>返回值: 成功的时候返回非负的套接字.</p><pre class="line-numbers language-none"><code class="language-none">int connect(int sockfd,const struct sockaddr * servaddr,socklen_t addrlen)//相应结构体定义struct sockaddr {       sa_family_t sin_family;//地址族　　  char sa_data[14]; //14字节，包含套接字中的目标地址和端口信息               };struct sockaddr_in{    short sin_family; //一般来说，AF_INET（地址族）PF_INET（协议族）    unsigned short sin_port;      /* Portnumber (必须要采用网络数据格式，普通数字可以用htons()函数转换成网络数据格式的数字)*/    struct in_addr sin_addr;        /* Internet address. */    unsigned char sin_zero[8];  　　　　/* 字符数组sin_zero[8]的存在是为了保证结构体struct sockaddr_in的大小和结构体struct sockaddr的大小相等 */};int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);//成功返回0  出错返回-1 //绑定端口和IPint listen(int sockfd,int backlog); int accept(int sockfd,struct sockaddr * cliaddr,socklen_t *addrlen);//连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="关于listen-的作用"><a href="#关于listen-的作用" class="headerlink" title="关于listen 的作用"></a>关于listen 的作用</h1><p>当我们调用socket()创建一个套接字时，这个套接字是一个主动连接的套接字,通过listen()将这个套接字转换为被动连接的，指定内核应该接受指向该套接字的连接请求。</p><p>这时候socket的状态从closed转换到listen状态</p><p>第二个参数指定了内核应该为相应套接字排队的最大连接数。内核会为每一个给定的监听套接字维护两个队列：完成连接队列和未完成连接队列。</p><p>完成连接队列: 在这个队列中的套接字状态都是ESTABLISHED </p><p>未完成连接队列:  众所周知，三次握手最后一次的的包是从客户端发出的,服务器端的套接字需处SYN_RCVD状态等待响应的ACK包发送过来,这个队列存放的就是这样的套接字</p><h2 id="SYN泛滥"><a href="#SYN泛滥" class="headerlink" title="SYN泛滥"></a>SYN泛滥</h2><p>通过高速率向服务端发送SYN包来将这个未完成连接队列填满，同时在每个SYN的源地址IP都设置 成未知数，这样服务端的下一个ACK包就不知道发往什么地方，进而导致整个队列为满,使得合法的SYN排不上队,导致合法客户的连接请求被拒绝.</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>服务器简单实现了并发,同时也解决僵尸进程的问题,但是这个服务器有一个问题,当客户端和服务器建立连接之后,我们通过kill杀死服务器中客户端对应的子进程时,客户端此时正阻塞在输入中,当我们再次输入文本的时候他将返回terminated prematurely .</p><p>这是一个错误信息,因为此时客户端正在应对两个描述符:套接字和文本输入.此时阻塞在文本输入中,但是正常来说当服务器发送FIN时我们总是想要客户端能够正确马上响应,所以程序应该阻塞在其中任何一个源的输入上.这也是select和poll两个函数的目的.</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>server</p><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author: &gt; Mail: &gt; Created Time: 2020年01月26日 星期日 16时39分52秒 ************************************************************************/ # include &lt;signal.h&gt;# include &lt;sys/types.h&gt;# include &lt;sys/wait.h&gt;# include &lt;sys/socket.h&gt;# include &lt;unistd.h&gt;# include &lt;string.h&gt;# include &lt;stdlib.h&gt;# include &lt;ctype.h&gt;# include &lt;errno.h&gt;# include &lt;netinet/in.h&gt;# include &lt;arpa/inet.h&gt;# include &lt;sys/ioctl.h&gt;# include &lt;stdarg.h&gt;# include &lt;fcntl.h&gt;# include&lt;iostream&gt;using namespace std;typedef void Sigfunc(int);void sig_chld(int signo){    pid_t pid;    int stat;    if((pid=waitpid(-1,&amp;stat,WNOHANG))&gt;0)        cout&lt;&lt;"child terminated\n"&lt;&lt;endl;    return ;}Sigfunc* signal_bind(int signo,Sigfunc* func){    struct sigaction act,oact;    act.sa_handler=func;    sigemptyset(&amp;act.sa_mask);    act.sa_flags=0;    act.sa_flags|=SA_RESTART;    if(sigaction(signo,&amp;act,&amp;oact)&lt;=0)        return SIG_ERR;    return oact.sa_handler;}void str_echo(int fd){    size_t n;    char buf[4096];    cout&lt;&lt;"str_echo"&lt;&lt;endl;    while((n=read(fd,buf,4096))&gt;0)    {        write(fd,buf,strlen(buf));        memset(buf,0,sizeof(char)*4096);    }    if(n&lt;=0)        cout&lt;&lt;"str_echo:read error"&lt;&lt;endl;}intmain(int argc,char ** argv){    int listenfd,connfd;    pid_t childpid;    socklen_t cliadr_len;    struct sockaddr_in cliaddr,servaddr;    signal_bind(SIGCHLD,sig_chld);    if((listenfd=socket(AF_INET,SOCK_STREAM,0))&lt;0)    {        cout&lt;&lt;"socket error"&lt;&lt;endl;        exit(0);    }    servaddr.sin_family=AF_INET;    servaddr.sin_addr.s_addr=htonl(INADDR_ANY);    servaddr.sin_port=htons(8888);    if(bind(listenfd,(sockaddr *)&amp;servaddr,sizeof(cliaddr))&lt;0)    {        cout&lt;&lt;"bind error"&lt;&lt;endl;        exit(0);    }    if(listen(listenfd,20)&lt;0){        cout&lt;&lt;"listen error"&lt;&lt;endl;        exit(0);    }    for(;;)    {        cliadr_len=sizeof(cliaddr);        connfd=accept(listenfd,(sockaddr*)&amp;cliaddr,&amp;cliadr_len);        if(errno==EINTR)            continue;        if(connfd&lt;0)            exit(0);        if((childpid=fork())==0)        {            //child            close(listenfd);            str_echo(connfd);            exit(0);        }        close(connfd);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>client</p><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author: &gt; Mail: &gt; Created Time: 2020年01月26日 星期日 16时39分52秒 ************************************************************************/# include &lt;sys/types.h&gt;# include &lt;sys/socket.h&gt;# include &lt;netdb.h&gt;# include &lt;unistd.h&gt;# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;# include &lt;string.h&gt;# include &lt;ctype.h&gt;# include &lt;errno.h&gt;# include &lt;malloc.h&gt;# include &lt;netinet/in.h&gt;# include &lt;arpa/inet.h&gt;# include &lt;sys/ioctl.h&gt;# include &lt;stdarg.h&gt;# include &lt;fcntl.h&gt;# include &lt;fcntl.h&gt;# include&lt;iostream&gt;using namespace std;void str_cin(int sockfd){    char sendline[4096],recvline[4096];    while(1)    {        cin&gt;&gt;sendline;                write(sockfd,sendline,strlen(sendline));        if(read(sockfd,recvline,4096)&lt;=0)        {            cout&lt;&lt;"str_cli:server terminated permaturely";            exit(0);        }        cout&lt;&lt;recvline&lt;&lt;endl;        memset(recvline,0,sizeof(char)*4096);    }}intmain(int argc,char ** argv){    int sockfd;    struct sockaddr_in servaddr;    if(argc&lt;2)    {        cout&lt;&lt;"usage:tcpcli &lt;IPaddress&gt;"&lt;&lt;endl;        exit(0);    }    sockfd=socket(AF_INET,SOCK_STREAM,0);    bzero(&amp;servaddr,sizeof(servaddr));    servaddr.sin_family=AF_INET;    servaddr.sin_port=htons(8888);    inet_pton(AF_INET,argv[1],&amp;servaddr.sin_addr);    connect(sockfd,(struct sockaddr * )&amp;servaddr,sizeof(servaddr));    str_cin(sockfd);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程间通信-信号</title>
      <link href="linux-jin-cheng-jian-tong-xin-xin-hao/"/>
      <url>linux-jin-cheng-jian-tong-xin-xin-hao/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-信号"><a href="#Linux-信号" class="headerlink" title="Linux 信号"></a>Linux 信号</h1><p>类似于嵌入式中的软中断。由内核发出信号告知进程，且不进行排队。这意味着当多个相同信号同时到来的时候进程将只会执行一次信号处理函数。</p><h1 id="几个重要的信号"><a href="#几个重要的信号" class="headerlink" title="几个重要的信号"></a>几个重要的信号</h1><p>SIGPIPE 管道中止,当写入无人读取的管道时产生该信号,默认终止进程<br>SIGCHLD 子进程结束或者停止时发送<br>SIGALRM 定时器信号,以秒为单位,默认终止进程<br>SIGUSR1/SIGUSR2 自定义信号,默认终止信号<br>SIGINT  键盘输入的退出信号 ctrl+’'<br>SIGOUIT 键盘输入的退出信号 ctrl+c<br>SIGHUP  控制终端的挂起信号 ctrl+z</p><h2 id="SIGPIPE"><a href="#SIGPIPE" class="headerlink" title="SIGPIPE"></a>SIGPIPE</h2><p>网络程序必须要处理SIGPIPE信号,否则当客户端退出的时候服务器仍然向管道中发送数据,会造成crash</p><h2 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a>SIGCHLD</h2><p>处理僵尸进程</p><p>僵尸进程是已经死亡的进程,资源已经释放但是任然占用一个进程号.父进程没有处理SIGCHLD信号或者wait/waitpid()后,子进程结束后没有对子进程进行处理会导致僵尸进程</p><h1 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h1><ol><li>硬件方式: ctrl+c等</li><li>软件方式: kill api</li></ol><h1 id="安装信号"><a href="#安装信号" class="headerlink" title="安装信号"></a>安装信号</h1><h2 id="简单方式："><a href="#简单方式：" class="headerlink" title="简单方式："></a>简单方式：</h2><pre class="line-numbers language-none"><code class="language-none">signal(int sig,void (*func)(int));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="高级方式"><a href="#高级方式" class="headerlink" title="高级方式:"></a>高级方式:</h2><pre class="line-numbers language-none"><code class="language-none"> int sigaction(int sig,const struct sigaction *act,struct sigaction * oact)struct sigaction{     void (*sa_handler)(int);void (*sa_sigaction)(int ,siginfo_t *,void *);//处理函数sigset_t sa_mask; //掩码  在处理函数中对于哪个信号会进行处理,置位表示屏蔽int sa_flags; //根据SA_SIGINFO 标记选择处理函数 void (*sa_restorer)(void); //设置为null,一般不用};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在服务器程序中,如果主程序进入了一个中断调用退出后,accept 会返回EINTR错误（被中断的系统调用）,这时候我们需要设置sa_flags| = SA_RESTART标志,这个标志是自动重启被中断的系统调用,这样我们的accept 就不会返回错误.</p><p>但是对于这一类慢系统调用(accept、select)来说,最好手动重启,即error==EINTR时候重新循环,这样时为了考虑到移植性,在一些系统并非支持SA_RESTART</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="tan-xin-suan-fa/"/>
      <url>tan-xin-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>每次都是当前最优解.<br>缺点: 也许当前呃最优解并不是最后的最优解.就像人生,也许你现在放弃了一些东西以后就收获更多.</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>问题必须能够分解成子问题来解决.**子问题的最优解能够递推到最终问题的最优解.**这种子问题的最优解成为最优子结构.</p><p>贪心算法与动态规划不同在于它对每个子问题的解决方案都做出选择,不能回退.</p><p>动态规划会保存以前的运算结果,并根据以前的结果对当前进行选择,具备回退功能.</p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><h2 id="122-买卖股票"><a href="#122-买卖股票" class="headerlink" title="122 买卖股票"></a>122 买卖股票</h2><p>只要每天的股票价格比前一天的高,就可以买入前一天的股票第二天马上抛出</p><p>class Solution {<br>public:<br>    int maxProfit(vector<int>&amp; prices) {<br>        //动态规划<br>        // if(prices.size()&lt;=1)<br>        //     return 0;<br>        // int dp[2][2],x=0;<br>        // dp[0][0]=0;<br>        // dp[0][1]=-prices[0];<br>        // for(int i=1;i&lt;prices.size();i++)<br>        // {<br>        //     x=i%2;<br>        //     dp[x][0]=max(dp[!x][0],dp[!x][1]+prices[i]);<br>        //     dp[x][1]=max(dp[!x][0]-prices[i],dp[!x][1]);<br>        // }<br>        // return dp[x][0];</int></p><pre><code>    //贪心算法    int ret=0;    for(int i=1;i&lt;prices.size();i++)        if(prices[i]&gt;prices[i-1])            ret+=prices[i]-prices[i-1];    return ret;}</code></pre><p>};</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++ 对象模型 笔记 - 第四章</title>
      <link href="shen-du-tan-suo-c-dui-xiang-mo-xing-bi-ji-di-si-zhang/"/>
      <url>shen-du-tan-suo-c-dui-xiang-mo-xing-bi-ji-di-si-zhang/</url>
      
        <content type="html"><![CDATA[<h1 id="Function-语意学"><a href="#Function-语意学" class="headerlink" title="Function 语意学"></a>Function 语意学</h1><p>概述: 这一章好难,有些地方作者语焉不详的,图示和内容有些出入不知道是不是错误. 主要内容是在object中的函数存放位置,虚继承及多重继承下vptr的存取方案,inline 函数的展开以及指向member function 的指针.</p><h2 id="member的各种调用方式"><a href="#member的各种调用方式" class="headerlink" title="member的各种调用方式"></a>member的各种调用方式</h2><p><strong>C++的设计准则之一： nonstatic member function 至少必须和一般的nonmember function有相同的效率</strong></p><p>对于调用 nostatic member function 而言,例如: </p><p>编译器会进行下面几步转化过程:</p><p>1.改写函数原型</p><pre class="line-numbers language-none"><code class="language-none">//non-constPoint3d Point3d::magnitude(Point3d *const this)//constPoint3d Point3d::magnitude(const Point3d *const this)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.将每一步对nonstatic data member的存取操作改为经由this指针来存取</p><p>3.将member function重新携程一个外部函数。函数名经过名称的特殊处理,使它在程序中独一无二</p><pre class="line-numbers language-none"><code class="language-none">extern magnitude__7Point3dFv(    register Point3d *const this);// 这里的Fv的意识是返回值为void的Function <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Point3d p;Point3d *ptr=&amp;pp.magnitude();ptr-&gt;magnitude();//转化后magnitude__7Point3dFv(&amp;p);magnitude__7Point3dFv(ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="名称的特殊处理"><a href="#名称的特殊处理" class="headerlink" title="名称的特殊处理"></a>名称的特殊处理</h3><p>一般而言,member的名称前面会加上class 形成独一无二的命名。同时function需要支持可重载，则需要更广泛的处理,</p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">class Point{public:     void x__5Point(float newX);    float x__5Point();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>转换后:</p><pre class="line-numbers language-none"><code class="language-none">class Point{public:     void x__5PointFf(float newX);    float x__5PointFv();}//将参数的类型添加进去.这是cfront采用的编码方法.目前各种编译器有各种处理方案.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="虚拟成员函数"><a href="#虚拟成员函数" class="headerlink" title="虚拟成员函数"></a>虚拟成员函数</h3><pre class="line-numbers language-none"><code class="language-none">ptr-&gt;normalize();//转换后(*ptr-&gt;vptr[1](ptr)); // 1为虚函数表中的索引值 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="虚拟成员函数-重点"><a href="#虚拟成员函数-重点" class="headerlink" title="虚拟成员函数     (重点)"></a>虚拟成员函数     (重点)</h2><h3 id="单一继承"><a href="#单一继承" class="headerlink" title="单一继承"></a>单一继承</h3><p><img src="https://banthink.com/usr/uploads/2020/01/2035798177.jpg" alt="虚函数单一继承.jpg"></p><p>如上图所示,对于每一个object中都维护一个vptr,每个vptr中对应的slot就是成员函数.图中索引值为0(type_info for Point)的位置存放的是类类型,如果是虚继承的话这里存放的是在派生类中的偏移值.</p><p>一个class 只会有一个virtual table .每一个table内涵其对应的class object中所有active virtual functions函数实例的地址.这些active virtual function 包括:</p><ol><li>这一class 所定义的函数实例.覆盖基类的虚函数指针.(仍然可以调用父类的,但是此时只能显性调用)</li><li>继承自base class 的函数实例</li><li>一个纯虚函数实例</li></ol><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><pre class="line-numbers language-none"><code class="language-none">class Base1 {public:    Base1();    virtual ~Base1();    virtual void speakClearly();    virtual Base1 *clone() const;protected:    float data_Base1;}class Base2 {public:    Base2();    virtual ~Base1();    virtual void mumble();    virtual Base2 *clone() const;protected:    float data_Base2;}class Derived : public Base1, public Base2 {public:    Derived();    virtual ~Derived();    virtual Derived *clone() const;protected:    float data_Derived;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用Thunk技术解决在执行期完成”this指针调整”操作.</p><pre class="line-numbers language-none"><code class="language-none">pbase2_dtor_thunk:    this+= sizeof(base1); //用适当的offset值调整this指针    Derived::~Derived(this);  //跳转到virtual function<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在多重继承下,一个derived class 内含n-1 个额外的virtual tables,n表示其上一层base classed的个数.对于本例，会产生两个虚表：</p><ol><li>一个主要实例,与base1共享</li><li>一个次要实例,与base2有关</li></ol><p>针对每一个虚表,derived对象中都有对应的vptr.如下图所示</p><p><img src="https://banthink.com/usr/uploads/2020/01/2481564438.png" alt="20180516110739102.png"></p><p>针对每一个虚表，Derived对象中有对应的vptr,这些vptrs将在构造函数中设定初值。这一点可以说明构造函数一般不能是虚函数。</p><h3 id="虚继承下的Virtual-Function"><a href="#虚继承下的Virtual-Function" class="headerlink" title="虚继承下的Virtual Function"></a>虚继承下的Virtual Function</h3><p><img src="https://banthink.com/usr/uploads/2020/01/1377672788.png" alt="虚继承.png"></p><p>Point2d的内存布局在单一继承(上一章)中就进行了类似的讨论。对于Point3d,非常复杂。</p><p>建议：不要在virtual base class中声明nonstatic data member.</p><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><blockquote><p>以下内容摘自博客<a href="https://blog.csdn.net/qq_25467397/article/details/80333163">https://blog.csdn.net/qq_25467397/article/details/80333163</a>  幸福的起点_</p></blockquote><p>静态成员最重要的特性在于它没有this指针，以下特性来源于这个主要特性。</p><ul><li>不能够直接存取class中的nonstatic members；</li><li>不能被声明为const, volatile,virtual;</li><li>不需要经由class object才被调用，可以直接经由classname::调用。</li></ul><p>因此静态成员函数转化为一般的nonmember函数调用时，不会添加this指针，只会应用”name mangling”以及”NRV”优化。</p><p>例如：假设一个三维坐标点类Point3d，有个静态函数定义为:</p><p>int Pointe3d::object_count() { return _object_count; }</p><p>转化为：int object_count__5Point3dSFV() { return _object_count__5Point3dSFV; }</p><p>其中SFV表示static member function,拥有一个空白(void)的参数链表(argument list).</p><p>如果取一个静态成员函数的地址，获取的是其在内存中的位置，也就是其地址，地址的类型是”nonmember<br>函数指针”而非”class member function指针”。</p><p>例如：&amp;Pointe3d::object_count();</p><p>得到的类型是：int (<em>)();而不是：int (Point3d::</em>)();</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="函数效能"><a href="#函数效能" class="headerlink" title="函数效能"></a>函数效能</h3><p>对于nonmember、static member、nonstatic member函数都是转换为一样的形式，所以三者的效率完全一样。inline函数经过优化后效率有了极大地提升。</p><h3 id="指向Member-Functions的指针"><a href="#指向Member-Functions的指针" class="headerlink" title="指向Member Functions的指针"></a>指向Member Functions的指针</h3><p>(1).指向non-virtual nonstatic member functions的指针</p><p>例如：double (Point::*pmf)();//声明pmf函数指针指向Point的member function</p><p>指定其值：pmf = &amp;Point::y;//y是Point的成员函数</p><p>或者直接声明是赋值：double (Point::*pmf)() = &amp;Point::y;</p><p>假设一个Point对象origin以及一个Point指针ptr,那么可以这样调用：</p><p>(origin.*pmf)();或者(ptr-&gt;*pmf)();</p><p>编译器的转化为：(pmf)(&amp;origin);或者(pmf)(ptr);</p><p>(2).指向Virtual Member Functions的指针</p><p>对一个虚成员函数取地址，所能获得的只是一个索引值。</p><p>假设有如下Point声明：</p><pre class="line-numbers language-none"><code class="language-none">class Point {public:    virtual ~Point();    float x();    float y();    virtua float z();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>取析构函数的地址：&amp;Point::~Point();得到索引1；取&amp;Point::x()得到函数在内存中的地址；取<br>&amp;Point::z()得到索引2。若通过函数指针pmf来调用z():</p><pre class="line-numbers language-none"><code class="language-none">float (Point::*pmf)() = &amp;Point::z();Point* ptr;(ptr-&gt;*pmf)();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>内部转换为：(*ptr-&gt;vptr[(int)pmf])(ptr);实际(int)pmf就是2，还是原来的形式：(*ptr-&gt;vptr<a href="https://banthink.com/usr/uploads/2020/01/2481564438.png">2</a>)(ptr);</p><p>还有一个问题在于如何辨别这个数值是内存地址还是索引值呢？cfront2.0非正式版的策略：</p><p>(((int)pmf) &amp; ~127) ? (*pmf)(ptr) : (*ptr-&gt;vptr<a href="">(int)pmf</a>);</p><p>对于x&amp;~127=0 当x&lt;=127，这种实现技巧必须假设继承体系中的virtual functions的个数小于128.</p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>内联函数只是建议请求编译器实行，真正决定内联还是看编译器本身。如果请求被接受，编译器必须认为它可以用一个表达式合理地将这个函数扩展开来。通常编译器会计算assignments, function calls, virtual function calls等操作的次数的总和来决定是否内联。</p><p>一般处理inline function的两个阶段：</p><ul><li>分析函数定义，以决定函数的”intrinsic inline ability”(本质的inline能力)。</li><li>真正的inline函数扩展操作是在调用的那点上。</li></ul><h3 id="形式参数-Formal-Arguments"><a href="#形式参数-Formal-Arguments" class="headerlink" title="形式参数(Formal Arguments)"></a>形式参数(Formal Arguments)</h3><p>在内联函数的扩展期间，形式参数有什么变化？看如下例子：</p><pre class="line-numbers language-none"><code class="language-none">inline int min(int i, int j) { return i &lt; j ? i : j; }inline int bar() {    int minval;    int val1 = 1024;    int val2 = 2048;    /*(1)*/minval = min(val1, val2);    /*(2)*/minval = min(1024, 2048);    /*(3)*/minval = min(foo(), bar() + 1);    return minval;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标识(1)中直接参数替换：minval = val1 &lt; val2 ? val1 : val2;</p><p>标识(2)中直接拥抱常量：minval = 1024;</p><p>标识(3)中引发参数副作用，需要导入两个临时对象：</p><p>int t1,t2;minval = (t1 = foo()), (t2 = bar() + 1), t1 &lt; t2 ? t1 : t2;</p><h3 id="局部变量-Local-Variables"><a href="#局部变量-Local-Variables" class="headerlink" title="局部变量(Local Variables)"></a>局部变量(Local Variables)</h3><p>如果在inline定义中加入局部变量：</p><pre class="line-numbers language-none"><code class="language-none">inline int min(int i, int j){    int minval = i &lt; j ? i : j;    return minval;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>假设有操作：int minval = min(val1, val2);为了维护局部变量可能变成：</p><pre class="line-numbers language-none"><code class="language-none">int __min_lv_minval;int minval = (__min_lv_minval = val1 &lt; val2 ? val1 : val2),         __min_lv_minval);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>inline函数的每一个局部变量都必须放在函数调用的一个封闭的区段中，拥有独一无二的名称。<br>另外，如果扩展多次，可能会产生很多临时变量：</p><pre class="line-numbers language-none"><code class="language-none">int minval = min(val1, val2) + min(foo(), foo() + 1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可能扩展为：</p><pre class="line-numbers language-none"><code class="language-none">//为局部变量产生的临时对象int __min_lv_minval_00, __min_lv_minval_01;//为放置副作用产生的临时变量int t1, t2;int minval = (__min_lv_minval_00 = val1 &lt; val2 ? val1 : val2),         __min_lv_minval_00)        +        ((__min_lv_minval_01 = (t1 = foo()), (t2 = bar() + 1),         t1 &lt; t2 ? t1 : t2), __min_lv_minval_00);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此如果一个inline函数参数带有副作用或者进行多重调用或者函数内部有多个局部变量，这样都会产生临时对象，产生大量的扩展码，使得程序大小暴增。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++ 对象模型 笔记 - 第三章</title>
      <link href="shen-du-tan-suo-c-dui-xiang-mo-xing-bi-ji-di-san-zhang/"/>
      <url>shen-du-tan-suo-c-dui-xiang-mo-xing-bi-ji-di-san-zhang/</url>
      
        <content type="html"><![CDATA[<h1 id="Data语意学"><a href="#Data语意学" class="headerlink" title="Data语意学"></a>Data语意学</h1><p>概述 ： 这部分主要内容是在将Class Object中数据成员在内存中的分布,深入的讲解了在多重继承、虚继承等情况下编译器对于Class模型的构建。同时也对成员对象的使用效率方面做了深入的研究分析.</p><h2 id="Class-Object内存布局"><a href="#Class-Object内存布局" class="headerlink" title="Class Object内存布局"></a>Class Object内存布局</h2><p>对于class X{}这样一个对象而言,sizeof(X)后获得的大小为1,它里面包含有一个隐藏的1byte大小，这样可以使得两个object可以在内存中配置独一无二的地址.</p><p>class A：public X{};</p><p>class B: public X{};</p><p>class C: public A,public B {};</p><p>sizeof运行结果:</p><p><img src="https://banthink.com/usr/uploads/2020/01/3246047397.jpg" alt="第三章  普通继承.jpg"></p><p>class A：virtual public X{};</p><p>class B: virtual public X{};</p><p>class C: public A,public B {};</p><p>sizeof运行结果:<br><img src="https://banthink.com/usr/uploads/2020/01/1293943827.jpg" alt="对象模型 第三章.jpg"></p><p>对比上述两种继承方式中在内存中的大小分布.首先第一种普通继承方式下仅仅是继承了基类中隐藏的byte.</p><p>而第二种虚继承中,A、B、C三者的大小受到三个因素的影响:</p><p>1、 语言本身所造成的额外负担(重点)</p><p>在编译器中,由于vitrual base class在多重继承中会折叠成为一个由最后派生的class 维护的单一子类,同时还需要支持能够在base 指针和 derived 指针之间转换的多态操作.</p><p>所以在每一个virtual 继承而来的derived class object 中安插一些指针,每个指针指向一个virtual base class .通过指针的间接操作来完成对virtual base class 共享操作.</p><p>但是这样会出现两个问题: </p><ol><li>当virtual继承多了这些指针也增多了</li><li>随着虚拟继承串链的增长,间接存取的深度也增加了.</li></ol><p>第一个问题:  </p><p>A.引入虚继承基类表(微软)</p><p>B. 将虚继承基类的偏移量存放在虚函数表的首部.</p><p>第二个问题:通过拷贝操作取得所有嵌套指针来对指针的数量进行压缩</p><p>2、 编译器对特殊情况的优化处理</p><p>3、 Alignment的处理</p><p>在大部分的机器上,聚合的结构体大小都会收到aligment的限制,使他们能够在更有效率的在内存中被存取.</p><p>另一个作用就是图中所说<br><img src="https://banthink.com/usr/uploads/2020/01/1315372641.jpg" alt="padding.jpg"></p><p><strong>了解了上述三个因素后我们就能够对A.B.C三个类的大小做出一个很好的理解了</strong></p><p><img src="https://banthink.com/usr/uploads/2020/01/2682187733.jpg" alt="虚基类.jpg"></p><h2 id="vptr指针的存放位置"><a href="#vptr指针的存放位置" class="headerlink" title="vptr指针的存放位置"></a>vptr指针的存放位置</h2><p>C++ 标准中,vptr指针可以存放在C++ 模型中的任意位置,但是一般来说编译器都要么存放在首部,要么就是尾部。</p><p>首部:  对于”在多重继承之下，通过指向class members 调用virtual function “ 会带来一些帮助,否则将会从class object起始点开始亮起.</p><p>尾端: 提供对C语言的兼容性. </p><h2 id="指向data-members-的指针"><a href="#指向data-members-的指针" class="headerlink" title="指向data members 的指针"></a>指向data members 的指针</h2><p>对于:</p><p>class Point3d{<br>    public :<br>        virtual ~Point3d();<br>            ….<br>       public:<br>            static Point3d origin;<br>            float x,y,z;<br>}</p><p>取某个坐标成员的地址:</p><p> &amp;Point3d::z;</p><p>上述操作将得到z坐标在class object 中偏移位置.最低限度是其x+y的大小总和.</p><p>注意 ： 为了区分一个没有指向任何data member 的指针和一个指向第一个data member ,每一个真正的member offset的值都被加上1 </p><p>使用:</p><p>float Point3d::*ax=&amp;Point3d::x;<br>Point3d pA;<br>pA.*ax=2;   //这么做效率较低</p><p>等价于<br>pA.ax=2;</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络---传输层 TCP</title>
      <link href="wang-luo-chuan-shu-ceng-tcp/"/>
      <url>wang-luo-chuan-shu-ceng-tcp/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p><img src="https://banthink.com/usr/uploads/2020/01/3237449440.jpg" alt="TCP报文.jpg"></p><p>TCP，控制传输协议，和UDP的差别很大，它充分实现了数据传输时的各种控制功能：</p><p>针对发送端发出的数据包的确认应答信号ACK</p><p>针对数据包丢失或者出现定时器超时的重传机制</p><p>针对数据包到达接收端主机顺序乱掉的顺序控制</p><p>针对高效传输数据包的滑动窗口控制</p><p>针对避免网络拥堵时候的流量控制</p><p>针对刚开始启动的时候避免一下子发送大量数据包而导致网络瘫痪的慢启动算法和拥塞控制。</p><p>言归正传：TCP通过序列号、检验和、确认应答信号、重发控制、连接管理、窗口控制、流量控制、拥塞控制实现可靠性。</p><h2 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h2><ol><li>MSS 选项 ：发送SYN的TCP一段使用本选项通告对端它的最大分解大小。</li><li>窗口规模选项 : 就是TCP连接任何一端能够通告对端的窗口大小</li><li>时间戳选项: 防止失而复现的分组可能造成的数据损坏</li></ol><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口解决的是流量控制的的问题，就是如果接收端和发送端对数据包的处理速度不同，如何让双方达成一致。接收端的缓存传输数据给应用层，但这个过程不一定是即时的，如果发送速度太快，会出现接收端数据overflow，流量控制解决的是这个问题。</p><p><a href="https://blog.csdn.net/wdscq1234/article/details/52444277">https://blog.csdn.net/wdscq1234/article/details/52444277</a><br>可以看这里，其实很简单的东西,主要要注意当滑动窗口中的数据等待超时了发生的重传机制</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p><a href="https://blog.csdn.net/qq_41431406/article/details/97926927">https://blog.csdn.net/qq_41431406/article/details/97926927</a></p><h2 id="连接和释放"><a href="#连接和释放" class="headerlink" title="连接和释放"></a>连接和释放</h2><p><img src="https://banthink.com/usr/uploads/2020/01/584741552.jpg" alt="TCP状态变迁图"></p><p><img src="https://banthink.com/usr/uploads/2020/01/2455100635.jpg" alt="tcp状态列表图.jpg"></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><a href="https://blog.csdn.net/cmm0401/article/details/77865479">https://blog.csdn.net/cmm0401/article/details/77865479</a></p><h3 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h3><p><a href="https://blog.csdn.net/cmm0401/article/details/77865479">https://blog.csdn.net/cmm0401/article/details/77865479</a></p><h4 id="为什么建链接要3次握手，断链接需要4次挥手"><a href="#为什么建链接要3次握手，断链接需要4次挥手" class="headerlink" title="为什么建链接要3次握手，断链接需要4次挥手"></a>为什么建链接要3次握手，断链接需要4次挥手</h4><p>对于建链接的3次握手，主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）<br>因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。</p><h4 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h4><p>1.time_wait状态如何产生？</p><p>从上面的两张图可以看到，当客户端发送完最后一个ACK后会转换为TIME_WAIT状态.客户端会在这个状态停留2MSL(两倍的最长分解生命期)时间.</p><p>2.time_wait状态产生的原因</p><p>(1)可靠的实现TCP全双工连接的终止</p><p>我们可以假设，当客户端最后发送的ACK在网络中丢失,由于TCP协议的重传机制,执行被动关闭的一方(服务端)将会重新发送FIN,在FIN到达之前,客户端必须维护状态信息,以允许他重新发送最终那个ACK.假如客户端发送完ACK后就完成终止释放了,那么它将响应一个RST分节,该分节将被服务器解释成一个错误.如果TCP打算执行所有必要的工作以彻底终止某个链接上两个方向的数据流,即全双工关闭,那么它必须正确处理链接终止序列四个字节中任何一个字节丢失的情况.</p><p>(2)为使旧的数据包在网络因过期而消失</p><p>这个原因网上有些解释不是很清楚,我参考了UNIX:网络编程1卷后后的理解：我们可以假设这个状态不存在,然后在服务器和客户端之间有一个TCP连接，我们关闭连接后,在相同的端口上建立同样的连接.由于端口和IP都和之前的一样,TCP协议无法辨别.这时候我们假设客户端刚才关闭连接的时候最后发送的ACK超时了,在我们建立了新连接的时候又出现了(这个TCP字节的分组我们称为迷途的重复分组),那么TCP将会误解为这个ACK是新连接中客户端传来的最终引发错误!</p><p>为了避免这一点，TCP将不给那些处于TIME_WAIT状态的连接发起新的连接,同时既然TIME_WAIT状态持续时间是MSL的两倍，那么足以让两个方向上的分组最多存活MSL秒就丢弃.</p><p>4.time_wait状态如何避免</p><p>首先服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。</p><h1 id="SCTP"><a href="#SCTP" class="headerlink" title="SCTP"></a>SCTP</h1><p>流控制传输协议。SCTP在客户和服务器之间提供关联，并且像TCP那样给应用提供可靠性、排序、流量控制以及全双工的数据传送。</p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络</title>
      <link href="wang-luo/"/>
      <url>wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><h2 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h2><pre><code>考虑一个16位整数，它由两个字节组成。 内存中存储这两个字节有两种方法：一种是将低序字节存储在起始地址，称为小端字节序,另一种是将高序字节存储在起始地址，称为大端字节序。两种格式都有系统使用。</code></pre><p>　　网络上传输的数据都是字节流,对于一个多字节数值,在进行网络传输的时候,先传递哪个字节?也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题;<br>　　UDP/TCP/IP协议规定:把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节;而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的;<br>　　所以说,网络字节序是大端字节序;<br>　　在实际中，当在两个存储方式不同的主机上传输时，需要借助字节序转换函数。</p><p> 在Unix网络编程中，需要用到下列这四个函数进行字节序的转换</p><h1 id="include-lt-netinet-in-h-gt"><a href="#include-lt-netinet-in-h-gt" class="headerlink" title="include <netinet/in.h>"></a>include &lt;netinet/in.h&gt;</h1><p>uint16_t htons(uint16_t hostbitvalue);<br>uint32_6 htonl(uint32_t hostbitvalue);<br>返回网络字节序的值</p><p>uint16_t ntohs(uint16_t hostbitvalue);<br>uint32_t ntohl(uint16_t hostbitvalue);<br>返回主机字节序的值</p><p>OSI七层模型从低到高分别是:物理层,数据链路层,网络层,传输层,会话层,表示层，应用层</p><p>TCP/IP模型则是:数据链路层,网络层，传输层,应用层</p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自己整理的经验 方向</title>
      <link href="zi-ji-zheng-li-de-jing-yan-fang-xiang/"/>
      <url>zi-ji-zheng-li-de-jing-yan-fang-xiang/</url>
      
        <content type="html"><![CDATA[<p>鹅厂是cpp的主战场，而以cpp为背景的工程师大都对os，network这块要求特别高，不像是Java这种偏重业务层的语言，之前面试Java的公司侧重还是在数据结构、网络、框架、数据库和分布式。所以OS这块吃的亏比较大。<br>面试分为以下几大块<br>• C/C++<br>• 网络<br>• 操作系统<br>• Linux系统<br>• MongoDB<br>• Redis<br>• mysql<br>• 算法<br>• 设计模式<br>• 分布式架构<br>• 系统设计<br>• 等等，未完待续</p><h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><ol><li>const</li><li>多态</li><li>什么类不能被继承（这个题目非常经典，我当时答出了private但是他说不好，我就没想到final我以为那个是java的）<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2></li><li>网络的字节序</li><li>网络知识 tcp三次握手 各种细节 timewait状态</li><li>tcp 与 udp  区别 概念 适用范围</li><li>TCP四次挥手讲一下过程，最后一次ack如果客户端没收到怎么办，为什么挥手不能只有三次，为什么time_wait。</li><li>对于socket编程，accept方法是干什么的，在三次握手中属于第几次，可以猜一下，为什么这么觉得。</li><li>tcp怎么保证有序传输的，讲下tcp的快速重传和拥塞机制，知不知道time_wait状态，这个状态出现在什么地方，有什么用？</li><li>知道udp是不可靠的传输，如果你来设计一个基于udp差不多可靠的算法，怎么设计？</li><li>http与https有啥区别？说下https解决了什么问题，怎么解决的？说下https的握手过程。</li><li>tcp 粘包半包问题怎么处理？</li><li>keepalive 是什么东东？如何使用？</li><li>列举你所知道的tcp选项，并说明其作用。</li><li>socket什么情况下可读？</li><li>nginx的epoll模型的介绍以及io多路复用模型</li><li>SYN Flood攻击</li><li>流量控制，拥塞控制</li><li>TCP和UDP区别，TCP如何保证可靠性，对方是否存活(心跳检测)</li><li>tcpdump抓包，如何分析数据包</li><li>tcp如何设定超时时间</li><li>基于socket网络编程和tcp/ip协议栈，讲讲从客户端send()开始，到服务端recv()结束的过程，越细越好</li><li>http报文格式</li><li>http1.1与http1.0区别，http2.0特性 </li><li>http3了解吗</li><li>http1.1长连接时，发送一个请求阻塞了，返回什么状态码？</li><li>udp调用connect有什么作用？<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2></li><li>进程和线程-分别的概念 区别 适用范围 它们分别的通讯方式 不同通讯方式的区别优缺点</li><li>僵尸进程</li><li>死锁是怎么产生的</li><li>CPU的执行方式</li><li>代码中遇到进程阻塞，进程僵死，内存泄漏等情况怎么排查。</li><li>有没有了解过协程？说下协程和线程的区别？</li><li>堆是线程共有还是私有，堆是进程共有还是私有，栈呢</li><li>了解过协程吗（我：携程？？？不了解呜呜呜）</li><li>共享内存的使用实现原理（必考必问，然后共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大限制是多少？）</li><li>c++进程内存空间分布（注意各部分的内存地址谁高谁低，注意栈从高道低分配，堆从低到高分配）</li><li>ELF是什么？其大小与程序中全局变量的是否初始化有什么关系（注意.bss段）</li><li>使用过哪些进程间通讯机制，并详细说明（重点）</li><li>多线程和多进程的区别（重点 面试官最最关心的一个问题，必须从cpu调度，上下文切换，数据共享，多核cup利用率，资源占用，等等各方面回答，然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催）</li><li>信号：列出常见的信号，信号怎么处理？</li><li>i++是否原子操作？并解释为什么？？？？？？？</li><li>说出你所知道的各类linux系统的各类同步机制（重点），什么是死锁？如何避免死锁（每个技术面试官必问）</li><li>列举说明linux系统的各类异步机制</li><li>exit() _exit()的区别？</li><li>如何实现守护进程？</li><li>linux的内存管理机制是什么？</li><li>linux的任务调度机制是什么？</li><li>标准库函数和系统调用的区别？</li><li>补充一个坑爹坑爹坑爹坑爹的问题：系统如何将一个信号通知到进程？（这一题哥没有答出来）<h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2></li><li>linux的各种命令 给你场景让你解决</li><li>Linux了解么，查看进程状态ps，查看cpu状态 top。查看占用端口的进程号netstat grep</li><li>Linux的cpu 100怎么排查，top jstack，日志，gui工具</li><li>Linux操作系统了解么</li><li>怎么查看CPU负载，怎么查看一个客户下有多少进程</li><li>Linux内核是怎么实现定时器的</li><li>gdb怎么查看某个线程</li><li>core dump有没有遇到过，gdb怎么调试</li><li>linux如何设置core文件生成</li><li>linux如何设置开机自启动</li><li>linux用过哪些命令、工具</li><li>用过哪些工具检测程序性能，如何定位性能瓶颈的地方</li><li>netstat tcpdump ipcs ipcrm （如果这四个命令没听说过或者不能熟练使用，基本上可以回家，通过的概率较小 ^_^ ，这四个命令的熟练掌握程度基本上能体现面试者实际开发和调试程序的经验)</li><li>cpu 内存 硬盘 等等与系统性能调试相关的命令必须熟练掌握，设置修改权限 tcp网络状态查看 各进程状态 抓包相关等相关命令 必须熟练掌握</li><li>awk sed需掌握</li><li>gdb调试相关的经验，会被问到<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2></li><li>关于大数据存储的（mongodb hadoop）各种原理 mongodb又问的深入很多<br>Redis</li><li>Redis内存数据库的内存指的是共享内存么</li><li>Redis的持久化方式</li><li>Redis和MySQL有什么区别，用于什么场景。</li><li>redis有没有用过，常用的数据结构以及在业务中使用的场景，redis的hash怎么实现的</li><li>问了下缓存更新的模式，以及会出现的问题和应对思路？</li><li>redis的sentinel上投票选举的问题 raft算法</li><li>redis单线程结构有什么优势？有什么问题？  主要优势单线程，避免线程切换产生静态消耗，缺点是容易阻塞，虽然redis使用io复用epoll和输入缓冲区把命令按照队列先进先出输入等等</li><li>你觉得针对redis这些缺点那些命令在redis上不可使用？ 比如keys、hgetall等等这些命令 建议用scan等等 这方面阐述</li><li>你觉得为什么项目中没有用mysql而用了es，redis在这里到底起到了什么作用？因为架构上这里理解不清楚，最后回答自己都觉得有漏洞了</li><li>你觉得redis什么算有用？ 有用？ 是说存进去了还是说命中缓存？最后把缓存命中率是什么说了一遍</li><li>你们这边redis集群是怎么样子的</li><li>平常redis用的多的数据结构是什么，跳表实现，怎么维护索引，当时我说是一个简单的二分，手写二分算法，并且时间复杂度是怎么计算出来的  （2的k次方等于n  k等于logn）<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2></li><li>你们后端用什么数据库做持久化的？有没有用到分库分表，怎么做的？</li><li>索引的常见实现方式有哪些，有哪些区别?MySQL的存储引擎有哪些，有哪些区别？InnoDB使用的是什么方式实现索引，怎么实现的？说下聚簇索引和非聚簇索引的区别?</li><li>mysql查询优化</li><li>MySQL的索引，B+树性质。</li><li>B+树和B树，联合索引等原理</li><li>mysql的悲观锁和乐观锁区别和应用，ABA问题的解决</li><li>项目性能瓶颈在哪，数据库表怎么设计</li><li>假设项目的性能瓶颈出现在写数据库上，应该怎么解决峰值时写速度慢的问题</li><li>假设数据库需要保存一年的数据，每天一百万条数据，一张表最多存一千万条数据，应该怎么设计表</li><li>数据库自增索引。100台服务器，每台服务器有若干个用户，用户有id，同时会有新用户加入。实现id自增，统计用户个数？不能重复，好像是这样的。</li><li>mysql，会考sql语言，服务器数据库大规模数据怎么设计，db各种性能指标<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2></li><li>堆栈</li><li>有序数组排序，二分，复杂度</li><li>常见排序算法，说下快排过程，时间复杂度</li><li>有N个节点的满二叉树的高度。1+logN</li><li>如何实现关键字输入提示，使用字典树，复杂度多少，有没有其他方案，答哈希，如果是中文呢，分词后建立字典树？</li><li>hashmap的实现讲一下吧，讲的很详细了。讲一下红黑树的结构，查询性能等。</li><li>快排的时间复杂度，冒泡时间复杂度，快排是否稳定，快排的过程</li><li>100w个数，怎么找到前1000个最大的，堆排序，怎么构造，怎么调整，时间复杂度。</li><li>一个矩阵，从左上角到右下角，每个位置有一个权值。可以上下左右走，到达右下角的路径权值最小怎么走。</li><li>四辆小车，每辆车加满油可以走一公里，问怎么能让一辆小车走最远。说了好几种方案，面试官引导我优化了一下，但是还是不满意，最后他说跳过。</li><li>MySQL的索引，B+树性质。</li><li>十亿和数找到前100个最大的，堆排序，怎么实现，怎么调整。</li><li>布隆过滤器</li><li>hash表解决冲突的方法</li><li>跳表插入删除过程</li><li>让你实现一个哈希表，怎么做（当时按照Redis中哈希表的实现原理回答）<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2></li><li>对于单例模式，有什么使用场景了，讲了全局id生成器，他问我分布式id生成器怎么实现，说了zk，问我zk了解原理不，讲了zab，然后就没问啦。</li><li>除了单例模式，知道适配器模式怎么实现么，有什么用<br>分布式架构</li><li>CAP BASE理论</li><li>看你项目里面用了etcd，讲解下etcd干什么用的，怎么保证高可用和一致性？</li><li>既然你提到了raft算法，讲下raft算法的基本流程？raft算法里面如果出现脑裂怎么处理？有没有了解过paxos和zookeeper的zab算法，他们之前有啥区别？</li><li>rpc有没有了解<h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2></li><li>朋友之间的点对点关系用图维护，怎么判断两人是否是朋友，并查集，时间复杂度，过程。</li><li>10g文件，只有2g内存，怎么查找文件中指定的字符串出现位置。</li><li>Linux大文件怎么查某一行的内容。</li><li>秒杀系统的架构设计</li><li>十亿个数的集合和10w个数的集合，如何求它们的交集。</li><li>回到网络，刚才你说到直播场景，知道直播的架构怎么设计么，要点是什么，说了几个不太对，他说要避免广播风暴，答不会。</li><li>针对自己最熟悉的项目，画出项目的架构图，主要的数据表结构，项目中使用到的技术点，项目的总峰值qps，时延，以及有没有分析过时延出现的耗时分别出现在什么地方，项目有啥改进的地方没有？</li><li>如果请求出现问题没有响应，如何定位问题，说下思路？</li><li>除了公司项目之外，业务有没有研究过知名项目或做出过贡献？</li><li>go程和线程有什么区别？ 答：1 起一个go程大概只需要4kb的内存，起一个Java线程需要1.5MB的内存；go程的调度在用户态非常轻量，Java线程的切换成本比较高。接着问为啥成本比较高？因为Java线程的调度需要在用户态和内核态切换所以成本高？为啥在用户态和内核态之间切换调度成本比较高？简单说了下内核态和用户态的定义。接着问，还是没有明白为啥成本高？心里瞬间崩溃，没完没了了呀，OS这块依旧是痛呀，支支吾吾半天放弃了。</li><li>服务器CPU 100%怎么定位？可能是由于平时定位业务问题的思维定势，加之处于蒙蔽状态，随口就是：先查看监控面板看有无突发流量异常，接着查看业务日志是否有异常，针对CPU100%那个时间段，取一个典型业务流程的日志查看。最后才提到使用top命令来监控看是哪个进程占用到100%。果然阵脚大乱，张口就来，捂脸。。。  本来正确的思路应该是先用top定位出问题的进程，再用top定位到出问题的线程，再打印线程堆栈查看运行情况，这个流程换平时肯定能答出来，但是，但是没有但是。还是得好好总结。</li><li>最后问了一个系统设计题目（朋友圈的设计），白板上面画出系统的架构图，主要的表结构和讲解主要的业务流程，如果用户变多流量变大，架构将怎么扩展，怎样应对？ 这个答的也有点乱，直接上来自顾自的用了一个通用的架构，感觉毫无亮点。后面反思应该先定位业务的特点，这个业务明显是读多写少，然后和面试官沟通一期刚开始的方案的用户量，性能要求，单机目标qps是什么等等？在明确系统的特点和约束之后再来设计，而不是一开始就是用典型互联网的那种通用架构自顾自己搞自己的方案。</li><li>设计一个限流的算法</li><li>定时器除了小根堆，还可以怎么做</li><li>项目性能瓶颈在哪，数据库表怎么设计</li><li>.在高并发的生产环境中（非调试场景下），如果出现数据包的丢失，如何定位问题</li><li>补充一个最最重要，最最坑爹，最最有难度的一个题目：一个每秒百万级访问量的互联网服务器，每个访问都有数据计算和I/O操作，如果让你设计，你怎么设计？<h2 id="道友总结"><a href="#道友总结" class="headerlink" title="道友总结"></a>道友总结</h2></li><li>tcp/udp，http和https还有网络这块（各种网络模型，已经select，poll和epoll）一定要非常熟悉</li><li> 一定要有拿的出手的项目经验，而且要能够讲清楚，讲清楚项目中取舍，设计模型和数据表  </li><li>分布式要非常熟悉  </li><li>常见问题定位一定要有思路  </li><li>操作系统，还是操作系统，重要的事情说三遍  </li><li>系统设计，思路，思路，思路，一定要思路清晰，一定要总结下系统设计的流程  </li><li>一点很重要的心得，平时blog和专栏看的再多，如果没有自己的思考不过是过眼云烟，根本不会成为自己的东西，就像内核态和用户态，平常也看过，但是没细想，突然要自己说，还真说不出来，这就很尴尬了。勿以浮沙筑高台，基础这种东西还是需要时间去慢慢打牢，多去思考和总结。<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2></li><li>腾讯后端面经<br>C/C++Linux高级开发路线<br>对标腾讯C++后端开发</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构总览</title>
      <link href="shu-ju-jie-gou-zong-lan/"/>
      <url>shu-ju-jie-gou-zong-lan/</url>
      
        <content type="html"><![CDATA[<p><img src="https://banthink.com/usr/uploads/2020/01/2075999078.jpg" alt="数据结构总览.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++ 对象模型 笔记 - 第一章</title>
      <link href="shen-du-tan-suo-c-dui-xiang-mo-xing-bi-ji-di-yi-zhang/"/>
      <url>shen-du-tan-suo-c-dui-xiang-mo-xing-bi-ji-di-yi-zhang/</url>
      
        <content type="html"><![CDATA[<h1 id="C-对象模型的演变"><a href="#C-对象模型的演变" class="headerlink" title="C++对象模型的演变"></a>C++对象模型的演变</h1><h2 id="简单对象模型"><a href="#简单对象模型" class="headerlink" title="简单对象模型"></a>简单对象模型</h2><p>一个object是一系列的slots,每一个slot指向一个members.Members按其声明顺序,各被指定一个slot</p><h2 id="表格驱动对象模型"><a href="#表格驱动对象模型" class="headerlink" title="表格驱动对象模型"></a>表格驱动对象模型</h2><p>将类的成员和函数抽出来分为两个表,class object中存放这指向两个表的指针</p><h2 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h2><ol><li>非静态成员存放在class object 中,函数和静态成员存放在class object 之外</li><li>virtual function 由class object中安插的vptr(指向vtbl——虚函数表)支持.每一个class 的构造、拷贝和析构都自动完成对vptr的设置、重置.</li></ol><p><img src="https://banthink.com/usr/uploads/2020/01/4059981034.jpg" alt="C++ 对象模型.jpg"></p><h1 id="struct-和-class-的差异"><a href="#struct-和-class-的差异" class="headerlink" title="struct 和 class 的差异"></a>struct 和 class 的差异</h1><p>在C++ 领域中两者在用法上没有太大区别,但是既然已经迁移到了C++ 领域,使用面向对象的方式思考就最好放弃使用struct 转而使用class 在思想层面更有觉悟一点…23333</p><p>但是struct 在C++ 中有一个合理用途,当你要传递”一个复杂的class object”的全部或部分到某个C函数去时,struct声明可以将数据封装起来，并保证用于与C兼容的空间布局.然而这项保证只有在组合的情况下才存在.如果是继承的话由于编译器会有些策略改变class object在内存中的布局 ,编译器会决定是否应该有二外的data members 被安插到base struct subobject之中.</p><h1 id="三种程序设计范式"><a href="#三种程序设计范式" class="headerlink" title="三种程序设计范式"></a>三种程序设计范式</h1><ol><li>程序模型 : like C</li><li>抽象数据类型模型(ADT): 所谓的“抽象”是和一组表达式一起提供的,那时其运算定义任隐而未明</li><li>面相对象模型: 在此模型中有一些彼此相关的类型,通过一个抽象的base class 被封装起来.</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希表Hash  代码尚未完全实现</title>
      <link href="ha-xi-biao-hash-dai-ma-shang-wei-wan-quan-shi-xian/"/>
      <url>ha-xi-biao-hash-dai-ma-shang-wei-wan-quan-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="wiki定义"><a href="#wiki定义" class="headerlink" title="wiki定义"></a>wiki定义</h1><blockquote><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p></blockquote><blockquote><p>一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名x到首字母F(x)的一个函数关系），在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母”是这个例子中散列函数的函数法则F()，存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。</p></blockquote><blockquote><p>若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。</p></blockquote><blockquote><p>对不同的关键字可能得到同一散列地址，即k1 != k2，而f(k1)=f(k2)，这种现象称为冲突（英语：Collision）。</p></blockquote><blockquote><p>具有相同函数值的关键字对该散列函数来说称做同义词。</p></blockquote><blockquote><p>综上所述，根据散列函数f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。</p></blockquote><blockquote><p>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</p></blockquote><p>哈希函数  f(x)</p><p>“键” 转换为 “索引”<br>f(ch)=ch-‘a’<br>一个班的学生学号 :1 - 30<br>身份证号: 1101081985121666666<br>字符串<br>浮点数<br>日期<br>等等~~</p><pre><code> 很难保证每一个"键"通过哈希函数的转换对应不同的"索引"               ⬇产生            哈希冲突               ⬇            解决哈希冲突               ⬇           在哈希表上的操作</code></pre><p>哈希表充分体现了算法设计领域的经典思想:空间换时间.</p><p>假设 身份证 110108198512166666<br>如果我们有9999999999999999的空间，就可以用O(1)的时间操作<br>如果有1 的空间，就需要O(n)的时间操作</p><p>哈希表就是时间和空间之间的平衡</p><h1 id="哈希函数的设计"><a href="#哈希函数的设计" class="headerlink" title="哈希函数的设计"></a>哈希函数的设计</h1><p>所谓的设计，就是将我们所关心的键通过函数转换存储在数组的索引中.</p><p>“键”通过哈希函数得到的“索引”分布越均匀越好</p><h2 id="通用的哈希函数"><a href="#通用的哈希函数" class="headerlink" title="通用的哈希函数"></a>通用的哈希函数</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>小范围正整数直接使用作为索引</p><p>小范围负整数进行偏移  例 -100<del>100  -&gt;  0</del>200</p><p>大整数<br>例如: 身份证号<br>通常做法: 取模 ,比如取后四位,等同于mod 10000<br>取后六位: 分布不均匀,因为日期最大只到31<br>一个简答的解决方法:模一个素数<br><a href="http://planetmath.org/goodhashtableprimes">http://planetmath.org/goodhashtableprimes</a></p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>在计算机都是32位或者64位的二进制表示,只不过计算机解析成了浮点数</p><h3 id="字符串：转换成整型处理"><a href="#字符串：转换成整型处理" class="headerlink" title="字符串：转换成整型处理"></a>字符串：转换成整型处理</h3><p>166 = 1 * 10^2 + 6*10^1 + 6 * 10^0</p><p>code = c <em>26</em>3 + o * 26^2 + d * 26^1 + e * 26^0</p><p>code = c <em>B</em>3 + o * B^2 + d * B^1 + e * B^0</p><p>hash(code)= (c <em>B</em>3 + o * B^2 + d * B^1 + e * B^0) %M</p><p>hash(code)= ((((c *B) + o) * B + d) * B + e) %M</p><p>hash(code)= ((((c  %M *B) + o) %M * B + d)  %M * B + e)  %M  //避免溢出</p><p>int hash=0;<br>for(int i=0;i&lt;s.length();i++)<br>{<br>      hash=(hash*B + s.at(i))% ‘M’;</p><p>}</p><h3 id="复合类型-转为整型处理"><a href="#复合类型-转为整型处理" class="headerlink" title="复合类型  转为整型处理"></a>复合类型  转为整型处理</h3><p>hash(code)= ((((c  %M *B) + o) %M * B + d)  %M * B + e)  %M  //避免溢出</p><p>Dtae:year,month,day</p><p>hash(data)= ((((data.year  %M *B) + data.month) %M * B + data.day)  %M  //避免溢出</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol><li>一致性: 吐过a==b 则hash(a)== hash(b)</li><li>高效性: 计算高效简便</li><li>均匀性: 哈希值均匀分布</li></ol><h2 id="哈希冲突的处理"><a href="#哈希冲突的处理" class="headerlink" title="哈希冲突的处理"></a>哈希冲突的处理</h2><h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p><img src="https://banthink.com/usr/uploads/2020/01/2670161882.jpg" alt="链路法.jpg"></p><h3 id="更多哈希冲突的处理方案"><a href="#更多哈希冲突的处理方案" class="headerlink" title="更多哈希冲突的处理方案"></a>更多哈希冲突的处理方案</h3><p>开放地址法<br><img src="https://banthink.com/usr/uploads/2020/01/4172706331.jpg" alt="开放地址法.jpg"></p><p>再哈希法</p><p>把关键字用不同的哈希函数再做一遍哈希法，</p><h2 id="哈希表的动态空间处理"><a href="#哈希表的动态空间处理" class="headerlink" title="哈希表的动态空间处理"></a>哈希表的动态空间处理</h2><p>平均每个地址承载的元素多过一定程度,即扩容<br>N/M &gt;= upperTol</p><p>平均每个地址承载的元素少过一定程度,即缩容<br>N/M &lt; lowerTol</p><h3 id="添加动态空间后的复杂度分析"><a href="#添加动态空间后的复杂度分析" class="headerlink" title="添加动态空间后的复杂度分析"></a>添加动态空间后的复杂度分析</h3><p>对于哈希表来说,元素数从N增加到upperTol * N ,地址增倍.</p><p>平均复杂度O(1)</p><p>每个操作都在O(lowerTol)~ O(upperTol)  –&gt; O(1)</p><p>缩容同理.</p><h3 id="更复杂的动态空间处理方法"><a href="#更复杂的动态空间处理方法" class="headerlink" title="更复杂的动态空间处理方法"></a>更复杂的动态空间处理方法</h3><p>原本扩容M -&gt; 2<em>M ,扩容 2</em>M 不是素数将会导致哈希冲突增多且哈希值分布不够均匀.</p><p>解决方案: 建立一个扩容空间数组存储素数表<br><a href="http://planetmath.org/goodhashtableprimes">http://planetmath.org/goodhashtableprimes</a></p><h1 id="哈希表-amp-平衡树"><a href="#哈希表-amp-平衡树" class="headerlink" title="哈希表&amp;平衡树"></a>哈希表&amp;平衡树</h1><p>均摊复杂度</p><p>哈希表:O(1)</p><p>平衡树:O(log n)</p><p>这么来看,平衡树存在的意义在哪里? 事实上,平衡树是维护的是内部数据的有序性,所以牺牲了一部分性能在这上面. 哈希表中存储的内容都是无序的. 所以在前面的平衡树的结构中,所有的key都需要是可比较的,而在哈希表中的key是不需要的。所以当哈希表中底层实现用到了平衡树,则需要Key都是可比较的,否则会出BUG。</p><h1 id="基于AVL的Hash代码实现"><a href="#基于AVL的Hash代码实现" class="headerlink" title="基于AVL的Hash代码实现"></a>基于AVL的Hash代码实现</h1><pre class="line-numbers language-none"><code class="language-none"># pragma once# include "AVL.hpp"# include &lt;vector&gt;using namespace std;template &lt;class K,class V&gt;class HashTable{private:const  static int upperTol = 10;const static int lowerTol = 2;const static int initCapacity = 7;public:HashTable(int M=97){this-&gt;M = M;size = 0;hashtable = new vector&lt;AVL&lt;K, V&gt;*&gt;(M);for (int i = 0; i &lt; M; i++)hashtable[i] = new AVL&lt;K,V&gt;();}virtual static int hashCode(K key){//传入key值计算出hash值  }inline int Size() { return size;}void add(K key, V value){AVL&lt;K,V&gt;* map = hashtable[hash(key)];if (!map-&gt;contains(key)){map-&gt;add(key, value);size++;if (size &gt;= upperTol * M)resize(2 * M);}}void remove(K key) {AVL&lt;K, V&gt;* map = hashtable[hash(key)];if (!map-&gt;contains(key)) {ret = map.remove(key);size--;if (size &lt;= lowerTol * M &amp;&amp; M &gt; initCapacity)resize(M / 2);}return ret;} bool contains(K key) {return hashtable[hash(key)]-&gt;contains(key);}public V get(K key) {return hashtable[hash(key)]-&gt;get(key);}private:inline int hash(K key){return (hashCode(key) &amp; 0x7fffffff) % M;  //取正并取模  得到对应索引值}void resize(int n){vector&lt;AVL&lt;K, V&gt;*&gt;* newHashTable = new vector&lt;AVL&lt;K, V&gt;*&gt;(newM);for (int i = 0; i &lt; newM; i++)newHashTable[i] = new AVL&lt;K, V&gt;();int oldM = M;this-&gt;M = newM;for (int i = 0; i &lt; oldM; i++){/*这里需要对旧表数据进行迁移必须对每个索引值所对应的AVL树进行遍历，将遍历到节点的k值经过新的hash计算加入到新表对应的索引中由于这里使用的是自己编写的AVL树，这么做的话需要编写属于AVL树的迭代器暂时没精力 留给以后有时间写*/}for (int i = 0; i &lt; oldM; i++)delete hashtable[i];delete hashtable;M = newM;hashtable = newHashTable;}private:vector&lt;AVL&lt;K,V&gt;*&gt;* hashtable;int M;int size;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自平衡二叉树 (2) -- 红黑树</title>
      <link href="zi-ping-heng-er-cha-shu-2-hong-hei-shu/"/>
      <url>zi-ping-heng-er-cha-shu-2-hong-hei-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h2><blockquote><p>摘自wiki<br>红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。这不只是使它们在时间敏感的应用，如实时应用（real time application）中有价值，而且使它们有在提供最坏情况担保的其他数据结构中作为基础模板的价值；例如，在计算几何中使用的很多数据结构都可以基于红黑树实现。</p></blockquote><p>红黑树在函数式编程中也特别有用，在这里它们是最常用的持久数据结构（persistent data structure）之一，它们用来构造关联数组和集合，每次插入、删除之后它们能保持为以前的版本。除了O(logn)的时间之外，红黑树的持久版本对每次插入或删除需要O(logn)的空间。</p><p>红黑树是2-3-4树的一种等同。换句话说，对于每个2-3-4树，都存在至少一个数据元素是同样次序的红黑树。在2-3-4树上的插入和删除操作也等同于在红黑树中颜色翻转和旋转。这使得2-3-4树成为理解红黑树背后的逻辑的重要工具，这也是很多介绍算法的教科书在红黑树之前介绍2-3-4树的原因，尽管2-3-4树在实践中不经常使用。</p><p>红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。</p><p>简而言之:</p><p>对于完全随机的数据(数据量不是很大),普通的二分搜索树很好用<br>缺点：极端情况退化为链表（或者高度不平衡）</p><p>对于查询较多的使用情况，AVL树很好用</p><p>红黑树牺牲了平衡性(最大高度为2logn的高度)<br>统计性能更优(综合增删改查所有的操作)</p><p>另一种统计性能优秀的树SplayTree (伸展树)<br>局部性原理:刚被访问的内容下次高概率被再次访问</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>每个节点都是红色或者黑色</li><li>根节点是黑色的</li><li>每一个叶子节点（最后的空节点）是黑色的</li><li>如果一个节点是红色的,那么他的孩子节点都是黑色的.</li><li>从任意一个节点到叶子节点，经过的黑色节点都是一样的(黑平衡)</li></ol><h2 id="从2-3树类比到红黑树"><a href="#从2-3树类比到红黑树" class="headerlink" title="从2-3树类比到红黑树"></a>从2-3树类比到红黑树</h2><p><img src="https://banthink.com/usr/uploads/2020/01/3143202452.jpg" alt="数据结构笔记-9.jpg"></p><p><img src="https://banthink.com/usr/uploads/2020/01/3143202452.jpg" alt="数据结构笔记-10.jpg"></p><p><img src="https://banthink.com/usr/uploads/2020/01/4260737663.jpg" alt="数据结构笔记-11.jpg"></p><p><img src="https://banthink.com/usr/uploads/2020/01/2438101852.jpg" alt="数据结构笔记-12.jpg"></p><p><img src="https://banthink.com/usr/uploads/2020/01/3553091507.jpg" alt="数据结构笔记-13.jpg"></p><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>图中实现的红黑树是一种特殊的红黑树——左倾红黑树,同时图中的红黑树并没有经过相应的优化,并不能像算法导论中所说任何不平衡都能在三次旋转内解决。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-none"><code class="language-none">//RBTree.hpp# include &lt;iostream&gt;# include &lt;string&gt;# include &lt;stack&gt;# include &lt;queue&gt;# include &lt;time.h&gt;using namespace std;template &lt;typename K, typename V&gt; class BST;template &lt;class K, class V&gt;class RBTree{private:const static  bool RED  =true ;const static  bool BLACK = false;template &lt;class K, class V&gt;class Node {public:Node(K key, V value){this-&gt;key = key;this-&gt;value = value;height = 1;  //初始为叶子节点left = NULL;right = NULL;color = RED;//1}public:bool color;K key;V value;Node&lt;K, V&gt;* left;Node&lt;K, V&gt;* right;int height;};public:RBTree(){root = NULL;size = 0;}inline int Size(){return size;}V get(K key){V ret = getNode(root, key)-&gt;value;return ret;}void add(K key, V value)  //向RBT添加新的元素 key ,value {root = add(root, key, value);root-&gt;color = BLACK;}bool contains(K e){return contains(root, e);}void preOrder(){preOrder(root);}void preOrderNR(){stack&lt;Node&lt;K, V&gt;*&gt; stack;stack.push(root);while (!stack.empty()){Node&lt;K, V&gt;* cur = stack.top();;stack.pop();cout &lt;&lt; cur-&gt;key &lt;&lt; " ";if (cur-&gt;left != NULL)stack.push(cur-&gt;left);if (cur-&gt;right != NULL)stack.push(cur-&gt;right);}}void inOrder(){inOrder(root);}void postOrder()  //应用:内存释放方面,先将孩子节点的内存都释放干净，再释放根节点{postOrder(root);}//层次遍历(广度优先遍历) void levelOrder(){queue&lt;Node&lt;K, V&gt;*&gt; q;q.push(root);while (!q.empty()){Node&lt;K, V&gt;* cur = q.front();q.pop();cout &lt;&lt; cur-&gt;key &lt;&lt; " ";if (cur-&gt;left != NULL){q.push(cur-&gt;left);}if (cur-&gt;right != NULL)q.push(cur-&gt;right);}}K minElement(){if (!size)throw "BST is empty";return minElement(root)-&gt;key;}K maxElement(){if (!size)throw "BST is empty";maxElement(root)-&gt;key;}string toString(){string val;generateBSTString(root, 0, val);return val;}K removeMin(){K val = minElement();root = removeMin(root);return val;}K removeMax(){K val = maxElement();root = removeMax(root);return val;}void remove(K val){root = remove(root, val);}bool isBST(){vector&lt;K&gt; keys;inOrder(root, keys);for (int i = 1; i &lt; keys.size(); i++){if (keys[i] &lt; keys[i - 1])return false;}return true;}private:bool isRed(Node&lt;K, V&gt;* node) { return node!=NULL&amp;&amp;node-&gt;color==RED; }Node&lt;K, V&gt;* getNode(Node&lt;K, V&gt;* node, K key){if (node == NULL)return NULL;if (key &lt; node-&gt;key)return getNode(node-&gt;left, key);else if (key &gt; node-&gt;key)return getNode(node-&gt;right, key);elsereturn node;}Node&lt;K,V&gt;* leftRotate(Node&lt;K,V&gt;* node){Node&lt;K, V&gt;* x = node-&gt;right;node-&gt;right = x-&gt;left;x-&gt;left = node;x-&gt;color = node-&gt;color;node-&gt;color = RED;return x;}Node&lt;K, V&gt;* rightRotate(Node&lt;K, V&gt;* node){Node&lt;K, V&gt;* x = node-&gt;left;node-&gt;left = x-&gt;right;x-&gt;right = node;x-&gt;color = node-&gt;color;node-&gt;color = RED;return x;}//颜色翻转void flipColors(Node&lt;K, V&gt;* node){node-&gt;color = RED;node-&gt;left-&gt;color = BLACK;node-&gt;right-&gt;color = BLACK;}Node&lt;K, V&gt;* add(Node&lt;K, V&gt;* node, K key, V value){if (node == NULL){size++;return new Node&lt;K, V&gt;(key, value);}if (key &lt; node-&gt;key)node-&gt;left = add(node-&gt;left, key, value);else if (key &gt; node-&gt;key)node-&gt;right = add(node-&gt;right, key, value);elsenode-&gt;value = value;//首先判断当前节点是否需要右旋操作if (isRed(node-&gt;right) &amp;&amp; !isRed(node-&gt;left)){node = leftRotate(node);}if (isRed(node-&gt;left) &amp;&amp; isRed(node-&gt;left-&gt;left)){node = rightRotate(node);}if (isRed(node-&gt;left) &amp;&amp; isRed(node-&gt;right))flipColors(node);return node;}bool contains(Node&lt;K, V&gt;* node, K e){if (node == NULL)return false;if (node-&gt;key == e)return true;else if (e&lt; node-&gt;key )return contains(node-&gt;left, e);elsereturn contains(node-&gt;right, e);}void preOrder(Node&lt;K, V&gt;* node){if (node == NULL)return;cout &lt;&lt; node-&gt;key &lt;&lt; " ";preOrder(node-&gt;left);preOrder(node-&gt;right);}void inOrder(Node&lt;K, V&gt;* node){if (node == NULL)return;inOrder(node-&gt;left);cout &lt;&lt; node-&gt;key &lt;&lt; " ";inOrder(node-&gt;right);}void inOrder(Node&lt;K, V&gt;* node, vector&lt;K&gt;&amp; keys){if (node == NULL)return;inOrder(node-&gt;left, keys);keys.push_back(node-&gt;key);inOrder(node-&gt;right, keys);}void postOrder(Node&lt;K, V&gt;* node){if (node == NULL)return;postOrder(node-&gt;left);postOrder(node-&gt;right);cout &lt;&lt; node-&gt;key &lt;&lt; " ";}//打印输出函数void  generateBSTString(Node&lt;K, V&gt;* node, int depth, string&amp; str){if (node == NULL){str += generateDepthString(depth) + "null\n";return;}str = str + generateDepthString(depth) + to_string(node-&gt;key) + "\n";generateBSTString(node-&gt;left, depth + 1, str);generateBSTString(node-&gt;right, depth + 1, str);}string generateDepthString(int depth){string str;for (int i = 0; i &lt; depth; i++)str += "--";return str;}Node&lt;K, V&gt;* minElement(Node&lt;K, V&gt;* node){if (node-&gt;left == NULL)return node;return minElement(node-&gt;left);}Node&lt;K, V&gt;* maxElement(Node&lt;K, V&gt;* node){if (node-&gt;right == NULL)return node;return minElement(node-&gt;right);}//删除以node为根的二分搜索树中的最小节点//返回删除节点后新的二分搜索树的根Node&lt;K, V&gt;* removeMin(Node&lt;K, V&gt;* node){if (node-&gt;left == NULL){Node&lt;K, V&gt;* rightNode = node-&gt;right;node-&gt;right = NULL;delete node;size--;return rightNode;}node-&gt;left = removeMin(node-&gt;left);return node;}Node&lt;K, V&gt;* removeMax(Node&lt;K, V&gt;* node){if (node-&gt;right == NULL)  //当前节点为最大值{Node* leftNode = node-&gt;left;node-&gt;left = NULL;delete node;size--;return leftNode;}node-&gt;right = removeMax(node-&gt;right);return node;}//任意删除节点Node&lt;K, V&gt;* remove(Node&lt;K, V&gt;* node, K e){if (node == NULL)return NULL;if (e &lt; node-&gt;key){node-&gt;left = remove(node-&gt;left, e);return node;}else if (e &gt; node-&gt;key){node-&gt;right = remove(node-&gt;right, e);return node;}else{if (node-&gt;left == NULL){Node&lt;K, V&gt;* rightNode = node-&gt;right;node-&gt;right = NULL;delete node;node = NULL;size--;return rightNode;}if (node-&gt;right == NULL){Node&lt;K, V&gt;* leftNode = node-&gt;left;node-&gt;left = NULL;delete node;node = NULL;size--;return leftNode;}  //有两个孩子节点且都不为空Node&lt;K, V&gt;* successor = new Node&lt;K, V&gt;(*minElement(node-&gt;right));successor-&gt;right = removeMin(node-&gt;right);successor-&gt;left = node-&gt;left;node-&gt;left = NULL;node-&gt;right = NULL;delete node;node = NULL;return successor;}}private:Node&lt;K, V&gt;* root;int size;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自平衡二叉树(1) -- AVL树</title>
      <link href="zi-ping-heng-er-cha-shu-1-avl-shu/"/>
      <url>zi-ping-heng-er-cha-shu-1-avl-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>在计算机科学中，AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者G. M. Adelson-Velsky和Evgenii Landis，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。<br>节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。<br>带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。  </p></blockquote><h1 id="AVL和二叉搜索树区别"><a href="#AVL和二叉搜索树区别" class="headerlink" title="AVL和二叉搜索树区别"></a>AVL和二叉搜索树区别</h1><p>当初始化的数组为有序时，二叉搜索树会退化为链表,其时间复杂度为O(n),违背了树这个结构本身设计的初衷.</p><p>AVL树在每次添加节点的时候都会平衡因子检查当前节点是否平衡(左右子树的高度差是否小于1),如果平衡被打破则进行旋转操作进行调整。</p><p>和并查集类似,当插入数据增大时候，我们不能保证每次插入的数据都能尽可能的铺满树的最后一层而不是不断的增加高度,保证树的高度尽可能低。并查集通过rank保证树的高度,而AVL则通过平衡因子保证树的高度尽可能小。</p><h1 id="自平衡操作"><a href="#自平衡操作" class="headerlink" title="自平衡操作"></a>自平衡操作</h1><p>旋转之后一定要保证AVL的性质还在!就是中序遍历后的结果是有序的!</p><h2 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h2><p>就个人理解而言，右旋就是需要旋转的节点顺时针旋转90°,这时候左孩子则顶替被旋节点的位置了,被旋节点成为了自己左孩子的右孩子!说起来有点绕，可以网上看看其他人做的动画,一抓一大把.</p><p>参考图<br><img src="https://banthink.com/usr/uploads/2020/01/1256111453.jpg" alt="AVL2.jpg"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>template&lt;class K, class V&gt;<br>Node&lt;K, V&gt;* AVL&lt;K, V&gt;::rightRotate(Node&lt;K, V&gt;* y)<br>{<br>    Node&lt;K, V&gt;* x = y-&gt;left;<br>    Node&lt;K, V&gt;* T3 = x-&gt;right;<br>    x-&gt;right = y;<br>    y-&gt;left = T3;<br>    //更新height<br>    y-&gt;height = max(getHeight(y-&gt;left), getHeight(y-&gt;right)) + 1;<br>    x-&gt;height = max(getHeight(x-&gt;left), getHeight(x-&gt;right)) + 1;<br>    return x;<br>}</p><h2 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h2><p>和右旋相反</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>template&lt;class K, class V&gt;<br>Node&lt;K, V&gt;* AVL&lt;K, V&gt;::leftRotate(Node&lt;K, V&gt;* y)<br>{<br>    Node&lt;K, V&gt;* x = y-&gt;right;<br>    Node&lt;K, V&gt;* T3 = x-&gt;left;<br>    x-&gt;left = y;<br>    y-&gt;right = T3;<br>    //更新height<br>    y-&gt;height = max(getHeight(y-&gt;left), getHeight(y-&gt;right)) + 1;<br>    x-&gt;height = max(getHeight(x-&gt;left), getHeight(x-&gt;right)) + 1;<br>    return x;</p><p>}</p><h1 id="潦草的笔记"><a href="#潦草的笔记" class="headerlink" title="潦草的笔记"></a>潦草的笔记</h1><p><img src="https://banthink.com/usr/uploads/2020/01/3664142220.jpg" alt="AVL1.jpg"></p><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><pre class="line-numbers language-none"><code class="language-none">AVL.hpp:# pragma once# ifndef _AVL_HPP_# define _AVL_HPP_# include &lt;iostream&gt;# include &lt;string&gt;# include &lt;stack&gt;# include &lt;queue&gt;# include&lt;list&gt;# include &lt;vector&gt;using namespace std;template&lt;class K, class V&gt; class AVL;template &lt;class K, class V&gt;class AVL{private:template &lt;class K, class V&gt;class Node {public:Node(K key, V value){this-&gt;key = key;this-&gt;value = value;height = 1;  //初始为叶子节点left = NULL;right = NULL;}public:K key;V value;Node&lt;K, V&gt;* left;Node&lt;K, V&gt;* right;int height;};public:AVL();inline int Size() { return size; }inline V get(K key) { return getNode(root, key)-&gt;value; }inline bool empty() { return size == 0; }inline void add(K key, V value) {root = add(root, key, value);}inline bool contains(K key) { return contains(root, key); }inline void preOrder() { preOrder(root); }void preOrderNR();inline void inOrder() { inOrder(root); }//应用:内存释放方面,先将孩子节点的内存都释放干净，再释放根节点inline void postOrder() { postOrder(root); }//层次遍历(广度优先遍历) void levelOrder();inline V minElement(){if (!size)throw "BST is empty";return minElement(root)-&gt;value;}inline V maxElement(){if (!size)throw "BST is empty";maxElement(root)-&gt;value;}inline string toString(){string val;generateBSTString(root, 0, val);return val;}inline V removeMin(){V val = minElement();root = removeMin(root);return val;}inline V removeMax(){V val = maxElement();root = removeMax(root);return val;}void remove(K key);bool isBST();//是否为一棵平衡二叉树inline bool isBalanced() { return isBalanced(root); }private:Node&lt;K, V&gt;* add(Node &lt;K, V&gt;* node, K key, V value);bool contains(Node &lt;K, V&gt;* node, K e);void preOrder(Node &lt;K, V&gt;* node);void inOrder(Node&lt;K, V&gt;* node);void inOrder(Node&lt;K, V&gt;* node, vector&lt;K&gt;&amp; keys);void postOrder(Node&lt;K, V&gt;* node);//打印输出函数void  generateBSTString(Node&lt;K, V&gt;* node, int depth, string&amp; str);string generateDepthString(int depth);Node&lt;K, V&gt;* minElement(Node&lt;K, V&gt;* node);Node&lt;K, V&gt;* maxElement(Node&lt;K, V&gt;* node);//任意删除节点Node&lt;K, V&gt;* remove(Node&lt;K, V&gt;* node, K e);Node&lt;K, V&gt;* getNode(Node&lt;K, V&gt;* node, K key);int getHeight(Node&lt;K, V&gt;* node);int getBalanceFctor(Node&lt;K, V&gt;* node);bool isBalanced(Node&lt;K, V&gt;* node);Node&lt;K, V&gt;* rightRotate(Node&lt;K, V&gt;* y);Node&lt;K, V&gt;* leftRotate(Node&lt;K, V&gt;* y);private:Node&lt;K, V&gt;* root;int size;};template&lt;class K, class V&gt;AVL&lt;K, V&gt;::AVL(){root = NULL;size = 0;}template&lt;class K, class V&gt;void AVL&lt;K, V&gt;::preOrderNR(){stack&lt;Node&lt;K, V&gt;*&gt; stack;stack.push(root);while (!stack.empty()){Node&lt;K, V&gt;* cur = stack.top();;stack.pop();cout &lt;&lt; cur-&gt;e &lt;&lt; " ";if (cur-&gt;left != NULL)stack.push(cur-&gt;left);if (cur-&gt;right != NULL)stack.push(cur-&gt;right);}}//层次遍历(广度优先遍历) template&lt;class K, class V&gt;void AVL&lt;K, V&gt;::levelOrder(){queue&lt;Node&lt;K, V&gt;*&gt; q;q.push(root);while (!q.empty()){Node&lt;K, V&gt;* cur = q.front();q.pop();cout &lt;&lt; cur-&gt;e &lt;&lt; " ";if (cur-&gt;left != NULL){q.push(cur-&gt;left);}if (cur-&gt;right != NULL)q.push(cur-&gt;right);}}template&lt;class K, class V&gt;void AVL&lt;K, V&gt;::remove(K key){root = remove(root, key);}template&lt;class K, class V&gt;bool AVL&lt;K, V&gt;::isBST(){vector&lt;K&gt; keys;inOrder(root, keys);for (int i = 1; i &lt; keys.size(); i++){if (keys[i] &lt; keys[i - 1])return false;}return true;}template&lt;class K, class V&gt;AVL&lt;K, V&gt;::Node&lt;K, V&gt;* AVL&lt;K, V&gt;::add(Node &lt;K, V&gt;* node, K key, V value){if (node == NULL){size++;return new Node&lt;K, V&gt;(key, value);}if (key &lt; node-&gt;key)node-&gt;left = add(node-&gt;left, key, value);else if (key &gt; node-&gt;key)node-&gt;right = add(node-&gt;right, key, value);elsenode-&gt;value = value;node-&gt;height = 1 + max(getHeight(node-&gt;left), getHeight(node-&gt;right));int banlanceFactor = getBalanceFctor(node);if (banlanceFactor &gt; 1 &amp;&amp; getBalanceFctor(node-&gt;left) &gt;= 0){//进行平衡调整右旋转LLreturn rightRotate(node);}if (banlanceFactor &lt; -1 &amp;&amp; getBalanceFctor(node-&gt;right) &lt;= 0)return leftRotate(node);  //RR//LRif (banlanceFactor &gt; 1 &amp;&amp; getBalanceFctor(node-&gt;left) &lt; 0){node-&gt;left = leftRotate(node-&gt;left);return rightRotate(node);}//RLif (banlanceFactor &lt; -1 &amp;&amp; getBalanceFctor(node-&gt;right) &gt; 0){node-&gt;right = rightRotate(node-&gt;right);return leftRotate(node);}return node;}template&lt;class K, class V&gt;bool AVL&lt;K, V&gt;::contains(Node &lt;K, V&gt;* node, K e){if (node == NULL)return false;if (node-&gt;key == e)return true;else if ( e&lt; node-&gt;key )return contains(node-&gt;left, e);elsereturn contains(node-&gt;right, e);}template&lt;class K, class V&gt;void AVL&lt;K, V&gt;::preOrder(Node &lt;K, V&gt;* node){if (node == NULL)return;cout &lt;&lt; node-&gt;value &lt;&lt; " ";preOrder(node-&gt;left);preOrder(node-&gt;right);}template&lt;class K, class V&gt;void AVL&lt;K, V&gt;::inOrder(Node&lt;K, V&gt;* node){if (node == NULL)return;inOrder(node-&gt;left);cout &lt;&lt; node-&gt;value &lt;&lt; " ";inOrder(node-&gt;right);}template&lt;class K, class V&gt;void AVL&lt;K, V&gt;::inOrder(Node&lt;K, V&gt;* node, vector&lt;K&gt;&amp; keys){if (node == NULL)return;inOrder(node-&gt;left, keys);keys.push_back(node-&gt;key);inOrder(node-&gt;right, keys);}template&lt;class K, class V&gt;void AVL&lt;K, V&gt;::postOrder(Node&lt;K, V&gt;* node){if (node == NULL)return;postOrder(node-&gt;left);postOrder(node-&gt;right);cout &lt;&lt; node-&gt;value &lt;&lt; " ";}//打印输出函数template&lt;class K, class V&gt;void  AVL&lt;K, V&gt;::generateBSTString(Node&lt;K, V&gt;* node, int depth, string&amp; str){if (node == NULL){str += generateDepthString(depth) + "null\n";return;}str = str + generateDepthString(depth) + to_string(node-&gt;value) + "\n";generateBSTString(node-&gt;left, depth + 1, str);generateBSTString(node-&gt;right, depth + 1, str);}template&lt;class K, class V&gt;string AVL&lt;K, V&gt;::generateDepthString(int depth){string str;for (int i = 0; i &lt; depth; i++)str += "--";return str;}template&lt;class K, class V&gt;AVL&lt;K, V&gt;::Node&lt;K, V&gt;* AVL&lt;K, V&gt;::minElement(Node&lt;K, V&gt;* node){if (node-&gt;left == NULL)return node;return minElement(node-&gt;left);}template&lt;class K, class V&gt;AVL&lt;K, V&gt;::Node&lt;K, V&gt;* AVL&lt;K, V&gt;::maxElement(Node&lt;K, V&gt;* node){if (node-&gt;right == NULL)return node;return minElement(node-&gt;right);}//任意删除节点template&lt;class K, class V&gt;AVL&lt;K, V&gt;::Node&lt;K, V&gt;* AVL&lt;K, V&gt;::remove(Node&lt;K, V&gt;* node, K e){Node&lt;K, V&gt;* retNode;if (node == NULL)return NULL;if (e &lt; node-&gt;key){node-&gt;left = remove(node-&gt;left, e);retNode = node;}else if (e &gt; node-&gt;key){node-&gt;right = remove(node-&gt;right, e);retNode = node;}else{if (node-&gt;left == NULL){Node&lt;K, V&gt;* rightNode = node-&gt;right;node-&gt;right = NULL;size--;delete node;node = NULL;retNode = rightNode;}else if (node-&gt;right == NULL){Node&lt;K, V&gt;* leftNode = node-&gt;left;node-&gt;left = NULL;size--;delete node;node = NULL;retNode = leftNode;}else {//待删除节点左右节点都不为空的情况retNode = new Node&lt;K,V&gt;(*minElement(node-&gt;right));//这里很重要!! 因为后面会删除最小元素这里先保存下来retNode-&gt;right = remove(node-&gt;right, retNode-&gt;key);retNode-&gt;left = node-&gt;left;node-&gt;left = NULL;node-&gt;right = NULL;delete node;node = NULL;//现在retNode可能是一棵新的不平衡AVL树  //接下来进行自平衡调整后返回retNode}}if (retNode == NULL)return NULL;retNode-&gt;height = 1 + max(getHeight(retNode-&gt;left), getHeight(retNode-&gt;right));int banlanceFactor = getBalanceFctor(retNode);if (banlanceFactor &gt; 1 &amp;&amp; getBalanceFctor(retNode-&gt;left) &gt;= 0){//进行平衡调整右旋转LLreturn rightRotate(retNode);}if (banlanceFactor &lt; -1 &amp;&amp; getBalanceFctor(retNode-&gt;right) &lt;= 0)return leftRotate(retNode);  //RR//LRif (banlanceFactor &gt; 1 &amp;&amp; getBalanceFctor(retNode-&gt;left) &lt; 0){retNode-&gt;left = leftRotate(retNode-&gt;left);return rightRotate(retNode);}//RLif (banlanceFactor &lt; -1 &amp;&amp; getBalanceFctor(retNode-&gt;right) &gt; 0){retNode-&gt;right = rightRotate(retNode-&gt;right);return leftRotate(retNode);}return retNode;}template&lt;class K, class V&gt;AVL&lt;K, V&gt;::Node&lt;K, V&gt;* AVL&lt;K, V&gt;::getNode(Node&lt;K, V&gt;* node, K key){if (node == NULL)return NULL;if (key &lt; node-&gt;key)return getNode(node-&gt;left, key);else if (key &gt; node-&gt;key)return getNode(node-&gt;right, key);elsereturn node;}template&lt;class K, class V&gt;int AVL&lt;K, V&gt;::getHeight(Node&lt;K, V&gt;* node){if (!node)return 0;return node-&gt;height;}template&lt;class K, class V&gt;int AVL&lt;K, V&gt;::getBalanceFctor(Node&lt;K, V&gt;* node){if (node == NULL)return 0;return getHeight(node-&gt;left) - getHeight(node-&gt;right);}template&lt;class K, class V&gt;bool AVL&lt;K, V&gt;::isBalanced(Node&lt;K, V&gt;* node){if (node == NULL)return true;int balanceFactor = getBalanceFctor(node);if (abs(balanceFactor) &gt; 1)return false;return isBalanced(node-&gt;left) &amp;&amp; isBalanced(node-&gt;right);}template&lt;class K, class V&gt;AVL&lt;K, V&gt;::Node&lt;K, V&gt;* AVL&lt;K, V&gt;::rightRotate(Node&lt;K, V&gt;* y){Node&lt;K, V&gt;* x = y-&gt;left;Node&lt;K, V&gt;* T3 = x-&gt;right;x-&gt;right = y;y-&gt;left = T3;//更新height y-&gt;height = max(getHeight(y-&gt;left), getHeight(y-&gt;right)) + 1;x-&gt;height = max(getHeight(x-&gt;left), getHeight(x-&gt;right)) + 1;return x;}template&lt;class K, class V&gt;AVL&lt;K, V&gt;::Node&lt;K, V&gt;* AVL&lt;K, V&gt;::leftRotate(Node&lt;K, V&gt;* y){Node&lt;K, V&gt;* x = y-&gt;right;Node&lt;K, V&gt;* T3 = x-&gt;left;x-&gt;left = y;y-&gt;right = T3;//更新height y-&gt;height = max(getHeight(y-&gt;left), getHeight(y-&gt;right)) + 1;x-&gt;height = max(getHeight(x-&gt;left), getHeight(x-&gt;right)) + 1;return x;}# endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="写代码时的坑点："><a href="#写代码时的坑点：" class="headerlink" title="写代码时的坑点："></a>写代码时的坑点：</h2><ol><li>删除节点时候的内存释放,树大小自减的时机</li><li>旋转操作时候的节点高度需要+1!</li><li>模板函数的头文件和源文件分离链接时出错:C++ 中的模板类声明头文件和实现文件分离后，如何能实现正常编译?<a href="https://www.zhihu.com/question/20630104">https://www.zhihu.com/question/20630104</a></li><li>嵌套类的使用<a href="https://blog.csdn.net/Poo_Chai/article/details/91596538">https://blog.csdn.net/Poo_Chai/article/details/91596538</a> 这篇我觉得讲的很清楚了</li><li>相关博文  ：C++ 单独编译（separate compilation）与 模板的编译<br><a href="https://www.cnblogs.com/deepllz/p/9044231.html">https://www.cnblogs.com/deepllz/p/9044231.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分搜索树</title>
      <link href="er-fen-sou-suo-shu/"/>
      <url>er-fen-sou-suo-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树wiki定义"><a href="#二叉搜索树wiki定义" class="headerlink" title="二叉搜索树wiki定义"></a>二叉搜索树wiki定义</h1><p>二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p><ol><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点。</li></ol><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><table><thead><tr><th>算法</th><th>平均</th><th>最差</th></tr></thead><tbody><tr><td>空间</td><td>O(n)</td><td>O(n)</td></tr><tr><td>搜索</td><td>O(log n)</td><td>O(n)</td></tr><tr><td>插入</td><td>O(log n)</td><td>O(n)</td></tr><tr><td>删除</td><td>O(log n)</td><td>O(n)</td></tr></tbody></table><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。</p><p>二叉查找树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉查找树的存储结构。中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以透过建构一棵二叉查找树变成一个有序序列，建构树的过程即为对无序序列进行查找的过程。</p><p>每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望O(log n)，最坏O(n)（数列有序，树退化成线性表）。</p><p>虽然二叉查找树的最坏效率是O(n)，但它支持动态查询，且有很多改进版的二叉查找树可以使树高为O(log n)，从而将最坏效率降至O(log n)，如AVL树、红黑树等。</p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>二分搜索树是一种极具递归性质的树,需要掌握下面四种遍历算法:</p><p>层次遍历、前序遍历、中序遍历、后序遍历。</p><p>层次遍历很简单，就是根据每层的节点从左到右访问下来</p><p>前中后序遍历三种方法的区别是对于根节点的访问顺序上面。每个节点都是各自子树的根节点（叶子节点可以看做孩子节点为NULL），对于这些根节点的访问顺序分别是第1\2\3个访问。</p><p>前序遍历: 每次对根节点优先访问，用途可以是输出某个文件夹下所有文件名称(可以有子文件夹)</p><p>中序遍历：当树中存放的值为可比较的时，遍历的结果将会有序。</p><p>后序遍历：优先访问最底下的孩子节点，也就是在释放二叉树的节点内存时候可以使用得到。</p><p><img src="https://banthink.com/usr/uploads/2020/01/1888861647.jpg" alt="数据结构笔记-1.jpg"></p><h2 id="添加和删除"><a href="#添加和删除" class="headerlink" title="添加和删除"></a>添加和删除</h2><p>添加操作简而言之就是从根节点开始递归到底,找到相应位置插入即可</p><p>删除操作比较复杂,首先需要判断被删除节点是否有左孩子或者右孩子，如果有就只需要将孩子节点顶替被删节点在其父节点中的位置即可。</p><p>如果同时有左右孩子就需要在删除前，找到最接近被删节点值的节点来顶替被删节点的位置.我们用被删节点的左子树中最大值来顶替被删节点的位置和用右子树中最小值来顶替被删节点的位置是一样的，这两者都不会改变中序遍历的顺序。</p><p>通过用复杂的删除操作、添加操作来保持二分搜索树中节点的排序规则，可以保证二分搜索树的性质不变。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面是C++代码实现</p><pre class="line-numbers language-none"><code class="language-none">//BST.hpp# include &lt;iostream&gt;# include &lt;string&gt;# include &lt;stack&gt;# include &lt;queue&gt;# include &lt;time.h&gt;using namespace std;template &lt;typename T&gt; class BST;template &lt;class T&gt;class Node {public:Node(T e){this-&gt;e = e;left = NULL;right - NULL;}inline T getElement() { return e; }friend class BST&lt;T&gt;;private:T e;Node&lt;T&gt;* left;Node&lt;T&gt;* right;};template &lt;class T&gt;class BST{public:BST(){root = NULL;size = 0;}inline int Size(){return size;}void add(T e)  //向二分搜索树添加新的元素e {/*第一版if(root==NULL)// 特殊处理{root=new Node&lt;T&gt;(e);size++;}elseadd(root,e);*//*第二版*/root = add(root, e);}bool contains(T e){return contains(root, e);}void preOrder(){preOrder(root);}void preOrderNR(){stack&lt;Node&lt;T&gt;*&gt; stack ;stack.push(root);while (!stack.empty()){Node&lt;T&gt;* cur= stack.top();;stack.pop();cout &lt;&lt; cur-&gt;e &lt;&lt; " ";if(cur-&gt;left!=NULL)stack.push(cur-&gt;left);if(cur-&gt;right!=NULL)stack.push(cur-&gt;right);}}void inOrder(){inOrder(root);}void postOrder()  //应用:内存释放方面,先将孩子节点的内存都释放干净，再释放根节点{postOrder(root);}//层次遍历(广度优先遍历) void levelOrder(){queue&lt;Node&lt;T&gt;*&gt; q;q.push(root);while (!q.empty()){Node&lt;T&gt;* cur = q.front();q.pop();cout &lt;&lt; cur-&gt;e &lt;&lt; " ";if (cur-&gt;left != NULL){q.push(cur-&gt;left);}if (cur-&gt;right != NULL)q.push(cur-&gt;right);}}T minElement(){if (!size)throw "BST is empty";return minElement(root)-&gt;e;}T maxElement(){if (!size)throw "BST is empty";maxElement(root)-&gt;e;}string toString(){string val;generateBSTString(root, 0, val);return val;}T removeMin(){T val = minElement();root = removeMin(root);return val;}T removeMax(){T val = maxElement();root = removeMax(root);return val;}void remove(T val){root=remove(root, val);}private://第一版/*void add(Node&lt;T&gt;* root,T e)//以Node为根的二分搜索树插入元素e 递归{if(e==root.e)return ;else if(e&lt;root.e&amp;&amp;root.left==NULL){root.left=new Node&lt;T&gt;(e);size++;return ;}else if(e&gt;root.e&amp;&amp;root.right==NULL){root.right=new Node&lt;T&gt;(e);size++;return ;}if(e&lt;root.e)add(root.left,e);elseadd(root.right,e);}*///第二版 相等的时候返回回去Node&lt;T&gt;* add(Node &lt;T&gt;* node, T e){if (node == NULL){size++;return new Node&lt;T&gt;(e);}if (e &lt; node-&gt;e)node-&gt;left = add(node-&gt;left, e);else if(e&gt;node-&gt;e)node-&gt;right = add(node-&gt;right, e);return node;}bool contains(Node &lt;T&gt;* node, T e){if (node == NULL)return false;if (node-&gt;e == e)return true;else if (node-&gt;e &lt; e)return contains(node-&gt;left, e);elsereturn contains(node-&gt;right, e);}void preOrder(Node &lt;T&gt;* node){if (node == NULL)return;cout &lt;&lt; node-&gt;e&lt;&lt;" ";preOrder(node-&gt;left);preOrder(node-&gt;right);}void inOrder(Node&lt;T&gt;* node){if (node == NULL)return;inOrder(node-&gt;left);cout &lt;&lt; node-&gt;e &lt;&lt; " ";inOrder(node-&gt;right);}void postOrder(Node&lt;T&gt;* node){if (node == NULL)return;postOrder(node-&gt;left);postOrder(node-&gt;right);cout &lt;&lt; node-&gt;e &lt;&lt; " ";}//打印输出函数void  generateBSTString(Node&lt;T&gt;* node, int depth, string&amp; str){if (node == NULL){str += generateDepthString(depth) + "null\n";return;}str =str+ generateDepthString(depth) + to_string(node-&gt;e) + "\n";generateBSTString(node-&gt;left, depth + 1, str);generateBSTString(node-&gt;right, depth + 1, str);}string generateDepthString(int depth){string str;for (int i = 0; i &lt; depth; i++)str += "--";return str;}Node&lt;T&gt;* minElement(Node&lt;T&gt;*node){if (node-&gt;left == NULL)return node;return minElement(node-&gt;left);}Node&lt;T&gt;* maxElement(Node&lt;T&gt;* node){if (node-&gt;right == NULL)return node;return minElement(node-&gt;right);}//删除以node为根的二分搜索树中的最小节点//返回删除节点后新的二分搜索树的根Node&lt;T&gt;* removeMin(Node&lt;T&gt; *node){if (node-&gt;left == NULL){Node&lt;T&gt;* rightNode = node-&gt;right;node-&gt;right = NULL;delete node;size--;return rightNode;}node-&gt;left=removeMin(node-&gt;left);return node;}Node&lt;T&gt; * removeMax(Node&lt;T&gt; *node){if (node-&gt;right == NULL)  //当前节点为最大值{Node* leftNode = node-&gt;left;node-&gt;left = NULL;delete node;size--;return leftNode;}node-&gt;right = removeMax(node-&gt;right);return node;}//任意删除节点Node&lt;T&gt;* remove(Node&lt;T&gt;* node, T e){if (node == NULL)return NULL;if (e &lt; node-&gt;e){node-&gt;left=remove(node-&gt;left,e);return node;}else if (e &gt; node-&gt;e){node-&gt;right = remove(node-&gt;right, e);return node;}else{if (node-&gt;left == NULL){Node&lt;T&gt;* rightNode = node-&gt;right;node-&gt;right = NULL;delete node;size--;return rightNode;}if (node-&gt;right == NULL){Node&lt;T&gt;* leftNode = node-&gt;left;node-&gt;left = NULL;delete node;size--;return leftNode;}Node&lt;T&gt;* successor = new Node&lt;T&gt;(*minElement(node-&gt;right);successor-&gt;right = removeMin(node-&gt;right);successor-&gt;left = node-&gt;left;node-&gt;left = NULL;node-&gt;right = NULL;delete node;return successor;}}private:Node&lt;T&gt;* root;int size;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="基于二分搜索树的集合-set"><a href="#基于二分搜索树的集合-set" class="headerlink" title="基于二分搜索树的集合(set)"></a>基于二分搜索树的集合(set)</h1><pre class="line-numbers language-none"><code class="language-none">template &lt;class T&gt;class Set{public:virtual void add(T e) = 0;virtual void remove(T e) = 0;virtual bool contains(T e) = 0;virtual int size() = 0;virtual bool empty() = 0;};template &lt;class T&gt;class BSTSet:public Set{public:virtual void add(T e) {bst.add(e);}virtual void remove(T e){bst.remove(e);}virtual bool contains(T e){return bst.contains(e);}virtual int size(){return bst.Size();}virtual bool empty(){return bst.Size() == 0;}private:BST&lt;T&gt;  bst;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="基于二分搜索树的映射-map"><a href="#基于二分搜索树的映射-map" class="headerlink" title="基于二分搜索树的映射(map)"></a>基于二分搜索树的映射(map)</h1><pre class="line-numbers language-none"><code class="language-none"># include &lt;iostream&gt;# include &lt;string&gt;# include &lt;stack&gt;# include &lt;queue&gt;# include &lt;time.h&gt;using namespace std;template &lt;class K, class V&gt; class BSTMap;template&lt;class K, class V&gt;class Map {public:virtual void add(K key, V value) = 0;virtual V remove(K key) = 0;virtual bool contains(K key) = 0;virtual V get(K key) = 0;virtual int Size() = 0;virtual bool empty() = 0;};template &lt;class K,class V&gt;class Node {public:Node(K key,V value){this-&gt;key = key;this-&gt;value = value;left = NULL;right - NULL;}friend class BSTMap&lt;K,V&gt;;private:K key;V value;Node&lt;K,V&gt;* left;Node&lt;K,V&gt;* right;};template &lt;class K, class V&gt;class BSTMap :public Map&lt;K,V&gt;{public:BSTMap(){root = NULL;size = 0;}inline int Size(){return size;}V get(K key){return getNode(root, key)-&gt;value;}bool empty(){return size == 0;}void add(K key,V value)  //向二分搜索树添加新的元素e {/*第一版if(root==NULL)// 特殊处理{root=new Node&lt;T&gt;(e);size++;}elseadd(root,e);*//*第二版*/root = add(root, key,value);}bool contains(K e){return contains(root, e);}void preOrder(){preOrder(root);}void preOrderNR(){stack&lt;Node&lt;K,V&gt;*&gt; stack ;stack.push(root);while (!stack.empty()){Node&lt;K,V&gt;* cur= stack.top();;stack.pop();cout &lt;&lt; cur-&gt;e &lt;&lt; " ";if(cur-&gt;left!=NULL)stack.push(cur-&gt;left);if(cur-&gt;right!=NULL)stack.push(cur-&gt;right);}}void inOrder(){inOrder(root);}void postOrder()  //应用:内存释放方面,先将孩子节点的内存都释放干净，再释放根节点{postOrder(root);}//层次遍历(广度优先遍历) void levelOrder(){queue&lt;Node&lt;K,V&gt;*&gt; q;q.push(root);while (!q.empty()){Node&lt;K,V&gt;* cur = q.front();q.pop();cout &lt;&lt; cur-&gt;e &lt;&lt; " ";if (cur-&gt;left != NULL){q.push(cur-&gt;left);}if (cur-&gt;right != NULL)q.push(cur-&gt;right);}}V minElement(){if (!size)throw "BST is empty";return minElement(root)-&gt;value;}V maxElement(){if (!size)throw "BST is empty";maxElement(root)-&gt;value;}string toString(){string val;generateBSTString(root, 0, val);return val;}V removeMin(){V val = minElement();root = removeMin(root);return val;}V removeMax(){V val = maxElement();root = removeMax(root);return val;}V remove(K key){V val=getNode(root, key)-&gt;value;root=remove(root, key);return val;}private://第一版/*void add(Node&lt;T&gt;* root,T e)//以Node为根的二分搜索树插入元素e 递归{if(e==root.e)return ;else if(e&lt;root.e&amp;&amp;root.left==NULL){root.left=new Node&lt;T&gt;(e);size++;return ;}else if(e&gt;root.e&amp;&amp;root.right==NULL){root.right=new Node&lt;T&gt;(e);size++;return ;}if(e&lt;root.e)add(root.left,e);elseadd(root.right,e);}*///第二版 相等的时候返回回去Node&lt;K,V&gt;* add(Node &lt;K,V&gt;* node, K key,V value){if (node == NULL){size++;return new Node&lt;K,V&gt;(key,value);}if (key &lt; node-&gt;key)node-&gt;left = add(node-&gt;left, key,value);else if(key &gt;node-&gt;key)node-&gt;right = add(node-&gt;right, key, value);return node;}bool contains(Node &lt;K, V&gt;* node, K e){if (node == NULL)return false;if (node-&gt;key == e)return true;else if (node-&gt;key &lt; e)return contains(node-&gt;left, e);elsereturn contains(node-&gt;right, e);}void preOrder(Node &lt;K, V&gt;* node){if (node == NULL)return;cout &lt;&lt; node-&gt;value&lt;&lt;" ";preOrder(node-&gt;left);preOrder(node-&gt;right);}void inOrder(Node&lt;K, V&gt;* node){if (node == NULL)return;inOrder(node-&gt;left);cout &lt;&lt; node-&gt;value &lt;&lt; " ";inOrder(node-&gt;right);}void postOrder(Node&lt;K, V&gt;* node){if (node == NULL)return;postOrder(node-&gt;left);postOrder(node-&gt;right);cout &lt;&lt; node-&gt;value &lt;&lt; " ";}//打印输出函数void  generateBSTString(Node&lt;K, V&gt;* node, int depth, string&amp; str){if (node == NULL){str += generateDepthString(depth) + "null\n";return;}str =str+ generateDepthString(depth) + to_string(node-&gt;value) + "\n";generateBSTString(node-&gt;left, depth + 1, str);generateBSTString(node-&gt;right, depth + 1, str);}string generateDepthString(int depth){string str;for (int i = 0; i &lt; depth; i++)str += "--";return str;}Node&lt;K, V&gt;* minElement(Node&lt;K, V&gt;*node){if (node-&gt;left == NULL)return node;return minElement(node-&gt;left);}Node&lt;K, V&gt;* maxElement(Node&lt;K, V&gt;* node){if (node-&gt;right == NULL)return node;return minElement(node-&gt;right);}//删除以node为根的二分搜索树中的最小节点//返回删除节点后新的二分搜索树的根Node&lt;K, V&gt;* removeMin(Node&lt;K, V&gt;*node){if (node-&gt;left == NULL){Node&lt;K, V&gt;* rightNode = node-&gt;right;node-&gt;right = NULL;delete node;size--;return rightNode;}node-&gt;left=removeMin(node-&gt;left);return node;}Node&lt;K, V&gt;* removeMax(Node&lt;K, V&gt;*node){if (node-&gt;right == NULL)  //当前节点为最大值{Node* leftNode = node-&gt;left;node-&gt;left = NULL;delete node;size--;return leftNode;}node-&gt;right = removeMax(node-&gt;right);return node;}//任意删除节点Node&lt;K, V&gt;* remove(Node&lt;K, V&gt;* node, K e){if (node == NULL)return NULL;if (e &lt; node-&gt;key){node-&gt;left=remove(node-&gt;left,e);return node;}else if (e &gt; node-&gt;key){node-&gt;right = remove(node-&gt;right, e);return node;}else{if (node-&gt;left == NULL){Node&lt;K,V&gt;* rightNode = node-&gt;right;node-&gt;right = NULL;delete node;size--;return rightNode;}if (node-&gt;right == NULL){Node&lt;K, V&gt;* leftNode = node-&gt;left;node-&gt;left = NULL;delete node;size--;return leftNode;}Node&lt;T&gt;* successor = new Node&lt;T&gt;(*minElement(node-&gt;right));successor-&gt;right = removeMin(node-&gt;right);successor-&gt;left = node-&gt;left;node-&gt;left = NULL;node-&gt;right = NULL;delete node;return successor;}}Node&lt;K, V&gt;* getNode(Node&lt;K,V&gt; *node,K key){if (node == NULL)return NULL;if (key &lt; node-&gt;key)getNode(node-&gt;left, key);else if (key &gt; node-&gt;key)getNode(node-&gt;right, key);elsereturn node;}private:Node&lt;K,V&gt;* root;int size;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="完整的基于BST映射代码实现"><a href="#完整的基于BST映射代码实现" class="headerlink" title="完整的基于BST映射代码实现"></a>完整的基于BST映射代码实现</h1><pre class="line-numbers language-none"><code class="language-none">//BST.hpp# include &lt;iostream&gt;# include &lt;string&gt;# include &lt;stack&gt;# include &lt;queue&gt;# include &lt;time.h&gt;using namespace std;template &lt;typename K,typename V&gt; class BST;template &lt;class K,class V&gt;class BST{private:template &lt;class K, class V&gt;class Node {public:Node(K key, V value){this-&gt;key = key;this-&gt;value = value;height = 1;  //初始为叶子节点left = NULL;right = NULL;}public:K key;V value;Node&lt;K, V&gt;* left;Node&lt;K, V&gt;* right;int height;};public:BST(){root = NULL;size = 0;}inline int Size(){return size;}V get(K key){V ret=getNode(root, key)-&gt;value;return ret;}void add(K key,V value)  //向二分搜索树添加新的元素e {/*第一版if(root==NULL)// 特殊处理{root=new Node(e);size++;}elseadd(root,e);*//*第二版*/root = add(root, key,value);}bool contains(K e){return contains(root, e);}void preOrder(){preOrder(root);}void preOrderNR(){stack&lt;Node&lt;K,V&gt;*&gt; stack;stack.push(root);while (!stack.empty()){Node&lt;K,V&gt;* cur = stack.top();;stack.pop();cout &lt;&lt; cur-&gt;key &lt;&lt; " ";if (cur-&gt;left != NULL)stack.push(cur-&gt;left);if (cur-&gt;right != NULL)stack.push(cur-&gt;right);}}void inOrder(){inOrder(root);}void postOrder()  //应用:内存释放方面,先将孩子节点的内存都释放干净，再释放根节点{postOrder(root);}//层次遍历(广度优先遍历) void levelOrder(){queue&lt;Node&lt;K,V&gt;*&gt; q;q.push(root);while (!q.empty()){Node&lt;K,V&gt;* cur = q.front();q.pop();cout &lt;&lt; cur-&gt;key &lt;&lt; " ";if (cur-&gt;left != NULL){q.push(cur-&gt;left);}if (cur-&gt;right != NULL)q.push(cur-&gt;right);}}K minElement(){if (!size)throw "BST is empty";return minElement(root)-&gt;key;}K maxElement(){if (!size)throw "BST is empty";maxElement(root)-&gt;key;}string toString(){string val;generateBSTString(root, 0, val);return val;}K removeMin(){K val = minElement();root = removeMin(root);return val;}K removeMax(){K val = maxElement();root = removeMax(root);return val;}void remove(K val){root = remove(root, val);}bool isBST(){vector&lt;K&gt; keys;inOrder(root, keys);for (int i = 1; i &lt; keys.size(); i++){if (keys[i] &lt; keys[i - 1])return false;}return true;}private:Node&lt;K, V&gt;* getNode(Node&lt;K, V&gt;* node, K key){if (node == NULL)return NULL;if (key &lt; node-&gt;key)return getNode(node-&gt;left, key);else if (key &gt; node-&gt;key)return getNode(node-&gt;right, key);elsereturn node;}Node&lt;K,V&gt;* add(Node&lt;K,V&gt;* node, K key,V value){if (node == NULL){size++;return new Node&lt;K,V&gt;(key,value);}if (key &lt; node-&gt;key)node-&gt;left = add(node-&gt;left, key,value);else if (key &gt; node-&gt;key)node-&gt;right = add(node-&gt;right, key, value);return node;}bool contains(Node&lt;K,V&gt;* node, K e){if (node == NULL)return false;if (node-&gt;key == e)return true;else if (node-&gt;key &lt; e)return contains(node-&gt;left, e);elsereturn contains(node-&gt;right, e);}void preOrder(Node&lt;K,V&gt;* node){if (node == NULL)return;cout &lt;&lt; node-&gt;key &lt;&lt; " ";preOrder(node-&gt;left);preOrder(node-&gt;right);}void inOrder(Node&lt;K,V&gt;* node){if (node == NULL)return;inOrder(node-&gt;left);cout &lt;&lt; node-&gt;key &lt;&lt; " ";inOrder(node-&gt;right);}void inOrder(Node&lt;K, V&gt;* node, vector&lt;K&gt;&amp; keys){if (node == NULL)return;inOrder(node-&gt;left,keys);keys.push_back(node-&gt;key);inOrder(node-&gt;right, keys);}void postOrder(Node&lt;K,V&gt;* node){if (node == NULL)return;postOrder(node-&gt;left);postOrder(node-&gt;right);cout &lt;&lt; node-&gt;key &lt;&lt; " ";}//打印输出函数void  generateBSTString(Node&lt;K,V&gt;* node, int depth, string&amp; str){if (node == NULL){str += generateDepthString(depth) + "null\n";return;}str = str + generateDepthString(depth) + to_string(node-&gt;key) + "\n";generateBSTString(node-&gt;left, depth + 1, str);generateBSTString(node-&gt;right, depth + 1, str);}string generateDepthString(int depth){string str;for (int i = 0; i &lt; depth; i++)str += "--";return str;}Node&lt;K,V&gt;* minElement(Node&lt;K,V&gt;* node){if (node-&gt;left == NULL)return node;return minElement(node-&gt;left);}Node&lt;K,V&gt;* maxElement(Node&lt;K,V&gt;* node){if (node-&gt;right == NULL)return node;return minElement(node-&gt;right);}//删除以node为根的二分搜索树中的最小节点//返回删除节点后新的二分搜索树的根Node&lt;K,V&gt;* removeMin(Node&lt;K,V&gt;* node){if (node-&gt;left == NULL){Node&lt;K,V&gt;* rightNode = node-&gt;right;node-&gt;right = NULL;delete node;size--;return rightNode;}node-&gt;left = removeMin(node-&gt;left);return node;}Node&lt;K,V&gt;* removeMax(Node&lt;K,V&gt;* node){if (node-&gt;right == NULL)  //当前节点为最大值{Node* leftNode = node-&gt;left;node-&gt;left = NULL;delete node;size--;return leftNode;}node-&gt;right = removeMax(node-&gt;right);return node;}//任意删除节点Node&lt;K,V&gt;* remove(Node&lt;K,V&gt;* node, K e){if (node == NULL)return NULL;if (e &lt; node-&gt;key){node-&gt;left = remove(node-&gt;left, e);return node;}else if (e &gt; node-&gt;key){node-&gt;right = remove(node-&gt;right, e);return node;}else{if (node-&gt;left == NULL){Node&lt;K,V&gt;* rightNode =node-&gt;right;node-&gt;right = NULL;delete node;node = NULL;size--;return rightNode;}if (node-&gt;right == NULL){Node&lt;K,V&gt;* leftNode = node-&gt;left;node-&gt;left = NULL;delete node;node = NULL;size--;return leftNode;}  //有两个孩子节点且都不为空Node&lt;K,V&gt;* successor = new Node&lt;K,V&gt;(*minElement(node-&gt;right));successor-&gt;right = removeMin(node-&gt;right);successor-&gt;left = node-&gt;left;node-&gt;left = NULL;node-&gt;right = NULL;delete node;node = NULL;return successor;}}private:Node&lt;K, V&gt;* root;int size;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>set和map的二分搜索树实现和链表实现的方式其实都很简单,首先需要声明个set/map接口后继承，然后实现接口中的方法即可。二分搜索树只能应用于有序集合/键 中，链表都可以。</p><p>本身二分搜索树就满足集合的性质(值唯一),如果要改写为映射的话实际上也很简单,在每个节点中添加一个值属性，并改写节点的构造函数.</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Trie 字典树or前缀树</title>
      <link href="trie-zi-dian-shu-or-qian-zhui-shu/"/>
      <url>trie-zi-dian-shu-or-qian-zhui-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Trie-字典树-前缀树"><a href="#Trie-字典树-前缀树" class="headerlink" title="Trie 字典树/前缀树"></a>Trie 字典树/前缀树</h1><blockquote><p>wiki 定义<br>在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p></blockquote><h2 id="和并查集的区别"><a href="#和并查集的区别" class="headerlink" title="和并查集的区别"></a>和并查集的区别</h2><p>并查集主要解决的问题是网络连接问题,集合的包含合并问题.而Trie主要通过空间换取时间,将需要查询的字符串拆解为一个个字符存储在节点中,实现每次查询是否包含字符串只需要付出O(K)(K 为字符串的长度) 的时间复杂度. </p><p>两者实际都是一种为了解决特定问题的多路树结构.</p><h1 id="笔记内容"><a href="#笔记内容" class="headerlink" title="笔记内容"></a>笔记内容</h1><p><img src="https://banthink.com/usr/uploads/2020/01/2954635440.jpg" alt="数据结构笔记-6.jpg"></p><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><pre class="line-numbers language-none"><code class="language-none"># include &lt;iostream&gt;# include &lt;map&gt;# include &lt;string&gt;class Node{    private:            bool isWord;        map&lt;char,Node*&gt; next;    public:        Node(bool isWord=false)        {            this-&gt;isWord=isWord;                    }        void addMap(char c)        {            next[c]=new Node();        }        bool findNode(char c)        {            return next.find(c)!=next.end();        }        inline void setWord(){isWord=true;}        inline bool isTrue(){return isWord;}        inline void clrWord(){isWord=false;}        inline Node * Next(char c){return next[c];}        inline map&lt;char,Node*&gt; *getNext(){return &amp;next;}        };class Trie{  public:    Trie()    {        root=new Node();        size=0;            }    inline int getSize(){return size;}    void add(string word)    {        Node* cur=root;        for(int i=0;i&lt;word.length();i++)        {            if(!cur-&gt;findNode(word[i]))                cur-&gt;addMap(word[i]);            cur=cur-&gt;Next(word[i]);        }        cur-&gt;setWord();        size++;    }    bool contains(string word)    {        Node *cur=root;        for(int i=0;i&lt;word.length();i++)        {            if(!cur-&gt;findNode(word[i]))                return false;            cur=cur-&gt;Next(word[i]);        }        return cur-&gt;isTrue();    }    bool searchPrefix(string prefix)  //查找前缀     {        Node *cur=root;        for(int i=0;i&lt;prefix.length();i++)        {            if(!cur-&gt;findNode(prefix[i]))                return false;            cur=cur-&gt;Next(prefix[i]);        }        return true;    }    bool searchMode(string word)  //模式查找    {        return match(root,word,0);    }    void delWord(string word)    {        if(contains(word))            del(root,word,0);       }  private:    void del(Node *node,string word,int index)    {       if(index&gt;word.length()||node==NULL)       {           return ;       }       del(node-&gt;Next(word[index]),word,index+1);               if(node-&gt;getNext()-&gt;size())               {                   if(index==word.length());                    node-&gt;clrWord();               }else               {                   if(node!=root)                   {                   delete node;                   *node=NULL;                   }               }       }    bool match(Node *node,string word,int index)    {        if(!node)            return false;        if(index==word.length())            return node-&gt;isTrue();        if(word[index]!='.'){            if(!node-&gt;findNode(word[index]))                return false;            return match(node-&gt;Next(word[index]),word,index+1);                }else        {            for(map&lt;char,Node*&gt;::iterator it=node-&gt;getNext()-&gt;begin();                it!=node-&gt;getNext()-&gt;end();it++)                {                                     if(match((*it).second,word,index+1))                             return true;                }            return false;        }    }  private:    Node *root;    int size;};int main(){    Trie tree;    tree.add("heo");    tree.delWord("heo");    cout&lt;&lt;tree.searchMode("h.o");        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后缀树<br>三叉搜索树 </p><p>更多的字符串问题</p><p>子串查询<br>KMP<br>Boyer-Moore<br>Rabin-Karp</p><p>文件压缩<br>哈夫曼算法</p><p>模式匹配</p><p>编译原理</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="bing-cha-ji/"/>
      <url>bing-cha-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>1、 高效的解决点和点之间的连接问题,实例中就是网络中节点间的连接状态,这里的网络并不单单指代计算机网络,同时也指代现实中的关系网络.</p><p>2、 数学中的集合类实现,查询和并集合的操作.</p><h3 id="连接问题和路径问题"><a href="#连接问题和路径问题" class="headerlink" title="连接问题和路径问题"></a>连接问题和路径问题</h3><p>前者只需要进行判断,后者有着更广阔的应用空间吗,无论是两者之间的最短路径还是具体的路径情况.</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>对于一组数据，支持两个动作</p><p>union(p,q) 合并两个集合</p><p>isConnected(p,q)  两个元素是否同属于一个集合</p><h2 id="笔记内容"><a href="#笔记内容" class="headerlink" title="笔记内容"></a>笔记内容</h2><p><img src="https://banthink.com/usr/uploads/2020/01/4214199502.jpg" alt="数据结构笔记-3.jpg"></p><p><img src="https://banthink.com/usr/uploads/2020/01/2531102955.jpg" alt="数据结构笔记-4.jpg"></p><p><img src="https://banthink.com/usr/uploads/2020/01/3955321161.jpg" alt="数据结构笔记-5.jpg"></p><p>并查集的Rank[i]指的是根节点为i的树的高度.之所以不用height来形象的表示,是因为后面在路径压缩操作中,会将改变树的高度,这时候Rank值并不需要更新.是因为本身树高度的比较就是相对而言的,这时候Rank更多的意思是权重的意思.</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h3><pre class="line-numbers language-none"><code class="language-none"># include &lt;iostream&gt;class UF{  public:    UF(){}    virtual bool isConnected(int p,int q)=0;    virtual void unionElements(int p,int q)=0;    virtual int getSize()=0;        };class QuickUnionFind :public UF{    public:        QuickUnionFind(int size)        {           id.resize(size);           for(int i=0;i&lt;id.size();i++)           {            id[i]=i;           }                }        bool isConnected(int p,int q)        {        return find(p)==find(q);                }        void unionElements(int p,int q)        {        int pID=find(p);        int qID=find(q);        if(qID==pID)            return;        for(int i=0;i&lt;id.size();i++)        {        if(id[i]==pID)            id[i]=qID;        }                }       inline int getSize(){return id.size();}    private:        int find(int p)        {         if(p&lt;0||p&gt;=id.size())            return -1;        return id[p];            }    private:        vector&lt;int&gt; id;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="增加了Rank和路径压缩"><a href="#增加了Rank和路径压缩" class="headerlink" title="增加了Rank和路径压缩"></a>增加了Rank和路径压缩</h3><pre class="line-numbers language-none"><code class="language-none">class UnionFind :public UF{    public:            UnionFind(int size)            {            parent.resize(size);            rank.resize(size);            for(int i=0;i&lt;size;i++)            {            parent[i]=i;            rank[i]=1;            }                                        }           inline int getSize(){return parent.size();}           int find(int p)           {            if(p&lt;0||p&gt;=getSize())                return -1;            if(p!=parent[p])            {                parent[p]=find(parent[p]);   //进行路径压缩  使树的深度为2                         }            return parent[p];           }           bool isConnected(int p,int q)           {           return find(p)==find(q);           }           void unionElements(int p,int q)           {            int pRoot = find(p);            int qRoot = find(q);            if(pRoot==qRoot)                return ;         //根据两个元素所在的rank不同判断合并方向           //将rank低的集合合并到rank高的集合上            if(rank[pRoot]&lt;rank[qRoot])            {                parent[pRoot]=qRoot;            }            else if(rank[qRoot]&lt;rank[pRoot])            {                parent[qRoot]=pRoot;            }else            {                  parent[pRoot]=qRoot;                  rank[qRoot]++;            }           }    private:        vector&lt;int&gt; parent;        vector&lt;int&gt; rank; //存储以i为为根的树的权重};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库开发学习 (2)  结构设计</title>
      <link href="shu-ju-ku-kai-fa-xue-xi-2-jie-gou-she-ji/"/>
      <url>shu-ju-ku-kai-fa-xue-xi-2-jie-gou-she-ji/</url>
      
        <content type="html"><![CDATA[<p>业务数据库设计流程<br>需求分析分析—&gt;概要设计—&gt;详细设计</p><p>瀑布模型和螺旋模型</p><p>瀑布模型: 只有往下迭代开发,没有回溯.多适合用于业务需求十分明确可以一次性完成开发</p><p>螺旋模型: 有回溯,多次迭代开发.每次开发仅完成一部分的内容,与瀑布模型相反,用敏捷开发快速迭代出一版,适用于业务需求并不明确.</p><p>宽表模式<br>将属性全部列在一个表中</p><p>缺点 </p><ol><li>数据冗余,相同数据出现多次</li><li>维护成本高</li><li>更新异常</li><li>插入异常: 部分数据由于缺失主键信息而不得显示</li><li>删除异常: 删除某一数据时不得不删除另一数据</li></ol><p>适用场景<br>配合列存储的数据报表应用</p><p>逻辑设计: 数据库设计范式</p><p>第一范式: 表中的所有字段都是不可再分的</p><p>第二范式: 表中必须存在业务主键(能够唯一标识出每一行业务数据的列或者列的组合),并且非主键依赖于全部业务主键,意味着列非主键不能只依赖于组合业务主键中的某一个主属性</p><p>第三范式: 表中的非主键列之间不能相互依赖.(传递依赖),第三范式的目的就是为了让非主键列的字段只完全依赖于主键列,与其他列无关.</p><p>ER图:实体关系图,</p><p>属性语法</p><p>复合属性是多个属性的组合</p><p>多值属性是某个属性可以有多个不同的取值</p><p>派生属性是不保存在实体中的属性,用虚线绘制</p><p>可选属性是允许有空值的属性(在名字下方增加”(0)”  )</p><p>主键字段由下划线标识</p><p>实体关系语法</p><p>一对一关系</p><p>一对多关系</p><p>MySQL存储引擎<br>|  引擎名称   |   支持事务  |  说明 |<br>|  —-  | —-  | —- |<br>| MyISAM  | No | 不具备事务机制,不具备多线程访问,串行执行SQL语句 |<br>| CSV引擎  | No | 以CSV格式存储的非事务型存储引擎|<br>| Memory  | No |存储于内存中的易失型非事务型存储引擎|<br>| Archive   |No| 只允许查询和新增数据而不允许修改的非事务型存储引擎|<br>| InnoDB   |Yes |最常用,支持事务机制,适合写多读多,支持多线程读写,在多线程读写的时候是用行锁而不是MyISAM引擎的表锁<br>| TokuDB   |Yes |支持事务机制,适合写多读少.</p><p>InoDB引擎特点</p><ol><li>事务型存储引擎支持ACID</li><li>数据按主键聚集存储: 按照主键顺序存储</li><li>支持行级锁及MVCC(多版本的并发控制)</li><li>支持B树和自适应Hash索引</li><li>支持全文和空间索引</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库开发学习 (1) 数据库概述</title>
      <link href="shu-ju-ku-kai-fa-xue-xi-1-shu-ju-ku-gai-shu/"/>
      <url>shu-ju-ku-kai-fa-xue-xi-1-shu-ju-ku-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-VS-NOSQL"><a href="#SQL-VS-NOSQL" class="headerlink" title="SQL VS NOSQL"></a>SQL VS NOSQL</h1><p>SQL主要指的是关系型数据库,主要代表是MySql等</p><p>NOSQL全部指的是Not only SQL,意味着不仅仅使用数据库来存储数据，主要代表是MongoDB</p><h2 id="非关系数据库的特点"><a href="#非关系数据库的特点" class="headerlink" title="非关系数据库的特点"></a>非关系数据库的特点</h2><ol><li><p>存储结构灵活,没有固定的结构</p></li><li><p>在不考虑数据压缩的条件下,占内存大</p></li><li><p>对事物的支持比较弱，但对数据的并发处理性能高</p></li><li><p>大多不适用SQL语言进行操作</p></li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li><p>数据结构不固定的场景</p></li><li><p>对事务要求不高，但读写并发比较大的场景</p></li><li><p>对数据的处理比较简单的场景</p></li></ol><h2 id="关系数据库选型原则"><a href="#关系数据库选型原则" class="headerlink" title="关系数据库选型原则"></a>关系数据库选型原则</h2><ol><li><p>数据库使用的广泛性</p></li><li><p>数据库的可扩展性</p></li><li><p>数据库的安全性和稳定性</p></li><li><p>数据库所支持的系统</p></li><li><p>数据库的使用成本(不仅仅是数据库本身的也有开发人员的)</p></li></ol><h2 id="MySQLs数据库的可扩展性"><a href="#MySQLs数据库的可扩展性" class="headerlink" title="MySQLs数据库的可扩展性"></a>MySQLs数据库的可扩展性</h2><ol><li><p>支持基于二进制日志的逻辑赋值</p></li><li><p>存在多种第三方数据库中间层，支持读写分离及分库分表</p></li></ol><h2 id="MySQL的安全性和稳定性"><a href="#MySQL的安全性和稳定性" class="headerlink" title="MySQL的安全性和稳定性"></a>MySQL的安全性和稳定性</h2><ol><li><p>MySQL主从赋值集群可达到99%的可用性</p></li><li><p>配合主从赋值高可用架构可以达到99.99%的可用性</p></li><li><p>支持对存储在MySql的数据进行分级安全控制</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL- 算法(3) 常用算术生成算法、集合算法</title>
      <link href="stl-suan-fa-3-chang-yong-suan-zhu-sheng-cheng-suan-fa-ji-he-suan-fa/"/>
      <url>stl-suan-fa-3-chang-yong-suan-zhu-sheng-cheng-suan-fa-ji-he-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="算术生成算法"><a href="#算术生成算法" class="headerlink" title="算术生成算法"></a>算术生成算法</h1><h2 id="accumulate算法"><a href="#accumulate算法" class="headerlink" title="accumulate算法"></a>accumulate算法</h2><p>计算容器元素累计总和</p><pre class="line-numbers language-none"><code class="language-none"># include &lt;numeric&gt;# include &lt;algorithm&gt;T accumulate(iterator beg,iterator end,value)@param beg 开始@param end 结束@param value 累加器@return 其实累加值  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="fill-算法"><a href="#fill-算法" class="headerlink" title="fill 算法"></a>fill 算法</h2><p>向容器中添加元素<br><strong>需要提前resize!!!</strong></p><pre class="line-numbers language-none"><code class="language-none">file(iterator beg,iterator end,value)@param beg@param end@value 填充值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h1><p><strong>使用前记得给目标容器resize()!!!!</strong></p><h2 id="set-intersection算法"><a href="#set-intersection算法" class="headerlink" title="set_intersection算法"></a>set_intersection算法</h2><pre class="line-numbers language-none"><code class="language-none">interator set_intersection(interator beg1,interator end1,interator beg2,interator end2,interator target)交集@param beg1@param end1@param beg2@param end2@param target 目标容器的起始迭代器@return 存放的最后一个元素的迭代器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="set-union算法"><a href="#set-union算法" class="headerlink" title="set_union算法"></a>set_union算法</h2><pre class="line-numbers language-none"><code class="language-none">interator set_union(interator beg1,interator end1,interator beg2,interator end2,interator target)并集@param beg1@param end1@param beg2@param end2@param target 目标容器的起始迭代器@return 存放的最后一个元素的迭代器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="set-difference算法"><a href="#set-difference算法" class="headerlink" title="set_difference算法"></a>set_difference算法</h2><pre class="line-numbers language-none"><code class="language-none">interator set_difference(interator beg1,interator end1,interator beg2,interator end2,interator target)差集@param beg1@param end1@param beg2@param end2@param target 目标容器的起始迭代器@return 存放的最后一个元素的迭代器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author: &gt; Mail: &gt; Created Time: 2020年01月01日 星期三 14时22分05秒 ************************************************************************/# include&lt;iostream&gt;# include &lt;vector&gt;# include &lt;algorithm&gt;# include &lt;iterator&gt;using namespace std;void test01(){    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for(int i=0;i&lt;10;i++)    {        v1.push_back(i);        v2.push_back(i+5);    }    vector&lt;int&gt; vTarget(min(v1.size(),v2.size()));    vector&lt;int&gt;::iterator isEnd=set_intersection(v1.begin(),v1.end(),v2.begin(),v2.end(),vTarget.begin());    copy(vTarget.begin(),isEnd,ostream_iterator&lt;int&gt;(cout," "));    cout&lt;&lt;endl;}int main(){    test01();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://banthink.com/usr/uploads/2020/01/2595755428.jpg" alt="集合.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL- 算法(2) 常用排序、替换算法</title>
      <link href="stl-suan-fa-2-chang-yong-pai-xu-ti-huan-suan-fa/"/>
      <url>stl-suan-fa-2-chang-yong-pai-xu-ti-huan-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h1><h2 id="merge-算法"><a href="#merge-算法" class="headerlink" title="merge 算法"></a>merge 算法</h2><p>容器元素合并，并存储到另一个容器中，这两个容器必须也是有序的<br><strong>目标容器必须resize()!!</strong></p><pre class="line-numbers language-none"><code class="language-none">merge(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator target_beg)@param beg1 开始迭代器1@param end1 结束迭代器1@param beg2 开始迭代器2@param end2 结束迭代器2@param target 目标容器起始迭代器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="sort-算法"><a href="#sort-算法" class="headerlink" title="sort 算法"></a>sort 算法</h2><p>这个算法不知道干嘛的回去背英语吧</p><pre class="line-numbers language-none"><code class="language-none">sort(iterator beg,iterator end)sort(iterator beg,iterator end,_callback) @param beg 开始迭代器@param end 结束迭代器@param _callback 回调函数或者谓词（返回类型bool的函数对象）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="random-shuffle-洗牌算法"><a href="#random-shuffle-洗牌算法" class="headerlink" title="random_shuffle 洗牌算法"></a>random_shuffle 洗牌算法</h2><p>就是重新给数组随机排序</p><p>如果没有使用srand((unsigned int)time(NULL))，每一次运行结束后的结果都是一样的</p><pre class="line-numbers language-none"><code class="language-none">random_shuffle (iterator beg,iterator end)@param beg 开始迭代器@param end 结束迭代器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author: &gt; Mail: &gt; Created Time: 2020年01月01日 星期三 13时51分56秒 ************************************************************************/# include&lt;iostream&gt;# include &lt;algorithm&gt;# include &lt;time.h&gt;# include &lt;vector&gt;using namespace std;void test01(){    vector&lt;int&gt;v;    for(int i=0;i&lt;10;i++)    {        v.push_back(i);    }    srand((unsigned int)(time(NULL)));  //没有这个的话每一次重新运行生成的随即数组都是一样的    random_shuffle(v.begin(),v.end());    for_each(v.begin(),v.end(),[](int val){cout&lt;&lt;val&lt;&lt;"  ";});}int main(){    test01();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://banthink.com/usr/uploads/2020/01/2476081055.jpg" alt="洗牌.jpg"></p><h2 id="reverse-翻转算法"><a href="#reverse-翻转算法" class="headerlink" title="reverse 翻转算法"></a>reverse 翻转算法</h2><p>翻转数组顺序</p><pre class="line-numbers language-none"><code class="language-none">reverse(iterator beg,iterator end)@param beg 开始迭代器@param end 结束迭代器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="常用拷贝替换算法"><a href="#常用拷贝替换算法" class="headerlink" title="常用拷贝替换算法"></a>常用拷贝替换算法</h1><h2 id="copy算法"><a href="#copy算法" class="headerlink" title="copy算法"></a>copy算法</h2><p>将容器内指定范围的元素拷贝到另一容器中<br><strong>目标容器必须resize()!!</strong></p><pre class="line-numbers language-none"><code class="language-none">copy(iterator beg,iterator end,iteartor target_beg)@param beg 开始迭代器@param end 结束迭代器@param target_beg 目标开始迭代器小技巧# include &lt;iterator&gt;copy(iterator beg,iterator end,ostream_iterator&lt;T&gt;) //打印数据 相当于把数据复制到输出流中进行输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="replace-算法"><a href="#replace-算法" class="headerlink" title="replace 算法"></a>replace 算法</h2><pre class="line-numbers language-none"><code class="language-none">replace(iterator beg,iterator end,old_value,new_value)replace_if(iterator beg,iterator end,_callback,value)@param beg 开始迭代器@param end 结束迭代器@param old_value 旧值@param new_value 新值@_callback一元谓词<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="swap算法"><a href="#swap算法" class="headerlink" title="swap算法"></a>swap算法</h2><p>交换两个容器内的元素</p><pre class="line-numbers language-none"><code class="language-none">swap(c1,c2)@param 容器1@param 容器2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL- 算法(1) 概述    常用遍历、查找算法</title>
      <link href="stl-suan-fa-1-gai-shu-chang-yong-bian-li-cha-zhao-suan-fa/"/>
      <url>stl-suan-fa-1-gai-shu-chang-yong-bian-li-cha-zhao-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><p>算法主要是由头文件<algorithm> <functional> <numeric>组成</numeric></functional></algorithm></p><p><algorithm>是所有STL头文件中最大的一个，其中常用的功能涉及到比较、交换、查找、遍历、复制、修改、反转、排序、合并等。</algorithm></p><p><numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数</numeric></p><p><functional>定义了一些模板类，用以声明函数对象</functional></p><h1 id="仿函数、算法、适配器三者关系"><a href="#仿函数、算法、适配器三者关系" class="headerlink" title="仿函数、算法、适配器三者关系"></a>仿函数、算法、适配器三者关系</h1><p>算法常常会和仿函数和适配器一起使用，仿函数用来扩展算法的功能，用一个重载()运算符来修改算法最关键处的功能</p><p>适配器则用来适配算法和仿函数的。</p><p>例如find_if中第三个参数在内部调用的时候只会传递给仿函数1个参数值，但是我们需要使用的仿函数有两个参数，这时候就需要用适配器来适配仿函数。<br><img src="https://banthink.com/usr/uploads/2020/01/32357335.jpg" alt="关系.jpg"></p><h1 id="算法操作自定义数据成员"><a href="#算法操作自定义数据成员" class="headerlink" title="算法操作自定义数据成员"></a>算法操作自定义数据成员</h1><p>容器中的成员为自定义数据类型的时候，需要在类内部对算法的功能模板行为进行重载。<br>例如find算法中的模板行为为==，如果不使用find_if,就需要在类内部对==进行重载</p><h1 id="常用的遍历算法"><a href="#常用的遍历算法" class="headerlink" title="常用的遍历算法"></a>常用的遍历算法</h1><pre class="line-numbers language-none"><code class="language-none">_callback for_each(iterator begin,iterator end,_callback)@param begin 容器开始迭代器 @param end 容器结束迭代器@param _callback 回调函数或者仿函数@return 返回仿函数的对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">transform(iterator beg1,iterator end1,iterator beg2,_callback) @param beg1 源容器开始迭代器 @param end1 源容器结束迭代器@param beg2 目标容器开始迭代器@param _callback 回调函数或者仿函数@return 返回目标容器的迭代器note:将容器中的数据进行搬运到另一个容器中，但是需要给目标空间开辟空间(resize).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author:  遍历算法练习&gt; Mail: &gt; Created Time: 2020年01月01日 星期三 10时24分49秒 ************************************************************************/# include&lt;iostream&gt;# include &lt;algorithm&gt;# include &lt;vector&gt;# include &lt;functional&gt;using namespace std;struct myPrint  //和class的区别是成员访问权限{    void operator()(int num)    {        cout&lt;&lt;num&lt;&lt;"  ";    }};//for_each代码示例void test01(){    vector&lt;int&gt; v;    for(int i=0;i&lt;10;i++)    {        v.push_back(i);    }    for_each(v.begin(),v.end(),myPrint());    cout&lt;&lt;endl;}struct myPrint02  //和class的区别是成员访问权限{    int m_cout=0;    void operator()(int num)    {        cout&lt;&lt;num&lt;&lt;"  ";        m_cout++;    }};void test02(){    vector&lt;int&gt; v;    for(int i=0;i&lt;10;i++)    {        v.push_back(i);    }    myPrint02 my=for_each(v.begin(),v.end(),myPrint02());    cout&lt;&lt;endl;    cout&lt;&lt;my.m_cout&lt;&lt;endl;}struct myPrint03:public binary_function&lt;int,int,void&gt; //和class的区别是成员访问权限{    void operator()(int num,int start)const     {        cout&lt;&lt;num+start&lt;&lt;"  ";    }};void test03(){    vector&lt;int&gt; v;    for(int i=0;i&lt;10;i++)    {        v.push_back(i);    }    for_each(v.begin(),v.end(),bind2nd(myPrint03(),100));    cout&lt;&lt;endl;}/********TransForm*******************/class TransForm04{    public:        int operator()(int val)    {        return val+48;    }};void test04(){    vector&lt;int&gt; v;    for(int i=0;i&lt;10;i++)    {        v.push_back(i);    }    vector&lt;int&gt;Target;    Target.resize(v.size());    transform(v.begin(),v.end(),Target.begin(),TransForm04());    for_each(Target.begin(),Target.end(),[](int val){cout&lt;&lt; val &lt;&lt;" ";});    }class TransForm05{    public:        int operator()(int val,int start)    {        return val+start;    }};void test05()  //两数相加{    vector&lt;int&gt;v1;    vector&lt;int&gt;v2;    for(int i=0;i&lt;10;i++)    {        v1.push_back(i);        v2.push_back(i);    }    vector&lt;int&gt;Target;    Target.resize(v1.size());    transform(v1.begin(),v1.end(),v2.begin(),Target.begin(),TransForm05());    for_each(v1.begin(),v1.end(),[](int v){cout&lt;&lt;v&lt;&lt;" ";});    cout&lt;&lt;endl;    for_each(v2.begin(),v2.end(),[](int v){cout&lt;&lt;v&lt;&lt;" ";});    cout&lt;&lt;endl;    for_each(Target.begin(),Target.end(),[](int v){cout&lt;&lt;v&lt;&lt;" ";});    cout&lt;&lt;endl;    }int main(){    test05();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>for_each:test01测试<br><img src="https://banthink.com/usr/uploads/2020/01/1913938440.jpg" alt="for_each.jpg"></p><p>transform:test05测试<br><img src="https://banthink.com/usr/uploads/2020/01/2064801578.jpg" alt="transform.jpg"></p><h1 id="常用的查找算法"><a href="#常用的查找算法" class="headerlink" title="常用的查找算法"></a>常用的查找算法</h1><h2 id="find查找元素"><a href="#find查找元素" class="headerlink" title="find查找元素"></a>find查找元素</h2><p>如果是自定义的数据类型，那么需要在类里面重载==.</p><pre class="line-numbers language-none"><code class="language-none">iterator find(iterator beg,iterator end,T)@param beg 容器开始迭代器@param end 容器结束迭代器@param value 查找的元素@return 返回查找元素的位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">iterator find_if(iterator beg,iterator end,_callback)@param beg 容器开始迭代器@param end 容器结束迭代器@param _callback 回调函数或者一元谓词（返回bool类型的函数对象）@return 返回查找元素的位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="count计算元素出现个数"><a href="#count计算元素出现个数" class="headerlink" title="count计算元素出现个数"></a>count计算元素出现个数</h2><pre class="line-numbers language-none"><code class="language-none">int count(iterator beg,iterator end,value)@param beg 容器开始迭代器@param end 容器结束迭代器@param value 查找的元素@return 返回元素出现的次数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">int count_if(iterator beg,iterator end,_callback)按照条件计算元素出现的次数@param beg 容器开始迭代器@param end 容器结束迭代器@param _callback 回调函数或者谓词@return 返回元素出现的次数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="adjacent-find找到相邻重复元素的第一个位置"><a href="#adjacent-find找到相邻重复元素的第一个位置" class="headerlink" title="adjacent_find找到相邻重复元素的第一个位置"></a>adjacent_find找到相邻重复元素的第一个位置</h2><pre class="line-numbers language-none"><code class="language-none">iterator adjacent_find(iterator beg,iterator end)iterator adjacent_find (iterator beg,iterator end,BinaryPredicate pred);@param beg 容器开始迭代器@param end 容器结束迭代器@param BinaryPredicate 回调函数或者一元谓词（返回bool类型的函数对象）@return 返回相邻重复元素的第一个位置的迭代器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="binary-search-二分查找"><a href="#binary-search-二分查找" class="headerlink" title="binary_search  二分查找"></a>binary_search  二分查找</h2><pre class="line-numbers language-none"><code class="language-none">bool binary_search(iterator beg,iterator end,value)bool binary_search (iterator beg,iterator end,value, Compare comp);二分查找法  只能用于**有序序列**!!!需要用随机迭代器该功能模板的行为等效于：operator&lt;@param beg 容器开始迭代器@param end 容器结束迭代器@param value 查找的元素@param Compare bool(*)(T,T)的回调函数或者二元谓词@return 返回true或者false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author: &gt; Mail: &gt; Created Time: 2020年01月01日 星期三 11时28分40秒 ************************************************************************/# include &lt;string&gt;# include &lt;vector&gt;# include &lt;algorithm&gt;# include&lt;iostream&gt;using namespace std;class Person{    public:        Person(string name,int age)    {        m_name=name;        m_age=age;    }        bool operator==(const Person &amp;p)    {        if(m_name==p.m_name&amp;&amp;m_age==p.m_age)            return true;        else            return false;         }    string getName()    {return m_name;}    int getAge()    {        return m_age;    }    private:    string m_name;    int m_age;};void test01(){    vector&lt;Person&gt; v;    Person p1("aaala",10);    Person p2("askldj",20);    Person p3("aldkj",30);    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    if(find(v.begin(),v.end(),p2)!=v.end())    {        cout&lt;&lt;"找到了"&lt;&lt;endl;    }}class MyCompare:public binary_function&lt;Person *,Person *,bool&gt;{    public:        bool operator()(Person *p1,Person *p2)const    {        if(p1-&gt;getName()==p2-&gt;getName()&amp;&amp;p1-&gt;getAge()==p2-&gt;getAge())            return true;        else            return false;    }};void test02(){    vector&lt;Person *&gt; v;    Person p1("aaala",10);    Person p2("askldj",20);    Person p3("aldkj",30);    v.push_back(&amp;p1);    v.push_back(&amp;p2);    v.push_back(&amp;p3);    Person *p=new Person("basd",20);    if(find_if(v.begin(),v.end(),bind2nd(MyCompare(),p))!=v.begin())    {        cout&lt;&lt;"找到了"&lt;&lt;endl;    }}void test03(){    vector&lt;int&gt; v;    v.push_back(2);    v.push_back(3);    v.push_back(4);    v.push_back(5);    v.push_back(5);    v.push_back(6);    v.push_back(2);    vector&lt;int&gt;::iterator pos=adjacent_find(v.begin(),v.end());    if(pos!=v.end())    {        cout&lt;&lt;"找到了相邻重复元素"&lt;&lt;*pos&lt;&lt;endl;    }       }void test04(){     vector&lt;int&gt; v;    for(int i=0;i&lt;10;i++)    {        v.push_back(i);    }    if(binary_search(v.begin(),v.end(),4))    {        cout&lt;&lt;"找到4"&lt;&lt;endl;    }else        cout&lt;&lt;"找不到"&lt;&lt;endl;      }void int main(){    test02();    test03();    test04();    test05();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="官网的二分查找例子"><a href="#官网的二分查找例子" class="headerlink" title="官网的二分查找例子"></a>官网的二分查找例子</h3><pre class="line-numbers language-none"><code class="language-none">// binary_search example# include &lt;iostream&gt;     // std::cout# include &lt;algorithm&gt;    // std::binary_search, std::sort# include &lt;vector&gt;       // std::vectorbool myfunction (int i,int j) { return (i&lt;j); }int main () {  int myints[] = {1,2,3,4,5,4,3,2,1};  std::vector&lt;int&gt; v(myints,myints+9);                         // 1 2 3 4 5 4 3 2 1  // using default comparison:  std::sort (v.begin(), v.end());  std::cout &lt;&lt; "looking for a 3... ";  if (std::binary_search (v.begin(), v.end(), 3))    std::cout &lt;&lt; "found!\n"; else std::cout &lt;&lt; "not found.\n";  // using myfunction as comp:  std::sort (v.begin(), v.end(), myfunction);  std::cout &lt;&lt; "looking for a 6... ";  if (std::binary_search (v.begin(), v.end(), 6, myfunction))    std::cout &lt;&lt; "found!\n"; else std::cout &lt;&lt; "not found.\n";  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://banthink.com/usr/uploads/2020/01/3223814137.jpg" alt="二分查找.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题（致敬跨年）单词拆分</title>
      <link href="leetcode-shua-ti-zhi-jing-kua-nian-dan-ci-chai-fen/"/>
      <url>leetcode-shua-ti-zhi-jing-kua-nian-dan-ci-chai-fen/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://banthink.com/usr/uploads/2019/12/1868086670.png" alt="Lily_Screenshot_1577802966.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>class Solution {<br>public:<br>    bool wordBreak(string s, vector<string>&amp; wordDict) {<br>        if(s.empty()||wordDict.empty())<br>            return false;<br>        int n=s.size();<br>        vector<bool> dp(n+1,false);  //表示到第n个字符为止  s是否能被字典拆分<br>        dp[0]=true;<br>        for(int i=0;i&lt;=n;i++)<br>        {<br>            for(auto word:wordDict)<br>            {<br>                int ws = word.size();<br>                if(i - ws &gt;= 0) {<br>                    if (!s.compare(i-ws, ws, word)&amp;&amp;dp[i-ws]) {<br>                        dp[i] = true;<br>                        break;<br>                    }</bool></string></p><pre><code>            }        }       }    //从开始到是否在这里面    return dp[n];}</code></pre><p>};</p><h3 id="2019-12-31不优化了不优化了-这代码留作以后修改吧"><a href="#2019-12-31不优化了不优化了-这代码留作以后修改吧" class="headerlink" title="2019.12.31不优化了不优化了 这代码留作以后修改吧"></a>2019.12.31不优化了不优化了 这代码留作以后修改吧</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL -函数适配器</title>
      <link href="stl-han-shu-gua-pei-qi/"/>
      <url>stl-han-shu-gua-pei-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><p>一种用来修饰容器或者仿函数或迭代器接口的东西</p><h3 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h3><p>使用步骤</p><ol><li><p>继承binary_function&lt;参数1,参数2,…,返回值&gt;</p></li><li><p>加上const修饰operator</p></li><li><p>bind1st/bind2nd 绑定数据</p></li></ol><h4 id="bind1st-和bind2nd区别"><a href="#bind1st-和bind2nd区别" class="headerlink" title="bind1st 和bind2nd区别"></a>bind1st 和bind2nd区别</h4><p>对于绑定的数据而言，bind2nd按照顺序绑定，bind1st逆序绑定</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author: &gt; Mail: &gt; Created Time: 2019年12月31日 星期二 17时28分07秒 ************************************************************************/# include&lt;iostream&gt;# include &lt;string&gt;# include &lt;vector&gt;# include &lt;algorithm&gt;# include &lt;functional&gt;using namespace std;class MyPrint:public binary_function&lt;int,int,void&gt;  //operator的参数1，参数2，返回类型{    public:    void operator()(int v,int start) const     {        cout&lt;&lt; "v="&lt;&lt;v&lt;&lt; "  start ="&lt;&lt;start&lt;&lt;"  start+v = "&lt;&lt;start+v&lt;&lt;endl;    }};void test01(){    vector&lt;int&gt; v;    for(int i=0;i&lt;10;i++)        v.push_back(i);    for_each(v.begin(),v.end(),[](int n){cout&lt;&lt;n&lt;&lt;" ";});    cout&lt;&lt;endl;    int num;    cout&lt;&lt;"请输入:";    cin&gt;&gt;num;    //第一步  绑定数据 bind2nd    //继承 binary_function&lt;参数1,参数2,返回类型&gt;    //添加const修饰 operator()    for_each(v.begin(),v.end(),bind2nd(MyPrint(),num));    cout&lt;&lt;"bind1st"&lt;&lt;endl;    for_each(v.begin(),v.end(),bind1st(MyPrint(),num));}int main(){    test01();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://banthink.com/usr/uploads/2019/12/986781248.jpg" alt="函数适配器.jpg"></p><h3 id="取反适配器"><a href="#取反适配器" class="headerlink" title="取反适配器"></a>取反适配器</h3><p>not1 一元函数适配器 : 修饰参数个数为1的函数</p><p>not2 二元函数适配器 ：修饰参数个数为2的函数</p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol><li>继承unary_function&lt;参数1,bool&gt;  </li><li>加上const修饰operator</li><li><strong>not1</strong> 绑定数据</li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author: &gt; Mail: &gt; Created Time: 2019年12月31日 星期二 17时28分07秒 ************************************************************************/# include&lt;iostream&gt;# include &lt;string&gt;# include &lt;vector&gt;# include &lt;algorithm&gt;# include &lt;functional&gt;using namespace std;//取反适配器class greaterThenFIve: public unary_function&lt;int,bool&gt;  //继承unary_function{    public:        bool operator()(int val)const     {        return val&gt;5;    }};void test01(){    vector&lt;int&gt; v;    for(int i=0;i&lt;10;i++)        v.push_back(i);        vector&lt;int&gt;::iterator pos=find_if(v.begin(),v.end(),not1(greaterThenFIve()));    if(pos!=v.end())    {        cout&lt;&lt;"找到了"&lt;&lt;*pos&lt;&lt;endl;    }}int main(){   test01();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://banthink.com/usr/uploads/2019/12/2976410075.bmp" alt="取反适配器.bmp"></p><h3 id="函数指针适配器"><a href="#函数指针适配器" class="headerlink" title="函数指针适配器"></a>函数指针适配器</h3><p>ptr_fun：将普通函数适配为仿函数</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author: &gt; Mail: &gt; Created Time: 2019年12月31日 星期二 17时28分07秒 ************************************************************************/# include&lt;iostream&gt;# include &lt;string&gt;# include &lt;vector&gt;# include &lt;algorithm&gt;# include &lt;functional&gt;using namespace std;//函数指针适配器void MyPrintrint03(int v,int start){    cout&lt;&lt;v+start &lt;&lt;"  ";}void test01(){    vector&lt;int&gt; v;    for(int i=0;i&lt;10;i++)        v.push_back(i);    //将函数指针适配为函数对象    for_each(v.begin(),v.end(),bind2nd(ptr_fun(MyPrintrint03),100));}int main(){    test01();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://banthink.com/usr/uploads/2019/12/385808776.bmp" alt="函数指针适配器.bmp"></p><h3 id="成员函数适配器"><a href="#成员函数适配器" class="headerlink" title="成员函数适配器"></a>成员函数适配器</h3><p>如果容器中存放的是对象指针 使用的是mem_fun</p><p>如果容器中存放的是对象，则使用mem_fun_ref </p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author: &gt; Mail: &gt; Created Time: 2019年12月31日 星期二 17时28分07秒 ************************************************************************/# include&lt;iostream&gt;# include &lt;string&gt;# include &lt;vector&gt;# include &lt;algorithm&gt;# include &lt;functional&gt;using namespace std;class Person{    public:      Person(string name,int age)    {        m_name=name;        m_age=age;    }    void showPerson()    {    cout&lt;&lt;"姓名:"&lt;&lt;m_name&lt;&lt;"   年龄: "&lt;&lt;m_age&lt;&lt;endl;    }    void PlugAge(int val)    {       m_age+=val;    }    private:       string  m_name;       int m_age;};void test01(){        vector&lt;Person&gt; v;    Person v1("aaaa",10);    Person v2("sdsdsd",20);    v.push_back(v1);    v.push_back(v2);    //成员函数适配器mem_fun_ref    for_each(v.begin(),v.end(),mem_fun_ref(&amp;Person::showPerson));    }int main(){    test01();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://banthink.com/usr/uploads/2019/12/195271099.bmp" alt="成员函数适配器.bmp"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL -函数对象</title>
      <link href="stl-han-shu-dui-xiang/"/>
      <url>stl-han-shu-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>重载函数调用操作符的类，其对象常称为函数对象，即他们是行为类似函数的对象，也叫仿函数，其实就是重载”()”操作符，使得类对象可以像函数一样调用。</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ol><li>函数对象是一个类，不是一个函数</li><li>函数对象（仿函数）重载了”()” 操作符使得它可以像函数一样调用<br>分类：假定某个类有一个重载的operator()，而且重载的operator()要求获取一个参数，我们就将这个类称为”一元仿函数”(unary functior)，相反，如果重载的operator()要求获取两个参数，就将这个类称为”二元仿函数”（binary functor）</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>STL提供的算法往往都有两个版本，其中一个版本表现出最常用的某种运算，另一个版本则是允许用户通过template参数的形式来指定所要采取的策略。</p><h3 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h3><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author: 仿函数的使用方法&gt; Mail: &gt; Created Time: 2019年12月31日 星期二 16时09分25秒 ************************************************************************/# include&lt;iostream&gt;using namespace std;class MyPrint{    public:    void operator()(int num)    {        cout&lt;&lt;"Here "&lt;&lt;count++&lt;&lt;" is MyPrint:"&lt;&lt;num&lt;&lt;endl;    }    private:        int count=0; //保存内部状态};//函数对象作为参数void test01(){    cout&lt;&lt;"test01"&lt;&lt;endl;    MyPrint myPrint;    myPrint(10);    myPrint(10);    myPrint(10);    myPrint(10);}void doPrint(MyPrint print,int num){    cout&lt;&lt;"doPrint:";    print(num);}int main(){    test01();    MyPrint()(1234); //匿名对象的调用方式     doPrint(MyPrint(),1001); //传递匿名对象    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://banthink.com/usr/uploads/2019/12/56450607.bmp" alt="仿函数.bmp"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。</li><li>函数对象超出了普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可<strong>内联编译</strong>，性能好，用函数指针几乎不可能</li><li>模板函数对象使函数对象具有通用性，这也是它的优势之一。</li></ol><h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>谓词就是返回值为<strong>bool</strong>的普通函数或者是仿函数，根据参数的个数也有一元谓词和二元谓词.</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author: &gt; Mail: &gt; Created Time: 2019年12月31日 星期二 16时29分35秒 ************************************************************************/# include&lt;iostream&gt;# include &lt;vector&gt;# include &lt;algorithm&gt;using namespace std;//一元谓词class GreaterThen20{    public :bool operator()(const int &amp; val)    {        return val&gt;20;    }};void test01(){    vector&lt;int&gt; v;    v.push_back(10);    v.push_back(20);    v.push_back(30);    v.push_back(40);    //查找第一个大于20的数字    if(find_if(v.begin(),v.end(),GreaterThen20())!=v.end());        cout&lt;&lt;"找到了"&lt;&lt;endl;}//二元谓词class MyCompare{    public :        bool operator()(const int &amp;v1,const int &amp;v2)        { return v1&gt;v2; }};void test02(){    vector&lt;int&gt; v;    v.push_back(10);    v.push_back(20);    v.push_back(30);    v.push_back(40);    sort(v.begin(),v.end(),MyCompare());    //匿名函数 lambda表达式   [](){}    for_each(v.begin(),v.end(),[](int val){cout&lt;&lt;val&lt;&lt;" ";});}int main(){    test01();    test02();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://banthink.com/usr/uploads/2019/12/1068222699.bmp" alt="谓词.bmp"></p><h2 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h2><p>STL内建了一些函数对象，分为算术类函数对象，关系运算类函数对象，逻辑运算类仿函数。这些仿函数所产生的对象，用发货一般函数完全相同，当然我们还可以产生无名的临时对象来履行函数功能。使用内建函数对象需要引入头文件# include <functional></functional></p><h3 id="6个算术类函数对象，除了negate是一元运算，其他都是二元运算"><a href="#6个算术类函数对象，除了negate是一元运算，其他都是二元运算" class="headerlink" title="6个算术类函数对象，除了negate是一元运算，其他都是二元运算"></a>6个算术类函数对象，除了negate是一元运算，其他都是二元运算</h3><pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt; T plus&lt;T&gt; //加法仿函数template&lt;class T&gt; T minius&lt;t&gt; //加法仿函数template&lt;class T&gt; T multiplies&lt;T&gt; //乘法仿函数template&lt;class T&gt; T divides&lt;T&gt; //除法仿函数template&lt;class T&gt; T modulus&lt;T&gt; //取模仿函数template&lt;class T&gt; T negate&lt;T&gt; //取反仿函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6个关系运算类函数对象，每一种都是二元谓词"><a href="#6个关系运算类函数对象，每一种都是二元谓词" class="headerlink" title="6个关系运算类函数对象，每一种都是二元谓词"></a>6个关系运算类函数对象，每一种都是二元谓词</h3><pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt; bool equal_to&lt;T&gt;  //等于template&lt;class T&gt; bool not_equal_to&lt;T&gt; //不等于template&lt;class T&gt; bool greater&lt;T&gt; //大于template&lt;class T&gt; bool greater_equal&lt;T&gt; //大于等于template&lt;class T&gt; bool less&lt;T&gt; //小于template&lt;class T&gt; bool less_equal&lt;T&gt; //小于等于<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="逻辑运算类运算函数，not为一元谓词，其余都是二元谓词"><a href="#逻辑运算类运算函数，not为一元谓词，其余都是二元谓词" class="headerlink" title="逻辑运算类运算函数，not为一元谓词，其余都是二元谓词"></a>逻辑运算类运算函数，not为一元谓词，其余都是二元谓词</h3><pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt; bool logical_and&lt;T&gt; //逻辑与template&lt;class T&gt; bool logical_ro&lt;T&gt; //逻辑或template&lt;class T&gt; bool logical_not&lt;T&gt; //逻辑非<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author: 内建函数对象&gt; Mail: &gt; Created Time: 2019年12月31日 星期二 16时46分37秒 ************************************************************************/# include &lt;vector&gt;# include&lt;iostream&gt;# include &lt;functional&gt;# include &lt;algorithm&gt;using namespace std;void test01(){        negate&lt;int&gt; n; //取反    cout&lt;&lt;"negate:"&lt;&lt;n(10)&lt;&lt;endl;        plus&lt;int&gt; p;    cout&lt;&lt;"plus: "&lt;&lt;p(1,1)&lt;&lt;endl;}void test02(){    vector&lt;int&gt; v;    v.push_back(10);    v.push_back(20);    v.push_back(30);    sort(v.begin(),v.end(),greater&lt;int&gt;());    for_each(v.begin(),v.end(),[](int val){cout&lt;&lt;val&lt;&lt;" ";});    }int main(){    test01();    test02();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://banthink.com/usr/uploads/2019/12/1516233190.bmp" alt="内建函数对象.bmp"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>优先队列（堆）  最大堆和最小堆的实现</title>
      <link href="you-xian-dui-lie-dui-zui-da-dui-he-zui-xiao-dui-de-shi-xian/"/>
      <url>you-xian-dui-lie-dui-zui-da-dui-he-zui-xiao-dui-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>实现的实例：Heap(Binary,Binomial,Fibonacci)  堆</p><pre><code> Binary Search Tree  二叉搜索树</code></pre><p>小顶堆Mini Heap：优先级越小排在越前面,最小元素永远在堆顶,父亲节点永远比孩子节点的值小。</p><p>大顶堆和小顶堆相反</p><p> 维基百科: <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">https://en.wikipedia.org/wiki/Heap_(data_structure)</a></p><blockquote><p><img src="https://banthink.com/usr/uploads/2020/01/751333879.jpg" alt="堆.jpg"></p></blockquote><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆数据结构是一种数组对象，它可以被视为一棵完全二叉树结构，所以堆也叫做二叉堆。</p><p>二叉堆满足二个特性</p><p>1．父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</p><p>2．每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。</p><p>  当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆。当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆。</p><p>  最大堆和最小堆是堆数据结构的重点。堆排序中使用特别的多。</p><p> 堆的存储一般是用<strong>一个数组</strong>实现的，当然也可以用链式存储，但是特别麻烦。</p><p>  如下我们给出一个数组：</p><p>  int* Arry={10,16,18,12,11,13,15,17,14,19};</p><p>  现在我们要根据这个数组来建一个不是真正意义上的堆。</p><p>![wKioL1ch54ywVY67AABUJkAuhV4460.png](<a href="https://banthink.com/usr/uploads/2020/01/2456747625.png">https://banthink.com/usr/uploads/2020/01/2456747625.png</a><br>  [3<a href="https://banthink.com/usr/uploads/2020/01/3581248579.jpg">https://banthink.com/usr/uploads/2020/01/3581248579.jpg</a>)</p><p> 现在的堆并不是真正的堆，它不满足最大堆或者最小堆，所以它是无意义的，我们要调整这个“堆”让它变成最大堆或者最小堆，这一步操作就是调整堆。</p><h2 id="调整堆"><a href="#调整堆" class="headerlink" title="调整堆"></a>调整堆</h2><p>首先我们要明确调整堆的目的就是让整棵树中的双亲节点都大于孩子节点（这里以最大堆为例）所以我们要从叶子结点开始调整，直到调整到根节点结束，可能调整好这棵树后，子树又不符合最大堆规则，转而调整子树，所以我们把这种方式叫下调（AdjustDown）,下调主要的目的是为了将不符合条件的父节点向下调整</p><pre class="line-numbers language-none"><code class="language-none"># pragma once# include&lt;iostream&gt;# include&lt;vector&gt;# include&lt;assert.h&gt;using namespace std;template&lt;class T&gt;struct Less{bool operator()(const T&amp; l, const T&amp; r){return l &lt; r;}};template&lt;class T&gt;struct Greater{bool operator()(const T&amp; l, const T&amp; r){return l &gt; r;}};template&lt;class T,template&lt;class&gt; class Continer&gt;class Heap{    public:        Heap(){};        Heap(const T* a,size_t size,Continer&lt;T&gt; con=Greater&lt;T&gt;());        Heap(const vector&lt;T&gt; &amp;v);        void Push(const T&amp;x);        T Pop();        T &amp;GetTop(){return _a.back();}        bool Empty(){return _a.empty();}        vector&lt;T&gt; getArray(){return _a;}        size_t size(){return _a.size();}        vector&lt;T&gt; sort();    protected:        void _AdjustDown(size_t parent,size_t size);  //下调        void _AdjustUp(size_t child);  //上调    protected:        vector&lt;T&gt; _a;        Continer&lt;T&gt; _con;};template&lt;class T, template&lt;class&gt; class Continer&gt;Heap&lt;T,Continer&gt;::Heap(const T* a,size_t size ,Continer&lt;T&gt; con){_a.reserve(size);for (size_t i = 0; i &lt; size; ++i){_a.push_back(a[i]);}//建堆for (int i = (_a.size() - 2) / 2; i &gt;= 0; i--)   //记住 i=(a.size()-2)/2这个公式//从第一个非叶子结点开始下调，叶子结点可以看作是一个大堆或小堆{_AdjustDown(i);}}template&lt;class T, template&lt;class&gt; class Continer &gt;void Heap&lt;T,Continer&gt;::_AdjustDown(size_t parent){size_t child = parent * 2 + 1;size_t size = _a.size();while (child &lt; size)  //避免数组访问越界{      //遍历子树if (child + 1 &lt; size&amp;&amp;_con(_a[child+1],_a[child]))//比较左右孩子  第一个判断是否存在右孩子  第二个比较左右孩子++child;if (_con(_a[child],_a[parent])){swap(_a[parent], _a[child]);  //交换父子节点parent = child;   //接下来将孩子节点的位置作为父亲节点,比较孩子节点下面的子树child = parent * 2 + 1;   //公式}elsebreak;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  在这里是使用的类去封装堆结构，并且用了仿函数的方式去复用最大堆和最小堆的代码。在这里默认把堆调整为最大堆。</p><p> 以下是堆的调用：</p><pre><code>int array[] = { 10, 16, 18, 12, 11, 13, 15, 17, 14, 19 };size_t size = sizeof(array) / sizeof(int);Heap&lt;int,Greater&gt; h(array, size, Greater&lt;int&gt;());//因为默认为大顶堆，所以可以省略Greater</code></pre><p>  我们的调整堆的操作是从二叉树的第一个非叶子结点开始调整。有的读者会问为什么不从最后一个结点调整呢？因为所有叶子结点我们都可以看作一个最大堆或者最小堆，我们完全不需要去调整。</p><p> 要调整为一个最小堆的话只要修改一下调用即可：</p><pre><code>int array[] = { 10, 16, 18, 12, 11, 13, 15, 17, 14, 19 };size_t size = sizeof(array) / sizeof(int);Heap&lt;int，Less&gt; h1(array, size, Less&lt;int&gt;());</code></pre><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>   Push操作：向堆中插入一个数据，也就是往数组中插入一个数据，插入数据以后一般都不是最大堆（最小堆），我们得去调整。</p><p> 上调（AdjustUP）：把新插入的结点大于（小于）双亲节点则往上调，直到满足最大堆（最小堆）。</p><pre class="line-numbers language-none"><code class="language-none">template&lt;class T, template&lt;class&gt; class Continer&gt;void Heap&lt;T, Continer&gt;::Push(const T&amp; x){_a.push_back(x);_AdjustUp(_a.size() - 1);}template&lt;class T, template&lt;class&gt; class Continer &gt;void Heap&lt;T, Continer&gt;::_AdjustUp(size_t child)  //上调{size_t parent = (child - 1) / 2;  //获取数组中父亲节点的位置while (child &gt; 0){if (_con(_a[child] , _a[parent])){swap(_a[child], _a[parent]);child = parent;parent = (child - 1) / 2;}elsebreak;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除最大堆（最小堆）中的根结点"><a href="#删除最大堆（最小堆）中的根结点" class="headerlink" title="删除最大堆（最小堆）中的根结点"></a>删除最大堆（最小堆）中的根结点</h2><p>  我们把根节点删除以后剩下的结点就不构成一棵树结构了，所以我们可以换一种思路让堆保持原来的结构。</p><p>  方法就是把根节点和最后一个结点交换，删除最后一个结点，这样就不会破环结构了。</p><p>  把结点删除后，堆肯定不满足最大堆（最小堆）了，所以我们还要调整堆。这次我们要从根节点往叶子结点调，这样很快，因为原来的堆根节点的左右子树都已经满足大小堆了。利用下调来调整：</p><pre class="line-numbers language-none"><code class="language-none">template&lt;class T, template&lt;class&gt; class Continer &gt;void Heap&lt;T, Continer&gt;::Pop(){assert(!_a.empty());size_t size = _a.size();swap(_a[0], _a[size - 1]);_a.pop_back();_AdjustDown(0);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="排序输出"><a href="#排序输出" class="headerlink" title="排序输出"></a>排序输出</h2><p>固定一个最大值，将剩余的数用下调再构造成一个大根堆（元素下降），直到剩余元素为空的时候，数组排序结束。</p><pre class="line-numbers language-none"><code class="language-none">template&lt;class T,template&lt;class&gt; class Continer&gt;vector&lt;T&gt; Heap&lt;T,Continer&gt;::sort(){    for(int i=size()-1;i&gt;0;i--)  //i一定要是size()-1.因为需要的排序的数组大小为未排序的数组大小(最后一个已经排好序了)    {        swap(_a[0],_a[i]);        _AdjustDown(0,i);    }    return _a;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author:  堆排序&gt; Mail: &gt; Created Time: 2020年01月02日 星期四 12时01分02秒 ************************************************************************/# include&lt;iostream&gt;# include &lt;algorithm&gt;# include &lt;assert.h&gt;# include &lt;vector&gt;using namespace std;template&lt;class T&gt;struct less{    bool operator()(const T &amp;l,const T &amp;r)    {        return l&lt;r;    }};template&lt;class T&gt;struct Greater{    bool operator()(const T &amp;l,const T &amp;r)    {        return l&gt;r;    }};template&lt;class T,template&lt;class&gt; class Continer&gt;class Heap{    public:        Heap(){};        Heap(const T* a,size_t size,Continer&lt;T&gt; con=Greater&lt;T&gt;());        Heap(const vector&lt;T&gt; &amp;v);        void Push(const T&amp;x);        T Pop();        T &amp;GetTop(){return _a.back();}        bool Empty(){return _a.empty();}        vector&lt;T&gt; getArray(){return _a;}        size_t size(){return _a.size();}        vector&lt;T&gt; sort();    protected:        void _AdjustDown(size_t parent,size_t size);        void _AdjustUp(size_t child);    protected:        vector&lt;T&gt; _a;        Continer&lt;T&gt; _con;};template&lt;class T,template&lt;class&gt; class Continer&gt;Heap&lt;T,Continer&gt;::Heap(const T * a,size_t size,Continer&lt;T&gt; con){    _a.reserve(size);    for(size_t i=0;i&lt;size;i++)    {        _a.push_back(a[i]);    }    for(int i=(_a.size()-2)/2;i&gt;=0;i--)    {        _AdjustDown(i,size);    }}template&lt;class T,template&lt;class&gt; class Continer&gt;void Heap&lt;T,Continer&gt;::_AdjustDown(size_t parent,size_t size){    size_t child=parent * 2+1;    while(child&lt;size)    {        if(child+1&lt;size&amp;&amp; _con(_a[child+1],_a[child]))        {            ++child;        }        if(_con(_a[child],_a[parent]))        {            swap(_a[parent],_a[child]);            parent=child;            child=parent *2 +1;       }else            break;    }}template &lt;class T,template&lt;class&gt; class Continer&gt;void Heap&lt;T,Continer&gt;::Push(const T &amp; x){    _a.push_back(x);    _AdjustUp(_a.size()-1);}template &lt;class T,template&lt;class&gt; class Continer&gt;void Heap&lt;T,Continer&gt;::_AdjustUp(size_t child){    size_t parent=(child -1)/2;    while(child&gt;0)    {        if(_con(_a[child],_a[parent]))        {            swap(_a[child],_a[parent]);            child=parent;            parent=(child-1)/2;                }else{            break;        }    }}template&lt;class T,template&lt;class&gt; class Continer&gt;T Heap&lt;T,Continer&gt;::Pop(){    T temp;    assert(!_a.empty());    size_t size=_a.size();    swap(_a[0],_a[size-1]);    temp=_a.back();    _a.pop_back();    _AdjustDown(0,size);    return temp;}template&lt;class T,template&lt;class&gt; class Continer&gt;vector&lt;T&gt; Heap&lt;T,Continer&gt;::sort(){    for(int i=size()-1;i&gt;0;i--)    {        swap(_a[0],_a[i]);        _AdjustDown(0,i);    }    return _a;}int main(){    int array[]={10,16,18,12,11,13,15,17,14,19};    Heap&lt;int,Greater&gt; h(array,sizeof(array)/sizeof(int));    cout&lt;&lt;"大顶堆"&lt;&lt;endl;    vector&lt;int&gt; v1=h.getArray();    for_each(v1.begin(),v1.end(),[](int val){cout&lt;&lt;val&lt;&lt;" ";});    cout&lt;&lt;endl;    cout&lt;&lt;"排序后的数组"&lt;&lt;endl;    vector&lt;int&gt; v=h.sort();    for_each(v.begin(),v.end(),[](int val){cout&lt;&lt;val&lt;&lt;" ";});    cout&lt;&lt;endl;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>![堆排序.jpg][3]</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  堆和栈是计算机内存最常用的结构。</p><p>  有了最大堆和最小堆，我们可以利用他们的特性来实现堆排序。</p><p>  数组构建堆最重要的还是将数组下标转换为对应的父节、子节点。最后一个有叶子节点的父节点的下标为(size-2)/2</p><p>大部分转载自<a href="https://blog.51cto.com/helloleex/1768758">https://blog.51cto.com/helloleex/1768758</a> 稻草阳光L</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL -容器 &amp;lt;map&amp;gt; 相关API及原理</title>
      <link href="stl-rong-qi-lt-map-gt-xiang-guan-api-ji-yuan-li/"/>
      <url>stl-rong-qi-lt-map-gt-xiang-guan-api-ji-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="Map容器概念"><a href="#Map容器概念" class="headerlink" title="Map容器概念"></a>Map容器概念</h2><p>Map的特性是，所有元素都会根据元素的键值自动排序。Map所有的元素都是pair，同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素具有相同的键值</p><p>我们可以通过map的迭代器改变map的键值吗？答案是不行的，因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织，如果想要改变元素的实值，那么是可以的</p><p>map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外</p><p>multimap和map操作类似，唯一区别是multimap键值可以重复。</p><p><strong>map和multimap都是以红黑树为底层实现机制</strong></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre class="line-numbers language-none"><code class="language-none">map&lt;T1,T2&gt;  默认构造map(const map &amp;mp) //拷贝构造<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="插入数据操作-返回值为pair-lt-iterator-bool-gt"><a href="#插入数据操作-返回值为pair-lt-iterator-bool-gt" class="headerlink" title="插入数据操作(返回值为pair<iterator,bool>)"></a>插入数据操作(返回值为pair&lt;iterator,bool&gt;)</h2><pre class="line-numbers language-none"><code class="language-none">map&lt;int,string&gt; mapStu;insert(pair&lt;int,string&gt;(3,"校长"))insert(make_pair(3,"校长"))insert(map&lt;int,string&gt;::value_type(3,"校长"))mapStu[3]="小刘"  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h2><pre class="line-numbers language-none"><code class="language-none">map&amp; operator=(const map &amp;mp);//重载等号操作符swap(map) 交换两个map容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="大小操作"><a href="#大小操作" class="headerlink" title="大小操作"></a>大小操作</h2><pre class="line-numbers language-none"><code class="language-none">size();empty();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><pre class="line-numbers language-none"><code class="language-none">clear()erase(pos)erase(beg,end)erase(keyElem)  //删除容器中key为keyElem的对组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><pre class="line-numbers language-none"><code class="language-none">find(key) //查找键key是否存在，返回改元素的**迭代器**，若不存在则返回set.end()count(key) //查找key的元素个数，对于map而言不是1就是0(因为元素不重复)lower_bound(keyElem) //返回第一个个key&gt;=keyElem元素的迭代器，若不存在则返回set.end()upper_bound(keyElem) //返回第一个key&gt;keyElem元素的迭代器，若不存在则返回set.end()equal_range(keyElem) //返回容量中key与keyElem相等的上下限的两个迭代器(pair 对组类型)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="指定排序规则-用multimap"><a href="#指定排序规则-用multimap" class="headerlink" title="指定排序规则(用multimap)"></a>指定排序规则(用multimap)</h2><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author: 使用自定义数据来简单排序&gt; Mail: &gt; Created Time: 2019年12月30日 星期一 20时07分48秒 ************************************************************************/# include&lt;iostream&gt;# include &lt;string&gt;# include &lt;map&gt;# include &lt;set&gt;using namespace std;class Person{    public:        Person(string m_name,string m_tel,short m_age,int m_momey)    {        name=m_name;        tel=m_tel;        age=m_age;        momey=m_momey;    }           Person(const Person * s)  //这个需要加，不知道为什么，没加编译器不让过，其实也就是个默认拷贝构造函数    {        name=s-&gt;name;        tel=s-&gt;tel;        age=s-&gt;age;        momey=s-&gt;momey;    }        string getName()const {return name;}        string getTel()const {return tel;}        short  getAge()const {return age;}        int getMomey()const {return momey;}    private:        string name;        string tel;        short age;        int momey;        };class PersonCompare{    public:        bool operator ()(const string &amp;p1,const string &amp;p2)    {        return p1&gt;p2;    }};int main(){    multimap&lt;string,Person,PersonCompare&gt; my;    my.insert(make_pair("研发部门",new Person("陈官拜","1350512320",15,10000)));    my.insert(make_pair("研发部门",new Person("王东强","1351232320",25,1000)));    my.insert(make_pair("测试部门",new Person("才陈他","131233120",50,12000)));    my.insert(make_pair("研发部门",new Person("拜jia","1352320",15,18900)));    my.insert(make_pair("业务部门",new Person("ceo","13050",5,103900)));        cout&lt;&lt;"*****全部部门******"&lt;&lt;endl;    for(multimap&lt;string,Person,PersonCompare&gt;::iterator it=my.begin();it!=my.end();it++)    {        cout&lt;&lt;(*it).first&lt;&lt;"  "&lt;&lt;(*it).second.getName()&lt;&lt;"  年收入"&lt;&lt;(*it).second.getMomey()&lt;&lt;endl;    }        cout&lt;&lt;"*****单一******"&lt;&lt;endl;        for(multimap&lt;string,Person,PersonCompare&gt;::iterator it=my.lower_bound("研发部门");           it!=my.upper_bound("研发部门");it++)//这里也可以用equal_range    {        cout&lt;&lt;(*it).first&lt;&lt;(*it).second.getName()&lt;&lt;"  "&lt;&lt;(*it).second.getMomey()&lt;&lt;endl;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：<br><img src="https://banthink.com/usr/uploads/2019/12/1683064439.bmp" alt="map容器.bmp"></p><h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p>lower_bound和upper_boound这两个函数乍一看没什么用，但是其实可以搭配使用得到key相同的迭代器，就像上面代码中写的那<br>样，在multimap中发挥出特殊的用法，lower_bound作为第一个找到相同的键值也就是上限，upper_boound作为第一个不同的键值<br>作为下限，因为在multimap容器中键值的排列是有序的（也就是相同的键值是相邻的）。</p><p>当然，也可以用equal_range快速搞定。在map容器中好像除了end就是唯一的一个迭代器。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL -容器 &amp;lt;set&amp;gt; 相关API及原理</title>
      <link href="stl-rong-qi-lt-set-gt-xiang-guan-api-ji-yuan-li/"/>
      <url>stl-rong-qi-lt-set-gt-xiang-guan-api-ji-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Set容器的基本概念"><a href="#Set容器的基本概念" class="headerlink" title="Set容器的基本概念"></a>Set容器的基本概念</h1><p>  set的特性是：所有的元素都会根据元素的键值自动被排序(对于int来说默认从小到大)。Set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值。Set不允许两个元素有相同的键值</p><p>  Set容器不能通过迭代器改变里面的值，因为set元素值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织，换句话说，set的iterator是一种const_iterator</p><p> set拥有和list某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外。</p><h1 id="multiset容器基本概念"><a href="#multiset容器基本概念" class="headerlink" title="multiset容器基本概念"></a>multiset容器基本概念</h1><p>multiset特性及用法和set完全相同，唯一区别是允许键值重复，底层是用红黑树实现的。</p><h2 id="API函数"><a href="#API函数" class="headerlink" title="API函数"></a>API函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre class="line-numbers language-none"><code class="language-none">set&lt;T&gt; st //默认构造函数 multiset&lt;T&gt; mst set(const set &amp;st)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h3><pre class="line-numbers language-none"><code class="language-none">set &amp;operator =(const set &amp;set); swap(st);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="大小操作"><a href="#大小操作" class="headerlink" title="大小操作"></a>大小操作</h3><pre class="line-numbers language-none"><code class="language-none">size();empty();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="插入和删除操作"><a href="#插入和删除操作" class="headerlink" title="插入和删除操作"></a>插入和删除操作</h3><pre class="line-numbers language-none"><code class="language-none">//没有push_backinsert(T) //在容器中插入元素 返回值为pair&lt;set&lt;T&gt;::iterator ,bool&gt; 可以查看second是否插入成功clear()erase(pos)erase(beg,end)erase(T) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查找操作-返回值都是迭代器，查找不到的内容则返回s-end-结尾迭代器"><a href="#查找操作-返回值都是迭代器，查找不到的内容则返回s-end-结尾迭代器" class="headerlink" title="查找操作(返回值都是迭代器，查找不到的内容则返回s.end() 结尾迭代器)"></a>查找操作(返回值都是迭代器，查找不到的内容则返回s.end() 结尾迭代器)</h3><pre class="line-numbers language-none"><code class="language-none">find(key) //查找键key是否存在，返回改元素的**迭代器**，若不存在则返回set.end()count(key) //查找key的元素个数，对于set而言不是1就是0(因为元素不重复)lower_bound(keyElem) //返回第一个个key&gt;=keyElem元素的迭代器，若不存在则返回set.end()upper_bound(keyElem) //返回第一个key&gt;keyElem元素的迭代器，若不存在则返回set.end()equal_range(keyElem) //返回容量中key与keyElem相等的上下限的两个迭代器(pair 对组类型)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author: equal_range函数的测试&gt; Mail: &gt; Created Time: 2019年12月30日 星期一 15时48分14秒 ************************************************************************/# include&lt;iostream&gt;# include &lt;set&gt;using namespace std;void PrintSet(const set&lt;int&gt; &amp;s){    for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++)    {        cout&lt;&lt;*it&lt;&lt;" ";    }    cout&lt;&lt;endl;}void test01(){    set&lt;int&gt; s;    s.insert(5);    s.insert(2);    s.insert(21);    s.insert(20);    s.insert(55);    s.insert(23);    s.insert(6);    s.insert(0);    PrintSet(s);/*pair对组的两种创建方式pair&lt;string,int&gt;p("Tom",123)pair&lt;string,int&gt;p=make_pair("TOM",123)*/    pair&lt;set&lt;int&gt;::iterator,set&lt;int&gt;::iterator&gt; ret = s.equal_range(2);    if(ret.first!=s.end())    {        cout&lt;&lt;"ret.first"&lt;&lt;*(ret.first)&lt;&lt;endl;    }    if(ret.second!=s.end())    {        cout&lt;&lt;"ret.second"&lt;&lt;*(ret.second)&lt;&lt;endl;     }    //结果会打印2 和 5}int main(){    test01();      return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用仿函数修改set容器排序规则（从大到小）</p><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author: 利用仿函数修改set容器的排序规则 &gt; Mail: &gt; Created Time: 2019年12月30日 星期一 15时48分14秒 ************************************************************************/# include&lt;iostream&gt;# include &lt;set&gt;using namespace std;class myCompare{    public:        bool operator()(int v1,int v2)    {        return v1&gt;v2;    }};void PrintSet(const set&lt;int,myCompare&gt; &amp;s){    for(set&lt;int,myCompare&gt;::iterator it=s.begin();it!=s.end();it++)    {        cout&lt;&lt;*it&lt;&lt;" ";    }    cout&lt;&lt;endl;}void test01(){    set&lt;int,myCompare&gt; s;    s.insert(5);    s.insert(2);    s.insert(21);    s.insert(20);    s.insert(55);    s.insert(23);    s.insert(6);    s.insert(0);    if(s.insert(0).second)    {        cout&lt;&lt;"插入成功"&lt;&lt;endl;    }else        cout&lt;&lt;"插入失败"&lt;&lt;endl;    PrintSet(s);    pair&lt;set&lt;int&gt;::iterator,set&lt;int&gt;::iterator&gt; ret = s.equal_range(2);    if(ret.first!=s.end())    {        cout&lt;&lt;"ret.first"&lt;&lt;*(ret.first)&lt;&lt;endl;    }    if(ret.second!=s.end())    {        cout&lt;&lt;"ret.second"&lt;&lt;*(ret.second)&lt;&lt;endl;    }    }int main(){    test01();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p><img src="https://banthink.com/usr/uploads/2019/12/3887676748.bmp" alt="123.bmp"></p><pre class="line-numbers language-none"><code class="language-none">/*************************************************************************&gt; File Name: main.cpp&gt; Author: 自定义数据类型插入set容器&gt; Mail: &gt; Created Time: 2019年12月30日 星期一 15时48分14秒 ************************************************************************/# include&lt;iostream&gt;# include &lt;set&gt;using namespace std;class Person{    public:        Person(string name,int age)        {            this-&gt;name=name;            this-&gt;age=age;        }        string getName()const {return name;}        int getAge()const {return age;}            private:        string name;        int age;};class myCompare{    public:        bool operator()(const Person &amp; v1,const Person&amp; v2)    {        return v1.getAge()&gt;v2.getAge();    }};void test01(){    set&lt;Person,myCompare&gt; s;    Person s1("王宝强",44);    Person s2("黑色",20);    Person s3("打败",40);    s.insert(s1);    s.insert(s2);    s.insert(s3);    for(set&lt;Person,myCompare&gt;::iterator it=s.begin();it!=s.end();it++)    {        cout&lt;&lt;(*it).getName()&lt;&lt;"  年龄："&lt;&lt;(*it).getAge()&lt;&lt;endl;    }    }int main(){    test01();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><p><img src="https://banthink.com/usr/uploads/2019/12/2589343174.bmp" alt="TIM截图20191230163352.bmp"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL -容器 &amp;lt;stack&amp;gt;  &amp;lt;queue&amp;gt; &amp;lt;list&amp;gt;相关API及原理</title>
      <link href="stl-rong-qi-lt-stack-gt-lt-queue-gt-lt-list-gt-xiang-guan-api-ji-yuan-li/"/>
      <url>stl-rong-qi-lt-stack-gt-lt-queue-gt-lt-list-gt-xiang-guan-api-ji-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="链表容器"><a href="#链表容器" class="headerlink" title="链表容器"></a>链表容器</h1><p>原理：链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列节点组成，节点可以在运行时动态生成。每个节点包括两个部分：一个是存储数据元素的数据域，一个是存储下一个节点地址的指针域。</p><p>相较于vector的连续线性空间，list就显得负责的多，它的好处是每次插入或者删除元素的时间复杂度为O（1）。但是在内存空间上面由于是散列分布的，所以空间利用率并没有vector来的高。</p><h2 id="迭代器-不支持随机访问，仅限递增或者递减"><a href="#迭代器-不支持随机访问，仅限递增或者递减" class="headerlink" title="迭代器(不支持随机访问，仅限递增或者递减)"></a>迭代器(不支持随机访问，仅限递增或者递减)</h2><p>List容器不能像vector一样以普通指针作为迭代器，因为其节点不能保证在同一块连续的内存空间上。List迭代器必须有能力指向list的节点，并有能力进行正确的递增、递减、取值、成员存取操作。所谓list正确的递增、递减、取值、成员取用是指：递增时指向下一个节点，递减指向上一个节点，取值时取的是节点的数据值，成员取用时取的是节点的成员。</p><p>由于list是一个双向链表，迭代器必须能够具备前移、后移的能力，所以list容器提供的是Bidirectional Iterators</p><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器失效，这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效。甚至List元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受影响。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre class="line-numbers language-none"><code class="language-none">list&lt;T&gt; lstTlist(beg,end) 构造函数将beg,end区间中的元素拷贝给本身list(n,elem) 构造函数将n个elem拷贝给本身list(const list &amp;lst) 拷贝构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入删除操作"><a href="#插入删除操作" class="headerlink" title="插入删除操作"></a>插入删除操作</h3><pre class="line-numbers language-none"><code class="language-none">push_back(T) pop_back(T)push_front(T)pop_front(T)insert(pos,T);insert(pos,n,T)insert(pos,beg,end)clear();  //清空容器中的所有数据erase(beg,end) 删除区间中的数据，返回下一个数据的位置erase(pos)  删除pos位置的数据  返回下一个数据的位置remove(T) 删除容器中所有的与elem所匹配的值(可以重载== 来实现删除自定义的类型)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="大小操作"><a href="#大小操作" class="headerlink" title="大小操作"></a>大小操作</h3><pre class="line-numbers language-none"><code class="language-none">size()empty()resize(num)resize(num,T)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h3><pre class="line-numbers language-none"><code class="language-none">assign(iterator beg,iterator end)  将区间中的数据拷贝赋值到本身assign(n,T)   将n个elem拷贝赋值到本身list &amp;operator =(const list &amp;lst)swap(lst)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h3><pre class="line-numbers language-none"><code class="language-none">front();  返回第一个元素back(); 返回最后一个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="排序-去重"><a href="#排序-去重" class="headerlink" title="排序 去重"></a>排序 去重</h3><pre class="line-numbers language-none"><code class="language-none">unique() 删除list中重复的元素  sort(bool (*fun)(T&amp;,T&amp;)) 给list排序,需要传入一个排序规则:例如 return T1&gt;T2  //从大到小排序  ````# 栈容器 特点 ：先进后出(FILO)## API### 构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>stack<t> stkT<br>stack(const stack &amp;stk) //拷贝构造函数</t></p><pre class="line-numbers language-none"><code class="language-none"># 队列容器特点：先进先出（FIFO），queue容器允许从一端新增元素另一端删除元素## API### 构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>queue<t> stkT<br>queue(const queue&amp;stk) //拷贝构造函数</t></p><pre class="line-numbers language-none"><code class="language-none"># 队列和栈共同操作## 赋值操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>stack &amp;operator=(const stack &amp;stk); //重载</p><pre class="line-numbers language-none"><code class="language-none">## 数据存取操作<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>push(T)  //压栈  &amp;&amp;  向队尾添加元素 </p><p>pop()  //出栈   &amp;&amp;  从队头取出数据 </p><p>top()  //返回栈顶元素   &amp;&amp; 返回第一个元素（队头）</p><pre class="line-numbers language-none"><code class="language-none">## 大小操作<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>empty() //返回是否为空</p><p>size() //返回堆栈大小 &amp;&amp; 队列大小<br>```</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL -容器 &amp;lt;deque&amp;gt; 相关API及原理</title>
      <link href="stl-rong-qi-lt-deque-gt-xiang-guan-api-ji-yuan-li/"/>
      <url>stl-rong-qi-lt-deque-gt-xiang-guan-api-ji-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Deque容器（双端队列）"><a href="#Deque容器（双端队列）" class="headerlink" title="Deque容器（双端队列）"></a>Deque容器（双端队列）</h1><p>Deque是一种双向开口的连续线性空间。</p><p>Deque容器和vector最大的差异是：一再与deque头端的插入删除是O(1)时间复杂度。<strong>二是deque没有容量的概念，因为它是动态的分段连续空间组合而成</strong>，随时可以增加一段新的空间并链接起来。反观vector容器的空间不足时需要重新配置一块更大的空间然后复制元素，再释旧空间。因此，<strong>deque没有必要提供所谓的空间保留reserver功能</strong></p><p>虽然deque容器也提供了可以随机访问的迭代器，但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非必要，我们应该尽可能使用vector而不是deque.对deque的排序操作，为了最高效率，可以将deque先完整复制到一个vector中，对vector进行排序再复制回deque。</p><p>Deque容器是连续的空间，至少逻辑上看是如此，连续线性空间总是令我们联想到array和vector。array无法成长，vector虽然可以成长但是只能向尾端成长，而且其成长是一个假象，事实上是：申请更大的空间 -&gt;原数据复制到新空间-&gt;释放原空间。如果不是vector每次配置新的空间都留有余裕，其成长假象所带来的代价是非常昂贵的。</p><p>deque是由一段一段的定量的连续空间构成，一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间、赋值、释放的轮回，代价就是复杂的迭代器架构。</p><p>既然deque是分段连续内存空间，那么久必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。deque代码的实现远比vector或list多得多。</p><p>deque采取一块所谓的map（并不是STL的map容器）作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素（此处成为一个节点）都是一个指针，指向另一端连续内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体。</p><p><img src="https://banthink.com/usr/uploads/2019/12/4241868985.png" alt="无标题.png"></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="双端插入和删除操作"><a href="#双端插入和删除操作" class="headerlink" title="双端插入和删除操作"></a>双端插入和删除操作</h3><pre class="line-numbers language-none"><code class="language-none">push_back(T);  //尾部添加push_front(T);   //头部插入T pop_back()   //删除最后一个数据并返回T pop_front();  //删除第一个数据并返回<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h3><pre class="line-numbers language-none"><code class="language-none">at(idx)   //返回索引idx所指的数据，如果idx越界抛出out_of_rangeoperator [] //同上，区别是不抛出异常front(); //返回第一个数据back(); //返回最后一个数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><pre class="line-numbers language-none"><code class="language-none">insert(pos,T) 在pos位置插入一个T元素的拷贝，并返回新数据的位置insert(pos,n,T)  在pos位置插入n个T数据，无返回值insert(pos,iterator beg,iterator end) 在pos位置插入(beg,end)器件的数据，无返回值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><pre class="line-numbers language-none"><code class="language-none">clear(); //移除容器的所有数据erase(iterator begin,iterator end) 删除区间内的数据 并返回下一个数据的位置erase(pos) 删除pos位置的数据并返回下一个数据的位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL -容器 &amp;lt;vector&amp;gt; 相关API及原理</title>
      <link href="stl-rong-qi-lt-vector-gt-xiang-guan-api-ji-yuan-li/"/>
      <url>stl-rong-qi-lt-vector-gt-xiang-guan-api-ji-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="Vector（序列容器）"><a href="#Vector（序列容器）" class="headerlink" title="Vector（序列容器）"></a>Vector（序列容器）</h2><p>Vector维护一个线性空间，单向开口的连续内存空间(开口在尾部)，所谓动态增长并不是在原有空间上接续新空间（因为无法保证</p><p>原有空间之后尚有可配置的空间），而是一块更大的内存空间 然后将原数据拷贝到新空间中，并释放原空间。因此，对vector的任</p><p>何操作，一旦引起空间的重新配置，<strong>指向原vector的所有迭代器都会失效</strong></p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Vector迭代器是随机访问的迭代器，支持跳跃访问</p><p>Insert/erase/ (迭代器)<br>逆序迭代器 reverse_iterator .</p><p>例如:for(vector<int>::reverse_iterator it=v.rbegin();it!=rend();it++)</int></p><p>构造函数</p><pre class="line-numbers language-none"><code class="language-none">vector&lt;T&gt; v 默认构造函数vectoor(v.begin(),v.end()) //将v.begin()到end()区间中的元素拷贝给本身vector(n,T) 构造函数将n个T拷贝给本身vector(const vector &amp;vec) 拷贝构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常用赋值操作</p><pre class="line-numbers language-none"><code class="language-none">assign(beg,end); 将(beg,end)区间的数据拷贝赋值给本身assign(n,T) 将n个T拷贝赋值给本身vector &amp;operator=(const vector &amp;vec) 重载等号swap(vec)将vec与本身的元素互换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大小操作</p><pre class="line-numbers language-none"><code class="language-none">int size() 返回容器中元素的个数bool empty() 判断容器是否为空resize(int num)  重新指定容器的长度为num，若容器变长则以默认值填充新位，如果变短就删除尾部resize(int num,T) int capacity() 容器的容量reserve(int len) 容器预留len个元素长度，预留位置不初始化，元素不可访问<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关于resize和reserve的区别"><a href="#关于resize和reserve的区别" class="headerlink" title="关于resize和reserve的区别"></a>关于resize和reserve的区别</h3><h4 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h4><p>调整容器的长度大小，使其能容纳n个元素。</p><p>如果n小于容器的当前的size，则删除多出来的元素。</p><p>否则，添加采用值初始化的元素。</p><h4 id="resize-n，t"><a href="#resize-n，t" class="headerlink" title="resize(n，t)"></a>resize(n，t)</h4><p>多一个参数t，将所有新添加的元素初始化为t。</p><h4 id="reserver-的用法只有一种"><a href="#reserver-的用法只有一种" class="headerlink" title="reserver()的用法只有一种"></a>reserver()的用法只有一种</h4><p>reserve(n)</p><p>预分配n个元素的存储空间。</p><p>了解这两个函数的区别，首先要搞清楚容器的capacity（容量）与size（长度）的区别。</p><p>size指容器当前拥有的元素个数；</p><p>而capacity则指容器在必须分配新存储空间之前可以存储的元素总数。</p><p>也可以说是预分配存储空间的大小。</p><p>resize()函数和容器的size息息相关。调用resize(n)后，容器的size即为n。</p><p>至于是否影响capacity，取决于调整后的容器的size是否大于capacity。</p><p>reserve()函数和容器的capacity息息相关。</p><p>调用reserve(n)后，若容器的capacity&lt;n，则重新分配内存空间，从而使得capacity等于n。</p><p>如果capacity&gt;=n呢？capacity无变化。</p><p>从两个函数的用途可以发现，容器调用resize()函数后，所有的空间都已经初始化了，所以可以直接访问。</p><p>而reserve()函数预分配出的空间没有被初始化，所以不可访问。reserve主要是用来调整容器内部分配存储空间的策略</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL -容器 &amp;lt;string&amp;gt; 相关API及原理</title>
      <link href="stl-rong-qi-lt-string-gt-xiang-guan-api-ji-yuan-li/"/>
      <url>stl-rong-qi-lt-string-gt-xiang-guan-api-ji-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre class="line-numbers language-none"><code class="language-none">string() 创建一个空的字符串string(const string &amp;str) 使用一个string对象初始化string(const char *s) 使用字符串s初始化string(int n,char c) 使用n个字符c初始化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基本赋值操作"><a href="#基本赋值操作" class="headerlink" title="基本赋值操作"></a>基本赋值操作</h3><pre class="line-numbers language-none"><code class="language-none">string &amp;operator=(const char *s)string &amp;operator=(const string &amp;s)string &amp;operator=(char c)string &amp;assign(const char *s) 把字符串赋值给当前字符串string &amp;assign(int n,char c) 把n个字符c赋值给当前字符串string &amp;assign(const string &amp;s,int start,int n ); 将s从start开始n个字符赋值给字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="拼接操作"><a href="#拼接操作" class="headerlink" title="拼接操作"></a>拼接操作</h3><pre class="line-numbers language-none"><code class="language-none">string &amp;operator+=(const string &amp;str) string &amp;operator+=(const char *str)string &amp;operator+=(const char c)string &amp;append(const char *s) string &amp;append(const char *s,int n) 把字符串s的前n个字符连接到当前字符串结尾string &amp;append(int n,char c) 在当前字符串结尾添加n个字符cstring &amp;append(const string &amp;s,int pos,int n) 把字符串s中从pos开始的n个字符连接到当前字符串结尾<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h3><pre class="line-numbers language-none"><code class="language-none">int find(const string &amp;str,int pos=0) const; 查找str第一次出现的位置,从pos开始查找int find(const char *s,int pos=0) const; 同上int find(const char *s,int pos,int n)const; 从pos位置查找s的前n个字符第一次位置int find(const char c,int pos=0)const 查找cint rfind(const string &amp;str,int pos=npos)const; 查找s最后一次出现位置，从pos开始查找int rfind(const char *s,int pos=npos)const; 查找s最后一次出现位置，从pos开始查找int rfind(const char *s,int pos,int n)const;从pos查找s的前n个字符最后一次位置int rfind(const char c ,int pos=0)const; 查找字符c最后一次出现位置string &amp; replace(int pos,int n,const string&amp;str) 替换从pos开始n个字符为字符串strstring &amp;replace(int pos,int n,const char*s); 替换从pos开始的n个字符为字符串s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h3><p>compare 函数在&gt;时返回1，&lt;时返回-1,==时返回0</p><p>比较区分大小写，比较时参考字典顺序，排越前面的越小</p><p>例如：A&lt;a</p><pre class="line-numbers language-none"><code class="language-none">int compare(const string &amp;s)constint compare(const char *s)const <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="子串操作"><a href="#子串操作" class="headerlink" title="子串操作"></a>子串操作</h3><pre class="line-numbers language-none"><code class="language-none">string substr(int pos=0,int n=npos)const 返回由pos开始的n个字符组成的字符串<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="插入和删除操作"><a href="#插入和删除操作" class="headerlink" title="插入和删除操作"></a>插入和删除操作</h3><pre class="line-numbers language-none"><code class="language-none">string &amp;insert(int pos,const char *s);string &amp;insert(int pos,const string &amp;str);  插入字符串strstring &amp;insert(int pos,int n char c);   在指定位置插入n个字符string &amp;insert(int pos,int n=npos);  删除从pos开始的n个字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>转换大小写</p><pre class="line-numbers language-none"><code class="language-none"># include &lt;algorithm&gt;std::transform(iterator start,iterator end,iterator object,::toupper)  //大写std::transform(iterator start,iterator end,iterator object,::tolower)  //大写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="相关要点"><a href="#相关要点" class="headerlink" title="相关要点"></a>相关要点</h2><ol><li><p>string中访问单独字符的时候可以用at也可以用[]，两者的区别是前者可以抛出异常，用out_of_range接收</p></li><li><p>char *可以和string 互转，char *可以隐式转换string 反之不可以</p></li><li><p>关于const_cast 的可以看这个博客<br><a href="https://www.cnblogs.com/ider/archive/2011/07/22/cpp_cast_operator_part2.html">https://www.cnblogs.com/ider/archive/2011/07/22/cpp_cast_operator_part2.html</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL- 总览</title>
      <link href="stl-zong-lan/"/>
      <url>stl-zong-lan/</url>
      
        <content type="html"><![CDATA[<h2 id="STL组成"><a href="#STL组成" class="headerlink" title="STL组成"></a>STL组成</h2><ul><li><strong>容器</strong> ：存放数据  类似于class template</li><li><strong>迭代器</strong> ：迭代器是一种将operator *,operator-&gt; , operator ++,operator –等指针相关操作重载的class template。<strong>每个STL容器都附带有自己专属的迭代器</strong>（意味着如果容器中的元素为自己声明的类型时需要自己设计一个迭代器），只有容器的设计者才知道如何遍历自己的元素</li><li><strong>算法</strong>：类似于function template</li><li><strong>仿函数</strong> ：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class或者class template</li><li><strong>适配器（配接器）</strong>：一种用来修饰容器或者仿函数或迭代器接口的东西</li><li><strong>空间配置器</strong>：负责空间的配置与管理。从实现的角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template</li></ul><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。</p><h2 id="几个容器区别和使用场景"><a href="#几个容器区别和使用场景" class="headerlink" title="几个容器区别和使用场景"></a>几个容器区别和使用场景</h2><p><img src="https://banthink.com/usr/uploads/2019/12/3194276766.bmp" alt="容器.bmp"></p><p><img src="https://banthink.com/usr/uploads/2019/12/2058197932.bmp" alt="容器使用場景.bmp"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法复习-动态规划（5）</title>
      <link href="suan-fa-fu-xi-dong-tai-gui-hua-5/"/>
      <url>suan-fa-fu-xi-dong-tai-gui-hua-5/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-139-单词拆分"><a href="#LeetCode-139-单词拆分" class="headerlink" title="LeetCode 139 单词拆分"></a>LeetCode 139 单词拆分</h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定&nbsp;s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p><pre class="line-numbers language-none"><code class="language-none">示例 1：输入: s = "leetcode", wordDict = ["leet", "code"]输出: true解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。示例 2：输入: s = "applepenapple", wordDict = ["apple", "pen"]输出: true解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。&nbsp;    注意你可以重复使用字典中的单词。示例 3：输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]输出: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/word-break">https://leetcode-cn.com/problems/word-break</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>状态变量dp[i]：s中到第i个字符能否被字典拆分<br>状态转移方程:这个就比较难找了,这题目不像前面几道题前者的状态和后者的状态关联性那么明显,但是实际上因为存在一个字符重复被利用的问题，我们需要检查前一个匹配成功的单词避免重复利用!<br>即</p><pre class="line-numbers language-none"><code class="language-none">for i-&gt;n   for auto word:wordDict      if(i-word.size()&gt;=0)   匹配的长度必须大于等于词典中的单词长度         if(s.compare(i-word.size(),word.size(),word)&amp;&amp;dp[i-word.size()])              dp[i]=true             break;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-dp[i-word.size()]```：在匹配成功的之前除了需要字符串相同外,也需要前i-word.size()匹配成功。可以避免实例2的情况发生--->当同一个字符同时作为两个单词的尾部和首部时，会出现这个字符被重新利用的情况." data-language="dp[i-word.size()]```：在匹配成功的之前除了需要字符串相同外,也需要前i-word.size()匹配成功。可以避免实例2的情况发生--->当同一个字符同时作为两个单词的尾部和首部时，会出现这个字符被重新利用的情况."><code class="language-dp[i-word.size()]```：在匹配成功的之前除了需要字符串相同外,也需要前i-word.size()匹配成功。可以避免实例2的情况发生--->当同一个字符同时作为两个单词的尾部和首部时，会出现这个字符被重新利用的情况.">## 代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>class Solution {<br>public:<br>    bool wordBreak(string s, vector<string>&amp; wordDict) {<br>        if(s.empty()||wordDict.empty())<br>            return false;<br>        int n=s.size();<br>        vector<bool> dp(n+1,false);  //表示到第n个字符为止  s是否能被字典拆分<br>        dp[0]=true;<br>        for(int i=0;i&lt;=n;i++)<br>        {<br>            for(auto word:wordDict)<br>            {<br>                int ws = word.size();<br>                if(i - ws &gt;= 0) {<br>                    if (!s.compare(i-ws, ws, word)&amp;&amp;dp[i-ws]) {<br>                        dp[i] = true;<br>                        break;<br>                    }</bool></string></p><pre><code>            }        }       }    //从开始到是否在这里面    return dp[n];}</code></pre><p>};</p><p>```</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>这道题的状态转移方程是真的很特别，和之前的完全不太一样。从前面做的来看，过去的状态与现在的状态之间的联系很多变，有过去中取最大值最小值的，也有累加的，同时还有这道题的作为现在的状态的一个条件变量来进行赋值。很多遍，需要灵活一些。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法复习-动态规划（4）</title>
      <link href="suan-fa-fu-xi-dong-tai-gui-hua-4/"/>
      <url>suan-fa-fu-xi-dong-tai-gui-hua-4/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-No-188-股票"><a href="#LeetCode-No-188-股票" class="headerlink" title="LeetCode No.188 股票"></a>LeetCode No.188 股票</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意:&nbsp;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><pre class="line-numbers language-none"><code class="language-none">示例&nbsp;1:输入: [2,4,1], k = 2输出: 2解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。示例 2:输入: [3,2,6,5,0,3], k = 2输出: 7解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。&nbsp;    随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>LeetCode上面有好几道股票的动态规划题目，实际上这些题目都差不多，只要我们掌握了最难的那个，后面基本没问题。<br>首先是状态变量的定义：<br><code>dp[i] 最粗糙的就是这样子，dp[i]代表第i天的最大利润</code><br>但是实际写下去我们会发现，仅仅一维数组是没有用的，因为缺少了很多中间状态。比如第i天的利润无法直接从第i-1中获取，中间夹杂着是否持有股票，交易次数等的限制。所以接下来我们在状态变量上面增加几个标志<br><code>dp[i][k][a]:i表示天数，k表示交易次数，a表示是否持有股票（持有为1反之为0）</code><br>接下来就是状态转移方程：</p><p>第i天没有持有股票的时候,存在两种情况:</p><ol><li>第i-1天的时候就已经没有持有股票了</li><li>第i天的时候将股票抛售<br>即：<br><code> dp[i][k][0]=max(dp[i-1][k][0],dp[i-1][k][1]+prices[i])</code>  </li></ol><p>第i天持有股票的时候,同样存在两种情况:</p><ol><li>第i-1天的时候持有股票</li><li>第i天的时候将购入股票,这时候因为发生了交易,所以应该转移的状态是前一天的k-1次交易时没有持有股票的状态<br>即：<br><code> dp[i][k][1]=max(dp[i-1][k][1],dp[i-1][k-1][0]-prices[i]) </code></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-none"><code class="language-none">class Solution {public:    int maxProfit(int k, vector&lt;int&gt;&amp; prices) {        if(k&lt;=0||prices.size()&lt;=1)        {            return 0;        }        if(k&gt;prices.size()/2)        {            return maxProfit(prices);  //当输入的k过大的时候就已经转换为无限次交易的题目        }        vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; dp(prices.size(),vector&lt;vector&lt;int&gt; &gt;(k+1,vector&lt;int&gt;(2)));        int maxprofit=0;        for(int i=0;i&lt;prices.size();i++)        {            for(int j=1;j&lt;=k;j++)            {                if(i-1&lt;0)                {                    dp[i][j][0]=0;                    dp[i][j][1]=-prices[i];                    continue;                }  //这里需要对一些状态进行过滤                dp[i][j][0]=max(dp[i-1][j][1]+prices[i],dp[i-1][j][0]);                dp[i][j][1]=max(dp[i-1][j-1][0]-prices[i],dp[i-1][j][1]);                maxprofit=max(maxprofit,dp[i][j][0]);            }                    }        return maxprofit;    }    int maxProfit(vector&lt;int&gt;&amp; prices)  //无限制次数交易的题目代码    {        int dp[2][2],x;        dp[0][0]=0;        dp[0][1]=-prices[0];        for(int i=1;i&lt;prices.size();i++)        {            x=i%2;            dp[x][0]=max(dp[!x][0],dp[!x][1]+prices[i]);            dp[x][1]=max(dp[!x][1],dp[!x][0]-prices[i]);        }        return dp[x][0];    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>股票这边看了很久，反复的去看教程。事实上我的代码并不高效，只能是勉强过了，题解中大佬们基本都是几ms的，但是这个思路是最为朴素的动态规划，更适合刚入门学习动态规划的人。一开始并不是很能理解多维dp中有些维数的作用，事实上这些有些维数（最多应该也就3了吧…再多就得还算法了）起到的作用是用来分解状态的。例如股票这道题目，题目的限制条件有：交易k次，不能同时参与多个交易 =====&gt; 意味着要抛售前必须有股票，交易次数必须小于k次（废话），但是如果只有一个dp[n]一维数组的大小，很难界定说上个状态是否有股票，交易次数现在是否小于k次了，动态规划的核心就是记忆化，保存每一次递推的结果用于下一次。但是题目中最初的状态都可以分为：持有股票、没有持有股票、交易了、没有交易，可以说并不唯一，所以需要多维度来帮助表达限制条件，最直观的就是0表示没有股票，1表示持有股票。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法复习-动态规划（3）</title>
      <link href="suan-fa-fu-xi-dong-tai-gui-hua-3/"/>
      <url>suan-fa-fu-xi-dong-tai-gui-hua-3/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-No-120-三角形最小路径和"><a href="#LeetCode-No-120-三角形最小路径和" class="headerlink" title="LeetCode No.120 三角形最小路径和"></a>LeetCode No.120 三角形最小路径和</h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>例如，给定三角形：</p><pre class="line-numbers language-none"><code class="language-none">[     [2],    [3,4],   [6,5,7],  [4,1,8,3]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自顶向下的最小路径和为&nbsp;11（即，2&nbsp;+&nbsp;3&nbsp;+&nbsp;5&nbsp;+&nbsp;1&nbsp;= 11）。</p><p>说明：</p><p>如果你可以只使用 O(n)&nbsp;的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/triangle">https://leetcode-cn.com/problems/triangle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>回溯法<pre class="line-numbers language-none"><code class="language-none">走路(i,j){     min(走路(i+1,j),走路(i+1,j+1))  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>贪心法<br>如果只看当前层，那么后面层的时候如果有过大的话就没办法了<br>例如<pre class="line-numbers language-none"><code class="language-none">[     [2],    [3,4],   [6,5,7],  [4,1=&gt;1000,8=&gt;8000,3]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>贪心法：2+3+5+1  =&gt;2+3+5+1000 错！</li><li>动态规划<br>第一步是递归+记忆法=&gt;递推。递归在第一个方法中有大概说了一下。那么接下来的状态变量如何寻找和定义? 我们先从自上而下的去查找，会发现可能性很多，需要穷举（时间复杂度太高了）,底部的可能性太多了,自底而上的话最后指向的顶点只有一个。<br>状态定义:dp[i][j]  从底走到点(i,j)的路径和最小值<br>动态方程 dp[i][j]=min(dp[i+1][j],dp[i+1][j+1])+Triangle[i,j]<br>优化子结构:dp[n]就够了，只需要三角形那一行的数据就可以了<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-none"><code class="language-none">class Solution {public:    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {        vector&lt;int&gt; dp=triangle[triangle.size()-1];         //对dp进行赋值，将最后三角形最后一行的值赋值        for(int i=triangle.size()-2;i&gt;=0;i--)  //剔除掉最后一行，从倒数第二行开始        {            for(int j=0;j&lt;triangle[i].size();j++)              //dp为二维数组的时候             // dp[i][j]=min(dp[i+1][j],dp[i+1][j+1])+triangle[i][j]              //比较两者有什么差别                dp[j]=triangle[i][j]+min(dp[j],dp[j+1]);  //优化后                    }        return dp[0];        }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="LeetCode-No-152-乘积最大子序列"><a href="#LeetCode-No-152-乘积最大子序列" class="headerlink" title="LeetCode No.152 乘积最大子序列"></a>LeetCode No.152 乘积最大子序列</h2><p>给定一个整数数组 nums&nbsp;，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p><p>示例 1:</p><p>输入: [2,3,-2,4]<br>输出: 6<br>解释:&nbsp;子数组 [2,3] 有最大乘积 6。<br>示例 2:</p><p>输入: [-2,0,-1]<br>输出: 0<br>解释:&nbsp;结果不能为 2, 因为 [-2,-1] 不是子数组。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-product-subarray">https://leetcode-cn.com/problems/maximum-product-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><ol><li>回溯法+记忆化</li><li>动态规划<br>状态定义:<br>最简单的定义———dp[i] 表示0走到i位置的最大连续乘积子序列<br>那么最后的求解的是dp[n-1]<br>状态转移方程:<code> dp[i+1]=dp[i]*a[i+1](正?负?)</code><br>错误！存在一个负负得正的情况同时还有为0的情况，同时还有一种可以不进行相乘操作（换而言之就是乘积之后的结果比a[i]还要小）<br>状态变量：<code>dp[i][2]</code>    其中第二维：0:max  1:min<br>状态转移方程:<pre class="line-numbers language-none"><code class="language-none">dp[i][0]=max(dp[i-1][0]*a[i],a[i])   (a[i]&gt;=0)dp[i][0]=max(dp[i-1][1]*a[i],a[i])   (a[i]&lt;0)dp[i][1]=min(dp[i-1][1]*a[i],a[i])   (a[i]&gt;=0)dp[i][1]=min(dp[i=1][0]*a[i],a[i])   (a[i]&lt;0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2></li></ol><p>class Solution {<br>public:<br>    int maxProduct(vector<int>&amp; nums) {<br>        if(nums.size()==1)<br>            return nums[0];<br>        int dp[2][2],result=nums[0];<br>        dp[0][0]=nums[0];<br>        dp[0][1]=nums[0];<br>        for(int i=1;i&lt;nums.size();i++)<br>        {<br>            int x=i%2;<br>            if(nums[i]&gt;=0)<br>            {<br>                dp[x][0]=max(dp[!x][0]*nums[i],nums[i]);<br>                dp[x][1]=min(dp[!x][1]*nums[i],nums[i]);</int></p><pre><code>        }else        {            dp[x][0]=max(dp[!x][1]*nums[i],nums[i]);            dp[x][1]=min(dp[!x][0]*nums[i],nums[i]);        }        result=max(result,dp[x][0]);    }    return result;}</code></pre><p>};</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>这个就是出现了分支情况的动态规划，需要分析分解条件，不能一味的就dp[n]这样套下去。代码是优化后的，将原本的不定长二维数组优化为定长的二维数组节约了空间，同时用x=i%2进行滚动循环,这样减少冗余变量。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法复习-动态规划（2）</title>
      <link href="suan-fa-fu-xi-dong-tai-gui-hua-2/"/>
      <url>suan-fa-fu-xi-dong-tai-gui-hua-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>改说的概念什么的都在前面讲完了，剩下的都是实例分析了</p></blockquote><h2 id="LeetCode-No-70-爬楼梯"><a href="#LeetCode-No-70-爬楼梯" class="headerlink" title="LeetCode No.70 爬楼梯"></a>LeetCode No.70 爬楼梯</h2><p>假设你正在爬楼梯。需要 n&nbsp;阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p><ol><li> 1 阶 + 1 阶</li><li> 2 阶<br>示例 2：</li></ol><p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li> 1 阶 + 1 阶 + 1 阶</li><li> 1 阶 + 2 阶</li><li> 2 阶 + 1 阶</li></ol><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/climbing-stairs">https://leetcode-cn.com/problems/climbing-stairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li><p>回溯(自顶向下的去看)<br>从终点开始看，向下看:fun(n),fun(n-1)….fun(1)<br>观察第n阶台阶可以从哪些台阶上来。<br>fun(n)=fun(n-1)+fun(n-2)<br>就是斐波拉契数列</p></li><li><p>动态规划<br>for i=2-&gt;n<br>f[n]=f[n-1]+f[n-2]<br>dp状态定义：f[n]表示到第n阶台阶的总方法个数</p></li></ol><p>动态规划最重要的步骤：<br>1、dp状态定义<br>2、动态转移方程</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-none"><code class="language-none">class Solution {public:    int climbStairs(int n) {        if(n&lt;=2)            return n;        int dp[3];        dp[0]=1;        dp[1]=2;        for(int i=2;i&lt;n;i++)        {            dp[2]=dp[0]+dp[1];            dp[0]=dp[1];            dp[1]=dp[2];        }        return dp[2];    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>这道题是换了个角度的斐波拉契数列.实际有些动态规划的题目状态变量不是一维就是二维，接下来返回值大概率是状态变量的最后或者第一个元素。可以从这个角度去快速分析状态变量。然后状态转移方程的求解可以直接从最终解开始分析，重点是抓住<code>记忆化</code>和<code>子问题最优解</code>,就是最终解和前面若干个解的联系,例如斐波拉契数列的最终解就是n-1和n-2的解。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>又是折腾的一天</title>
      <link href="you-shi-zhe-teng-de-yi-tian/"/>
      <url>you-shi-zhe-teng-de-yi-tian/</url>
      
        <content type="html"><![CDATA[<p>折腾了半天的QT  最后重新安装了QT5.12，比QT4.8香多了<br>前置服务器的日志系统基本上是装完了，后置服务器需要再弄一弄<br>不过接下来就是得准备计算机网络基础的考试和数据库了<br>都不会23333</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Log4cplus 介绍及使用</title>
      <link href="log4cplus-jie-shao-ji-shi-yong/"/>
      <url>log4cplus-jie-shao-ji-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本的类"><a href="#一、基本的类" class="headerlink" title="一、基本的类"></a>一、基本的类</h2><table><thead><tr><th>类</th><th>功能</th></tr></thead><tbody><tr><td>Logger</td><td>记录日志的句柄。</td></tr><tr><td>Appender</td><td>用于指定内容输出位置（如：控制台，文件、远程服务器等）。一个Logger可添加多个Appender，从而向多个位置输出日志。</td></tr><tr><td>Layout</td><td>用于指定日志输出的格式。每个Appender需要设置一个Layout。</td></tr></tbody></table><p>Logger ——&nbsp;Appender ——&nbsp;Layout的关系图：<br><img src="https://banthink.com/usr/uploads/2019/12/3355676311.png" alt="1.png"></p><p>&nbsp;</p><h2 id="二、Log4cplus支持的Appender的类型"><a href="#二、Log4cplus支持的Appender的类型" class="headerlink" title="二、Log4cplus支持的Appender的类型"></a>二、Log4cplus支持的Appender的类型</h2><p><img src="https://banthink.com/usr/uploads/2019/12/1095873413.png" alt="2.png"></p><p>上图是Appender的继承关系，其中Log4cplus::Appnder是各种Appender的父类。从图中，我们可以获得log4cplus所支持的Appender的类型。</p><h2 id="三、Log4cplus支持的Layout的类型"><a href="#三、Log4cplus支持的Layout的类型" class="headerlink" title="三、Log4cplus支持的Layout的类型"></a>三、Log4cplus支持的Layout的类型</h2><p><img src="https://banthink.com/usr/uploads/2019/12/2252203378.png" alt="3.png"></p><p>上图是Layout的继承关系，其中Log4cplus::Layout是各种Layout的父类。从图中，我们可以得知Layout的类型有3种，分别为PatternLayout、SimpleLayout和TTCCLayout。其中的PatternLayout可以让用户自定义输出格式。</p><h2 id="四、Log4cplus的基本使用步骤："><a href="#四、Log4cplus的基本使用步骤：" class="headerlink" title="四、Log4cplus的基本使用步骤："></a>四、Log4cplus的基本使用步骤：</h2><p>创建Appender对象。<br>设置Appender的名称和输出格式（Layout）<br>获得一个Logger实例，并设置其日志输出等级阈值<br>给Logger实例添加Appender<br>使用宏输出日志（宏的等级有6个，分别为：FATAL, ERROR, WARN, INFO, DEBUG, TRACE。FATAL宏的名为LOG4CPLUS_FATAL(&nbsp;)，ERROR的宏的名为LOG4CPLUS_ERROR(&nbsp;)，以此类推。具体使用方法见示例。）<br>注：一个Logger实例被配置后，将一直存在于程序中，在程序的任何地方都可通过实例名称获取到这个Logger，不用重新配置。</p><h2 id="五、示例"><a href="#五、示例" class="headerlink" title="五、示例"></a>五、示例</h2><p>之后的内容将通过示例来展示log4cplus的基本使用方法。</p><p>例1：将日志输出到控制台并写入文件</p><pre class="line-numbers language-none"><code class="language-none"># include &lt;log4cplus/log4cplus.h&gt; int main(){    //用Initializer类进行初始化    log4cplus::Initializer initializer;     //第1步：创建ConsoleAppender和FileAppender(参数app表示内容追加到文件)    log4cplus::SharedAppenderPtr consoleAppender(new log4cplus::ConsoleAppender);    log4cplus::SharedAppenderPtr fileAppender(new log4cplus::FileAppender(                                                  LOG4CPLUS_TEXT("log.txt"),                                                  std::ios_base::app                                                  )                                              );     //第2步：设置Appender的名称和输出格式    //ConsoleAppender使用SimpleLayout    //FileAppender使用PatternLayout    consoleAppender-&gt;setName(LOG4CPLUS_TEXT("console"));    consoleAppender-&gt;setLayout(std::unique_ptr&lt;log4cplus::Layout&gt;(new log4cplus::SimpleLayout()));    fileAppender-&gt;setName(LOG4CPLUS_TEXT("file"));    log4cplus::tstring pattern = LOG4CPLUS_TEXT("%D{%m/%d/%y %H:%M:%S,%Q} [%t] %-5p %c - %m [%l]%n");    fileAppender-&gt;setLayout(std::unique_ptr&lt;log4cplus::Layout&gt;(new log4cplus::PatternLayout(pattern)));     //第3步：获得一个Logger实例，并设置其日志输出等级阈值    log4cplus::Logger logger = log4cplus::Logger::getInstance(LOG4CPLUS_TEXT ("test"));    logger.setLogLevel(log4cplus::INFO_LOG_LEVEL);     //第4步：为Logger实例添加ConsoleAppender和FileAppender    logger.addAppender(consoleAppender);    logger.addAppender(fileAppender);     //第5步：使用宏将日志输出    LOG4CPLUS_INFO(logger, LOG4CPLUS_TEXT("Hello world"));     return 0;}运行结果：控制台输出 “INFO - Hello world”，同时，在目录中生成名称为 “log.txt” 的文件，文件内容为&nbsp;“12/10/18 09:57:22,288.442 [12040] INFO &nbsp;test - Hello world [..\logtest\main.cpp:25]”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例3：将日志发送到日志服务器：</p><pre class="line-numbers language-none"><code class="language-none"># include &lt;log4cplus/log4cplus.h&gt; int main(){    //用Initializer类进行初始化    log4cplus::Initializer initializer;     //第1步：创建SocketAppender    log4cplus::SharedAppenderPtr appender(new log4cplus::SocketAppender(                                                    LOG4CPLUS_TEXT("localhost"),                                                    32015, LOG4CPLUS_TEXT("test")));     //第2步：设置Appender的名称，SocketAppender不需要设置输出格式    appender-&gt;setName(LOG4CPLUS_TEXT("logserver"));     //第3步：获得一个Logger实例，并设置其日志输出等级阈值    log4cplus::Logger logger = log4cplus::Logger::getInstance(LOG4CPLUS_TEXT ("test"));    logger.setLogLevel(log4cplus::INFO_LOG_LEVEL);     //第4步：为Logger实例添加Appender    logger.addAppender(appender);     //第5步：使用宏将日志输出    LOG4CPLUS_INFO(logger, LOG4CPLUS_TEXT("Hello world"));     return 0;}例3的结果可以通过搭建一个日志服务器来查看，服务器的示例可以参考：simpleserver目录下的loggingserver.cxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="日志输出格式化"><a href="#日志输出格式化" class="headerlink" title="日志输出格式化"></a>日志输出格式化</h2><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>%%</td><td>转义为%</td></tr><tr><td>%c</td><td>输出logger名称，例如std::string pattern =”%c” 时输出: “cc.gmem”， 也可以控制logger名称的显示层次，如”%c{1}”时输出”gmem”, 其中数字表示层次</td></tr><tr><td>%D</td><td>显示本地时间，当std::string pattern =”%D” 时输出:”2011-11-16 11:00:00”</td></tr><tr><td>%d</td><td>显示标准时间，可以通过%d{…}定义更详细的显示格式，{}中可显示的预定义标识符如下：</td></tr><tr><td>%a – 表示礼拜几，英文缩写形式，比如”Fri”</td><td></td></tr><tr><td>%A – 表示礼拜几，比如”Friday”</td><td></td></tr><tr><td>%b – 表示几月份，英文缩写形式，比如”Oct”</td><td></td></tr><tr><td>%B – 表示几月份，”October”</td><td></td></tr><tr><td>%c – 标准的日期＋时间格式，如 “Sat Oct 16 18:56:19 2004”</td><td></td></tr><tr><td>%d – 表示今天是这个月的几号(1-31)”16”</td><td></td></tr><tr><td>%H – 表示当前时刻是几时(0-23)，如 “18”</td><td></td></tr><tr><td>%I – 表示当前时刻是几时(1-12)，如 “6”</td><td></td></tr><tr><td>%j – 表示今天是哪一天(1-366)，如 “290”</td><td></td></tr><tr><td>%m – 表示本月是哪一月(1-12)，如 “10”</td><td></td></tr><tr><td>%M – 表示当前时刻是哪一分钟(0-59)，如 “59”</td><td></td></tr><tr><td>%p – 表示现在是上午还是下午， AM or PM</td><td></td></tr><tr><td>%q – 表示当前时刻中毫秒部分(0-999)，如 “237”</td><td></td></tr><tr><td>%Q – 表示当前时刻中带小数的毫秒部分(0-999.999)，如 “430.732”</td><td></td></tr><tr><td>%S – 表示当前时刻的多少秒(0-59)，如 “32”</td><td></td></tr><tr><td>%U – 表示本周是今年的第几个礼拜，以周日为第一天开始计算(0-53)，如 “41”</td><td></td></tr><tr><td>%w – 表示礼拜几，(0-6, 礼拜天为0)，如 “6”</td><td></td></tr><tr><td>%W – 表示本周是今年的第几个礼拜，以周一为第一天开始计算(0-53)，如 “41”</td><td></td></tr><tr><td>%x – 标准的日期格式，如 “10/16/04”</td><td></td></tr><tr><td>%X – 标准的时间格式，如 “19:02:34”</td><td></td></tr><tr><td>%y – 两位数的年份(0-99)，如 “04”</td><td></td></tr><tr><td>%Y – 四位数的年份，如 “2004”</td><td></td></tr><tr><td>%Z – 时区名，比如 “GMT”</td><td></td></tr><tr><td>%F</td><td>输出当前记录器所在的文件名称</td></tr><tr><td>%L</td><td>输出当前记录器所在的文件行号</td></tr><tr><td>%l</td><td>输出当前记录器所在的文件名称和行号</td></tr><tr><td>%m</td><td>输出原始日志信息</td></tr><tr><td>%n</td><td>换行符</td></tr><tr><td>%p</td><td>输出LogLevel</td></tr><tr><td>%t</td><td>输出记录器所在的线程ID</td></tr><tr><td>%x</td><td>嵌套诊断上下文NDC</td></tr></tbody></table><p>文章转载自<a href="https://blog.csdn.net/u014695839/article/details/84937769">https://blog.csdn.net/u014695839/article/details/84937769</a>  培培哥的CSDN博客</p>]]></content>
      
      
      <categories>
          
          <category> 服务器框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>上位机 开发日志 2019-12-10</title>
      <link href="shang-wei-ji-kai-fa-ri-zhi-2019-12-10/"/>
      <url>shang-wei-ji-kai-fa-ri-zhi-2019-12-10/</url>
      
        <content type="html"><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>丢包、重包、粘包的处理<br>日志系统你<br>信号量</p><h2 id="问题-amp-amp-BUG"><a href="#问题-amp-amp-BUG" class="headerlink" title="问题&amp;&amp;BUG"></a>问题&amp;&amp;BUG</h2><ol><li>下位机修改过了，发送数据丢包率增加了，导致信号量释放过多发生异常。大部分异常出现在开始测试的时候，因为需要先移动到对应位置才能开始扫描（移动到对应位置的命令就是<code>开始测试</code>），在接收这个应答的处理函数中会发送一个开始测试的信号量（提供给外部能够判断是否移动结束），但是在孵化结束的时候开始采集同时也需要开始测试协议，导致信号量实际释放得比原来的多。（实际表现在前一个卡正常测试，后一个卡会动一下就结束采集，以此类推）。</li><li>从sd卡中获得数据的时候会有错误（小概率事件），导致生成的sd卡文件为空，进而导致调用dll函数时出错。</li><li>自检和满卡的时候没有屏蔽操作</li><li>sd卡检测线程无法检测到sd卡拔出操作</li><li>线程中的弹框无法暂停主线程的运行</li><li>程序中很多多余的标志位</li></ol><h2 id="解决方案及过程"><a href="#解决方案及过程" class="headerlink" title="解决方案及过程"></a>解决方案及过程</h2><ol><li>在所有信号量释放的时候增加异常处理操作。</li><li>增加当sd卡插入获取数据时有错误时禁止覆盖原sd卡文件</li><li>在屏蔽操作中增加一个检测是否满卡的操作，当满卡的时候默认为屏蔽操作。</li><li>在检测线程中发送sd卡检测命令，同时增加一个SDisNew标志位，便于判断当前的sd卡是否为新插入的，如果是新插入的就执行后面的读取等操作，不是就直接退出。</li><li>暂未解决。</li><li>暂未解决。</li></ol><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><ol><li>深刻体会到框架设计的重要性，还有一些可能导致错误的函数应该在设计初期就对其增加异常处理操作（尤其是信号量释放）。</li><li>数据丢包、重包、粘包这些老生常谈的问题，应该有一个好的解决方案在一开始，不要到最后调试的时候焦头烂额</li><li>程序日志系统的重要性（<code>很重要！！</code>），不要觉得打印个命令行就可以排错了，设计初期最好将所有动作阶段都加上增加一个本地日志记录，方便后续出现错误快速定位，不用再增加断点这样，有时候BUG是小概率事件，自己测试是找不到的，有时候用户使用过程中偶然出现的。</li><li>代码规范一点，注释多写一些，垃圾变量少写一点。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>log4cplus日志系统 一站式安装说明与测试程序编写</title>
      <link href="log4cplus-ri-zhi-xi-tong-yi-zhan-shi-an-zhuang-shuo-ming-yu-ce-shi-cheng-xu-bian-xie/"/>
      <url>log4cplus-ri-zhi-xi-tong-yi-zhan-shi-an-zhuang-shuo-ming-yu-ce-shi-cheng-xu-bian-xie/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>log4cplus是C++编写的开源的日志系统，前身是java编写的log4j系统.受Apache Software License保护。作者是Tad E. Smith。log4cplus具有<code>线程安全</code>、灵活、以及多粒度控制的特点，通过将信息划分优先级使其可以面向程序调试、运行、测试、和维护等全生命周期； 你可以选择将信息输出到屏幕、文件、NT event log、甚至是远程服务器；通过指定策略对日志进行定期备份等等。</p><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="https://github.com/wilx/log4cplus">https://github.com/wilx/log4cplus</a></p><h2 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h2><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><pre class="line-numbers language-none"><code class="language-none">Git clone https://github.com/wilx/log4cplus --recursiveCd log4cplus./configuremakemake install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装成功<br><img src="https://banthink.com/usr/uploads/2019/12/3840872487.png" alt="log4cplus.png"></p><p>接下来将上面的Lib地址里的文件全部复制到/usr/lib/里<br>cp -r Lib地址 /usr/lib</p><h3 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h3><p>1、GCC编译器版本过低<br> </p><pre class="line-numbers language-configure:" data-language="configure:"><div class="caption"><span>error: *** A compiler with support for C++17 language features is required.```说明GCC的编译器版本太低了，不支持C++17.可以在github上查看支持的gcc版本号</span></div><code class="language-configure:">这里提供一个最简单的GCC升级方法：使用Yum升级<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br> yum install centos-release-scl -y<br> yum install devtoolset-8 -y   //安装GCC8<br> scl enable devtoolset-8 bash<br> gcc –version<br> <pre class="line-numbers language-none"><code class="language-none">2、AutoMake版本过低，需要1.16这个问题比较麻烦，下面这些安装一下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><h3 id="安装m4"><a href="#安装m4" class="headerlink" title="安装m4"></a>安装m4</h3><p>wget <a href="http://mirrors.kernel.org/gnu/m4/m4-1.4.18.tar.gz">http://mirrors.kernel.org/gnu/m4/m4-1.4.18.tar.gz</a> <br>&amp;&amp; tar -xzvf m4-1.4.18.tar.gz <br>&amp;&amp; cd m4-1.4.18 <br>&amp;&amp; ./configure –prefix=/usr/local<br>make &amp;&amp; make install<br>cd ..</p><h3 id="安装autoconf"><a href="#安装autoconf" class="headerlink" title="安装autoconf"></a>安装autoconf</h3><p>wget <a href="http://mirrors.kernel.org/gnu/autoconf/autoconf-2.69.tar.gz">http://mirrors.kernel.org/gnu/autoconf/autoconf-2.69.tar.gz</a> <br>&amp;&amp; tar -xzvf autoconf-2.69.tar.gz <br>&amp;&amp; cd autoconf-2.69 <br>&amp;&amp; ./configure –prefix=/usr/local<br>make &amp;&amp; make install<br>cd ..</p><h3 id="安装automake"><a href="#安装automake" class="headerlink" title="安装automake"></a>安装automake</h3><p>wget <a href="http://mirrors.kernel.org/gnu/automake/automake-1.16.tar.gz">http://mirrors.kernel.org/gnu/automake/automake-1.16.tar.gz</a> <br>&amp;&amp; tar xzvf automake-1.16.tar.gz <br>&amp;&amp; cd automake-1.16 <br>&amp;&amp; ./configure –prefix=/usr/local<br>make &amp;&amp; make install<br>cd ..</p><p>如果automake-1.16 make出现如下错误</p><p>help2man: can’t get <code>--help' info from automake-1.16 Try </code>–no-discard-stderr’ if option outputs to stderr<br>make: *** [doc/automake-1.16.1] 错误 255<br>直接修改<br>vi Makefile</p><p>在 3694行 的末尾加上 –no-discard-stderr  修改后如下：</p><p>doc/aclocal-$(APIVERSION).1: $(aclocal_script) lib/Automake/Config.pm<br>                $(update_mans) aclocal-$(APIVERSION)<br>        doc/automake-$(APIVERSION).1: $(automake_script) lib/Automake/Config.pm<br>                $(update_mans) automake-$(APIVERSION) –no-discard-stderr<br>make &amp;&amp; make install  编译通过</p><h3 id="安装libtool"><a href="#安装libtool" class="headerlink" title="安装libtool"></a>安装libtool</h3><p>wget <a href="http://mirrors.kernel.org/gnu/libtool/libtool-2.4.6.tar.gz">http://mirrors.kernel.org/gnu/libtool/libtool-2.4.6.tar.gz</a> <br>&amp;&amp; tar xzvf libtool-2.4.6.tar.gz <br>&amp;&amp; cd libtool-2.4.6 <br>&amp;&amp; ./configure –prefix=/usr/local<br>make &amp;&amp; make install<br>cd ..</p><pre class="line-numbers language-none"><code class="language-none">3、丢失ThreadPool.h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>src/global-init.cxx:44:10: fatal error: ThreadPool.h: 没有那个文件或目录</p><h1 id="include-“ThreadPool-h”"><a href="#include-“ThreadPool-h”" class="headerlink" title="include “ThreadPool.h”"></a>include “ThreadPool.h”</h1><pre><code>      ^~~~~~~~~~~~~~</code></pre><p>compilation terminated.<br>make<a href="https://banthink.com/usr/uploads/2019/12/148724812.png">2</a>: *** [Makefile:2709：src/liblog4cplus_la-global-init.lo] 错误 1<br>make<a href="https://banthink.com/usr/uploads/2019/12/148724812.png">2</a>: 离开目录“/home/lusky/log4cplus”<br>make<a href="https://banthink.com/usr/uploads/2019/12/3840872487.png">1</a>: *** [Makefile:3757：all-recursive] 错误 1<br>make<a href="https://banthink.com/usr/uploads/2019/12/3840872487.png">1</a>: 离开目录“/home/lusky/log4cplus”<br>make: *** [Makefile:1591：all] 错误 2</p><pre class="line-numbers language-none"><code class="language-none">如果是用git clone克隆的log4cplus，那么只需要再克隆子模块就好了。```git submodule update --init --recursive```默认的lib库路径是/usr/local/lib/，头文件的位置是：/usr/local/include/log4cplus将/usr/local/lib下的和log4cplus相关的库都拷贝到/usr/lib，将头文件加到/etc/profile下的CPLUS_INCLUDE_PATH4、automake出现错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>configure.ac:29: error: version mismatch.  This is Automake 1.16.1,<br>configure.ac:29: but the definition used by this AM_INIT_AUTOMAKE<br>configure.ac:29: comes from Automake 1.16.  You should recreate<br>configure.ac:29: aclocal.m4 with aclocal and run automake again.</p><pre class="line-numbers language-none"><code class="language-none">编译的时候报错，解决方法如下 第一步 : ```autoscan``` 用 autoscan 产生一个 configure.in 的原型，执行autoscan 后会产生一个configure.scan 的文件，可以用它作为 configure.in文件的蓝本。 第二步:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>aclocal<br>autoconf</p><pre class="line-numbers language-none"><code class="language-none"> 执行 aclocal 和 autoconf ，分別会产生 aclocal.m4 及 configure 两个文件 然后执行:``` automake –add-missing``` 最后执行:``` ./configure```之后执行```make&amp;&amp;make install``` 继续后面的步骤5、make的时候出现模块加载失败注释带哦提示中对应文件中的对应行号（取消xx加载模块）### 使用教程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="include-lt-log4cplus-log4cplus-h-gt"><a href="#include-lt-log4cplus-log4cplus-h-gt" class="headerlink" title="include <log4cplus/log4cplus.h>"></a>include &lt;log4cplus/log4cplus.h&gt;</h1><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iomanip></iomanip></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<iostream></iostream></h1><p>using namespace std;!<br>using namespace log4cplus;<br>int main()<br>{<br>    log4cplus::Initializer initializer;//初始化<br>    log4cplus::SharedAppenderPtr appender(new log4cplus::ConsoleAppender());<br>    appender-&gt;setName(LOG4CPLUS_TEXT(“console”));<br>    appender-&gt;setLayout(std::unique_ptr<a href="log4cplus::Layout">log4cplus::Layout</a>(new log4cplus::SimpleLayout));<br>    Logger logger=Logger::getInstance(LOG4CPLUS_TEXT(“test”));<br>    logger.setLogLevel(log4cplus::INFO_LOG_LEVEL);<br>    logger.addAppender(appender);<br>    LOG4CPLUS_INFO(logger,LOG4CPLUS_TEXT(“Hello world!”));<br>    return 0;<br>}</p><pre class="line-numbers language-none"><code class="language-none">最简单的实验代码，打开vi输入后编译<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>g++ -std=c++17 -llog4cplus -o main main.cpp</p><p>```<br><img src="https://banthink.com/usr/uploads/2019/12/148724812.png" alt="TIM图片20191212182847.png"></p><p>运行后如果提醒找不到动态库，那么说明动态库没有导入到linux里面。<br>检查/etc/ld.so.conf文件，如果其中缺少/usr/local/lib 目录，就添加进去；<br>注意：在修改了<code>/etc/ld.so.conf </code>文件或者在系统中安装了新的函数库之后，需要运行命令<code> ldconfig</code> ，该命令用来刷新系统的共享库缓存，即 <code>/etc/ld.so.cache</code> 文件。为了减少共享库系统的库搜索时间，共享库系统维护了一个共享库so名称的缓存文件<code>/etc/ld.so.cache</code> 。 因此，在安装新的共享库之后，一定要运行 <code>ldconfig</code>刷新该缓存。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法复习-动态规划 （1）</title>
      <link href="suan-fa-fu-xi-dong-tai-gui-hua-1/"/>
      <url>suan-fa-fu-xi-dong-tai-gui-hua-1/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>问题的最优解如果可以由子问题的最优解推到得到，则可以先求解子问题的最优解，再构造原问题的最优解；若子问题由较多的重复出现，则可以自底向上从最终子问题向原问题逐步求解。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>将原始问题划分为一系列子问题</li><li>求解每一个子问题仅一次，并将结果保存在一张表中，以后用到直接存取，不需要重复计算</li><li>整体问题的最优解取决于子问题的最优解（状态转移方程，即将子问题称为状态，最终状态的求解归结于其他状态的求解）</li></ul><h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h2><ol><li>递归+记忆化 —&gt;  递推</li><li>找到状态变量并定义</li><li>寻找状态转移方程</li><li>分析分解条件</li><li>优化子结构<h2 id="例题讲解"><a href="#例题讲解" class="headerlink" title="例题讲解"></a>例题讲解</h2>讲解动态规划这个算法没有什么例子斐波拉契数列更经典的了。后面大部分的动态规划题目都是以斐波拉契数列为基础展开的。<br>题目：<br>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144…<br>请求出第n个数<h3 id="回溯法-递归"><a href="#回溯法-递归" class="headerlink" title="回溯法(递归)"></a>回溯法(递归)</h3>很明显的，从第三个数字开始，后面每个数字的值都是前两个数字相加得到的，那么我们可以写出一个很简单的递归程序.<pre class="line-numbers language-none"><code class="language-none">int Solution(int n){if(n&lt;=1)return 1;return Solution(n-1)+Solution(n-2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>我们可以写的更简单一点，一句话就够了<pre class="line-numbers language-none"><code class="language-none">return n&lt;=1?1:Solution(n-1)+Solution(n-2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这样写下来是不是逼格高了很多，我们将这个程序的函数调用过程画出来就是这样：</li></ol><p><img src="https://banthink.com/usr/uploads/2019/12/263068583.jpg" alt="蜂蜜浏览器_斐波拉斯数列.jpg"></p><p>图中以n=5为例，那么如果n趋向于无穷大，整个算法的时间复杂度就是趋向于2的n次方（用VC6.0跑太大数字直接就崩溃了23333）。<br>实际上，这个回溯法我们可以进一步优化为动态规划的算法。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>上面的设计步骤中的递归已经想出来了，那么记忆化呢？图中所有没有被绿色标记的地方都重复计算了一次，这对时间的消耗是致命的，我们可以将已经计算出来的结果都用一个数组保存起来（这就是<code>记忆化</code>），这个数组就是学动态规划每个人都知道的一个状态变量dp。</li><li>状态变量的定义很快就可以得出：dp[n]表示斐波拉契数列的解。</li><li>状态转移方程:f[n]=f[n-1]+f[n-2]  </li><li>分析分解条件:这一步的时候我们一般要考虑初始值(例如这道题就是输入值为1或2的条件下)和特殊情况。可以得出f[n]=f[n-1]+f[n-2] (n&gt;2).</li><li>优化子结构: 和贪心算法不同，动态规划是从全局的角度来考虑最优解的，同时状态变量下存储的都是每个子问题下面的最优解（这里不太理解的后面还有爬梯子的例题）.我们观察状态转移方程，发现实际上用到的就3个变量，分别是f[n]、f[n-1]、f[n-2]，我们可以将数组进一步优化为大小为3的数组。<br>最后，代码如下：<pre class="line-numbers language-none"><code class="language-none">int Solution(int n){int dp[3];if(n&lt;=2)return 1;dp[0]=1;dp[1]=1;for(int i=2;i&lt;n;i++)          //从2开始的原因是跳过前两个情况(n=1,n=2){dp[2]=dp[0]+dp[1];dp[0]=dp[1];dp[1]=dp[2];}return dp[2];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题（2）最长回文子串</title>
      <link href="leetcode-shua-ti-2-zui-chang-hui-wen-zi-chuan/"/>
      <url>leetcode-shua-ti-2-zui-chang-hui-wen-zi-chuan/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p>Example 1:</p><p>Input: “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.<br>Example 2:</p><p>Input: “cbbd”<br>Output: “bb”</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring">https://leetcode-cn.com/problems/longest-palindromic-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h3><pre class="line-numbers language-none"><code class="language-none">class Solution {public:    string longestPalindrome(string s) {        string temp="",maxStr="";        int maxLeft=0,maxRight=0,max=0;        if(s.size()&lt;=1)            return s;        for(int i=0;i&lt;s.length();i++)        {            for(maxRight=maxStr.length()+i;maxRight&lt;=s.length();maxRight++)            {                temp=s.substr(i,maxRight-i);                                int val=checkPaling(temp);                                if(val&gt;max)                {                    max=temp.length();                    maxStr=temp;                }            }        }        return maxStr;            }    int checkPaling(string s)    {        int len=0;        if(s.empty())            return 0;        if(s.size()%2)        {            for(int i=0;i&lt;s.length();i++)            {                if(s[i]==s[s.length()-1-i])                    len++;                else                    return 0;            }        }else        {            for(int i=0;i&lt;=s.length();i++)            {                if(s[i]==s[s.length()-1-i])                    len++;                else                    return 0;            }        }        return len;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插曲：当测试字符串过长的时候会出现<br>Line 506: Char 9: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xffffffffffffffff (basic_string.h)<br>逻辑是没有错误的，但是内存开销在小内存机器上很容易出错，错误出现的主要原因是在string 不断赋值分配再释放空间产生大量的内存碎片导致堆区溢出，。<br>其实上面的错误出现的原因是我输入的时候没有加上””，加上后就好了。<br>提交的时候出现错误是在<br><code> "babaddtattarrattatddetartrateedredividerb"</code> </p><p>后面发现当回文字符个数为偶数的时候就会出现这个错误，自己输入很长乱七八糟的都没问题，排除内存问题。结果是自己出现了个很小很小的错误</p><pre class="line-numbers language-none"><code class="language-none">   for(int i=0;i&lt;s.length();i++)   //这里i&lt;s.length()            {                if(s[i]==s[s.length()-1-i])                    len++;                else                    return 0;            }```  #### 最后提交也没通过，因为时间复杂度太高了。。。## 下面是动态规划方面的题解<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始状态：</p><p>dp[i][i]=1; //单个字符是回文串<br>dp[i][i+1]=1 if s[i]=s[i+1]; //连续两个相同字符是回文串<br>实现代码：</p><p>class Solution {<br>public:<br>    string longestPalindrome(string s) {<br>        int len=s.size();<br>        if(len==0||len==1)<br>            return s;<br>        int start=0;//回文串起始位置<br>        int max=1;//回文串最大长度<br>        vector&lt;vector<int>&gt;  dp(len,vector<int>(len));//定义二维动态数组<br>        for(int i=0;i&lt;len;i++)//初始化状态<br>        {<br>            dp[i][i]=1;<br>            if(i&lt;len-1&amp;&amp;s[i]==s[i+1])<br>            {<br>                dp[i][i+1]=1;<br>                max=2;<br>                start=i;<br>            }<br>        }<br>        for(int l=3;l&lt;=len;l++)//l表示检索的子串长度，等于3表示先检索长度为3的子串<br>        {<br>            for(int i=0;i+l-1&lt;len;i++)<br>            {<br>                int j=l+i-1;//终止字符位置<br>                if(s[i]==s[j]&amp;&amp;dp[i+1][j-1]==1)//状态转移<br>                {<br>                    dp[i][j]=1;<br>                    start=i;<br>                    max=l;<br>                }<br>            }<br>        }<br>        return s.substr(start,max);//获取最长回文子串<br>    }<br>};</int></int></p><p>```<br>作者：chenlele<br>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-c-by-gpe3dbjds1/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-c-by-gpe3dbjds1/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>上位机崩溃问题解决 2019-12-9</title>
      <link href="shang-wei-ji-beng-kui-wen-ti-jie-jue-2019-12-9/"/>
      <url>shang-wei-ji-beng-kui-wen-ti-jie-jue-2019-12-9/</url>
      
        <content type="html"><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>程序的可移植性<br>某些支持库没有安装、dll文件缺失但是运行的时候并不是提醒而是直接变现为崩溃的现象。</p><h3 id="问题-amp-BUG"><a href="#问题-amp-BUG" class="headerlink" title="问题&amp;BUG"></a>问题&amp;BUG</h3><p>老问题，一到某个位置就崩溃。</p><h3 id="过程及解决方案"><a href="#过程及解决方案" class="headerlink" title="过程及解决方案"></a>过程及解决方案</h3><ul><li>过程：让对方用串口调试助手+虚拟串口模拟真机跑一遍，同时我的电脑也跑一遍发现对方的机器崩溃了，在确认对方操作没问题的情况下得出是运行环境的问题。</li><li>解决方案：实地调试，可能是系统原因吧。<h3 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h3>发现是运行环境的问题的时候，我吐了。发誓以后都不再用微软的东西了，恶心。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C# 上位机 崩溃 2019-12-8</title>
      <link href="c-shang-wei-ji-beng-kui-2019-12-8/"/>
      <url>c-shang-wei-ji-beng-kui-2019-12-8/</url>
      
        <content type="html"><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>异常处理机制<br>try：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。<br>catch：程序通过异常处理程序捕获异常。catch 关键字表示异常的捕获。<br>finally：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。例如，如果您打开一个文件，不管是否出现异常文件都要被关闭。<br>throw：当问题出现时，程序抛出一个异常。使用 throw 关键字来完成。抛出异常意味着可以自定义异常消息，可以将异常处理的方法交给外部，内部只需要将异常出现时出现的原因（消息）告诉（比较简单的使用时throw(new ApplicationException(“字符串”))）外部就好了。</p><p>简单来说，对于一个可能出现问题的函数/过程我们用</p><pre class="line-numbers language-none"><code class="language-none">try{    内容}catch(exception e){   出现问题后我们的处理方案}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="问题-amp-BUG"><a href="#问题-amp-BUG" class="headerlink" title="问题&amp;BUG"></a>问题&amp;BUG</h3><p>硬件设备不在身边，串口收发数据方面出现问题，根据描述可以将错误定位在以下几个方面：</p><ol><li>DLL函数调用出错</li><li>下位机数据发送太快，出现粘包</li><li>信号量或者互斥锁释放异常</li></ol><h3 id="过程及解决方案"><a href="#过程及解决方案" class="headerlink" title="过程及解决方案"></a>过程及解决方案</h3><ol><li>过程<br>询问另一个工程师发现是VC14动态库没有安装，安装了之后发现还是运行到调用动态链接库的部分会出错，之后用另一个Qt编写的C++动态库测试程序在虚拟机测试（原环境中因为运行库都装好了无法检测问题），可以运行。之后再用VS2019写了个C++程序发现在虚拟机中运行不了，提醒错误。同时在一个博客中发现了一个神器：<code>Dependency Walker</code> 。可以列出程序中的依赖链接库。</li></ol><ul><li>结论：<code>VC14运行库丢失</code>。是因为我重写的DLL是在VS环境下写的，编译出来的DLL本身就需要很多依赖库</li><li>解决方案：重新在VC6.0里面重编译DLL。</li></ul><ol start="2"><li>过程<br>由于手头上没有设备，自己重新用C# 写了个模拟下位机动作的程序。上位机发送指令后下发现下位机连续发送两个包（第一个确认包，第二个数据包）经常会出现重包和粘包，由于大体逻辑已经固定了，时间比较赶，简单的处理了一下，成功。</li></ol><ul><li>结论：自己写的框架有问题</li><li>解决方案：重新下发重新接受数据包的指令，<code>将下位机连续发送两个包中的第二个包忽略</code>。由于有多个包，原本的用计数的方式逻辑上有点复杂，最后采取<code>只要收到最后一个包</code>就说明收包结束。同时增加一个工作日志，将自己收到的包数记录下来方便后续排查错误。</li></ul><ol start="3"><li>过程<br>同样因为手头没有设备，为了更好的定位错误内容，在可能出现错误的地方用都用try进行异常处理一下，在最后可以很快的找到问题。</li></ol><ul><li>结论：暂无</li><li>解决方案：对每一个可能出现问题的函数语句用try进行处理一下，一旦出现错误就弹出消息框。<h3 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h3>写日志真的很重要，尤其是当同样的问题重复出现的时候就能很快的解决问题。<br>以后用微软的东西真的要小心！！！程序的移植真的害死人，经常莫名其妙出现移植错误。最狗血的是连写个简单的C++程序特么的都需要一些支持库我都想吐了。怪不得用VC6.0比较流行，难用是难用但是干净啊，很多东西都不用担心没有装可以直接移植直接跑，简直不要太爽。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="1-guan-cha-zhe-mo-shi/"/>
      <url>1-guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>QT中的信号和槽机制就相当于观察者模式的一种扩展，全局实现了观察者模式，如果对QT的信号槽机制很了解的话对于观察者模式应该得心应手，因为信号和槽机制实现起来比观察者模式难得多（我说的不是简单的connect这样子…）<br>什么是观察者模式?<br>就是当目标发送了某个信号后与其绑定的对象执行特定的动作。就类似于开关和灯的关系，开关发送通电信号，灯观察到了这个信号后执行亮灯动作。所以开关是被观察的目标，灯是观察者。</p></blockquote><h4 id="首先明确一点，使用这个模式的目的是什么"><a href="#首先明确一点，使用这个模式的目的是什么" class="headerlink" title="首先明确一点，使用这个模式的目的是什么?"></a>首先明确一点，使用这个模式的目的是什么?</h4><p>假设我是一名嵌入式工程师，我需要编写一个开关类，当开关类中的一个位置被置1的时候，通知所有插在这个开关上的设备都通电。</p><h2 id="不使用观察者模式的实现"><a href="#不使用观察者模式的实现" class="headerlink" title="不使用观察者模式的实现"></a>不使用观察者模式的实现</h2><p>在开关类中设置一个bool flag同时开关类作为全局对象，所有的设备类都去循环检查这个值，如果为真就执行对应的动作。（最简单的实现）</p><ul><li>优点：简单毫不做作</li><li>缺点：无形之中浪费很多性能，我需要在一个线程中不断的去检查这个值，直到flag置为1的时候才需要触发对应的动作（通电）。团队开发的时候全局变量很容易出问题，经常被某某某给乱用就用出问题了。<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2>首先明确一个观察者：“设备”，被观察的“目标”:开关。<pre class="line-numbers language-none"><code class="language-none">class 开关{//开关类的代码public:void 按下开关();private 设备[数量];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><code>按下开关这个函数需要执行的动作是设备通电后需要执行的动作(函数)</code><br>二者被绑定到了一起，这样下来只要调用 <code>按下开关()</code>这个函数就好了。</li><li>优点：整体逻辑感强，易于维护，性能好</li><li>缺点：写的有点麻烦<br>这样就实现了最简单的观察者模式。</li></ul><p>接下来我们将问题扩大，当这个开关是各种各样的，设备所绑定的开关也是各种各样的，我们如果去每个都这么写一下代码量就很大，冗余也很多。那么我们可以将开关类抽象成一个目标类，实现如下：</p><pre class="line-numbers language-none"><code class="language-none">class Target{public :Target();~Target();void sendSignal()=0;   //发送信号部分,具体怎么轮询调用容器中的观察者动作需要自己写void addObserver();   //添加观察者到容器中void delObserver();  //删除protected:vector&lt;Observer&gt;Observers;  //这个需要受保护，不能开放给外部肆意修改};class Observer{public:Observer();~Observer();type Signalfun(argv)=0;  //获得信号后的动作。}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题（1）两数之和</title>
      <link href="leetcode-shua-ti-1-liang-shu-zhi-he/"/>
      <url>leetcode-shua-ti-1-liang-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>Example:<br>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br>My Solutation</p><pre class="line-numbers language-none"><code class="language-none">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {        ListNode *l3=new ListNode(0),*result,*last;        int bit=0,flag=0,sum=0;        if(l3==NULL)            return l3;         result=l3;        while((l1!=NULL)||(l2!=NULL))        {            sum=0;            if((l1!=NULL)&amp;&amp;(l2!=NULL))            {                sum=l1-&gt;val+l2-&gt;val;                l1=l1-&gt;next;                l2=l2-&gt;next;            }else if(l1==NULL)            {                sum=l2-&gt;val;                l2=l2-&gt;next;            }else if(l2==NULL)            {                sum=l1-&gt;val;                l1=l1-&gt;next;            }            sum+=bit;            bit=sum/10;            l3-&gt;val=sum%10;            l3-&gt;next=new ListNode(0);            last=l3;            l3=l3-&gt;next;        }        if(bit)            {                l3-&gt;val=bit;               l3-&gt;next=NULL;            }        else            {                last-&gt;next=NULL;                delete l3;            }        return result;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>解决思路：幸好题目的位数是逆位的，我设置一个bit位用来存放是否有低位到高位的进位，循环两个链表，位数相加赋值给sum，bit是通过sum取余得到的，整个解决方案很简单。</p></li><li><p>时间复杂度:O(n+m)</p></li><li><p>空间复杂度:O(n)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程（2）互斥锁和信号量</title>
      <link href="duo-xian-cheng-2-hu-chi-suo-he-xin-hao-liang/"/>
      <url>duo-xian-cheng-2-hu-chi-suo-he-xin-hao-liang/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="引用自维基百科"><a href="#引用自维基百科" class="headerlink" title="引用自维基百科"></a>引用自维基百科</h2><p>互斥锁（英语：英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。</p></blockquote><h3 id="信号量（英语：Semaphore）"><a href="#信号量（英语：Semaphore）" class="headerlink" title="信号量（英语：Semaphore）"></a>信号量（英语：Semaphore）</h3><p>又称为信号标，是一个同步对象，用于保持在0至指定最大值之间的一个计数值。当线程完成一次对该semaphore对象的等待（wait）时，该计数值减一；当线程完成一次对semaphore对象的释放（release）时，计数值加一。当计数值为0，则线程等待该semaphore对象不再能成功直至该semaphore对象变成signaled状态。semaphore对象的计数值大于0，为signaled状态；计数值等于0，为nonsignaled状态.</p><h3 id="互斥锁的作用"><a href="#互斥锁的作用" class="headerlink" title="互斥锁的作用"></a>互斥锁的作用</h3><p>在多线程编程中，多条线程对同一内存区域进行操作时，会产生意料之外的情况发生。这时候就需要用到互斥锁，线程对当前需要操作的内存区域进行加锁操作，避免其他线程进行相同的访问，导致错误的结果。当其他线程需要访问这片区域时，如果区域已经加锁了，就会进入到挂起队列处于挂起状态，等到这片区域解锁后再唤醒。<br>简而言之，互斥锁就是为了避免多个线程对同一区域进行访问而采取的措施。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程（1）线程的定义和相关API</title>
      <link href="duo-xian-cheng-1-xian-cheng-de-ding-yi-he-xiang-guan-api/"/>
      <url>duo-xian-cheng-1-xian-cheng-de-ding-yi-he-xiang-guan-api/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="线程的定义（以下摘自维基）"><a href="#线程的定义（以下摘自维基）" class="headerlink" title="线程的定义（以下摘自维基）"></a>线程的定义（以下摘自维基）</h2><p>线程是操作系统能够进行运算调度的最小单位。包含在进程中，是进程中实际的运作单位。一个线程指的是进程中一个单一顺序的控制流，一个进程可以并发多个线程，每个线程并行执行不同的任务。（在一些类Unix的系统中也被称为轻量进程，但是轻量进程更多指的是内核线程，而用户线程称为线程）<br>线程是独立调度和分配的基本单位。<br>同一进程中的多条线程将共享进程中的全部系统资源。例如虚拟地址空间，文件描述符和信号处理等等，因为线程没有自己单独的地址空间（共享进程的地址空间），当一个线程死掉就等于整个进程死掉。但是每个线程都有各自的调用栈（call stack）、寄存器地址（register context）和本地存储（thread-local storage）。<br>在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。 </p></blockquote><h2 id="POSIX线程有关API"><a href="#POSIX线程有关API" class="headerlink" title="POSIX线程有关API"></a>POSIX线程有关API</h2><pre class="line-numbers language-none"><code class="language-none">int pthread_create(pthread_t * thread ,const pthread_attr_t *attr, void *(*start_routine)(void *),void *arg); // 线程创建int pthread_join(pthread_t thread, void **retval);//线程等待void pthread_exit(void* retval);//线程终止运行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下源码引用自IBM Develop，<br>Daniel Robbins 大佬的博客，侵权删 </p><pre class="line-numbers language-none"><code class="language-none"># include &lt;pthread.h&gt;# include &lt;stdlib.h&gt;# include &lt;unistd.h&gt;void *thread_function(void *arg) {  int i;  for ( i=0; i&lt;20; i++) {    printf("Thread says hi!\n");    sleep(1);  }  return NULL;}int main(void) {  pthread_t mythread;     if ( pthread_create( &amp;mythread, NULL, thread_function, NULL) ) {    printf("error creating thread.");    abort();  }  if ( pthread_join ( mythread, NULL ) ) {    printf("error joining thread.");    abort();  }  exit(0);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要编译这个程序，只需先将程序存为 thread1.c，然后输入：</p><pre class="line-numbers language-none"><code class="language-none">$ gcc thread1.c -o thread1 -lpthread //-l 参数为调用外部动态链接库pthread<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>理解thread1.c<br>pthread_create函数中</p><ul><li>第一个参数 &amp;mythread是类型为pthread_t类型的变量，相当于线程句柄，为创建后的线程分配一个tid</li><li>第二个参数NULL，表示为线程的某些属性（具体内容不知道），一般为缺省属性（NULL）</li><li>第三个参数是线程所分配到的函数，也就是线程启动时调用的函数。</li><li>第四个参数NULL是向线程传递参数，可以使用void *通用指针的数据类型。这样可传入参数的就变得很多了。</li></ul><ol><li>这里的判断可以有效的避免创建线程失败后发生未知的现象，这一点在国外的开发者种极为常见，在国内的blog大多数的代码内容都没有这么严谨，考虑错误情况。<br>在线程创建完毕后，当前程序总共存在有两个线程，一个是主线程，一个是新创建的线程，两者没有进程中的父子关系，是同等级别的关系,</li><li>线程是并发运行的。即使在单处理器系统上运行（内核利用时间分片模拟多任务） 也是可以的<br>接下来调用pthread_join(mythread,NULL) ，这个函数在网上的作用大部分都是说用来让pthread_join所在的线程先挂起，等待第一个参数中的线程执行完毕。然而实际的使用中发现，调用这个函数之后，主线程并没有停止！后来在IBM Develop中看到对这个函数的解释———合并资源。我觉得这才是pthread_join的真正作用。让第一个参数中的线程执行完毕并且将其所占有的资源与主线程合并（和pthread_join所在线程合并）。之所以需要这个操作，是因为线程创建到结束，通过不主动将其释放资源（利用pthread_exti或者pthread)_join），其始终会占据着系统的资源不会自己主动释放。<h3 id="实际案例："><a href="#实际案例：" class="headerlink" title="实际案例："></a>实际案例：</h3>创建一个包含所有已停止线程的全局“死线程列表”，然后让一个专门的清理线程专等停止的线程加到列表中。这个清理线程调用 pthread_join() 将刚停止的线程与自己合并。现在，仅用一个线程就巧妙和有效地处理了全部清理。<br>最后程序结束。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Apache占用内存太高解决方案</title>
      <link href="apache-zhan-yong-nei-cun-tai-gao-jie-jue-fang-an/"/>
      <url>apache-zhan-yong-nei-cun-tai-gao-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内存占用突然飙高的原因竟然是…<br>最近，我在写博客的时候发现总是写着写着就崩了，重启之后就可以了。 本来以为是服务器IP突然被墙无法访问的原因（这个原因事后想来很蠢，因为重启之后就可以继续访问了所以肯定排除了服务器IP的问题），导致我换了好几次机房都无果。突然意识到，会不会是因为服务器的内存占用比太高了导致一些服务崩掉了。后来查了一下服务器后台的内存占用数据，果然。。。 再顺手一查发现果然是httpd占用太高了。<br> 这是解决后的（虽然仍然占比很多，但这是我在编辑文章的时候截的，实际效果好很多） </p></blockquote><ol><li>查看Apache是什么模式的<br><code>httpd -V</code><br>Ps:如果遇到找不到httpd命令的话，说明apache的文件夹没有加到全局变量里面。那么你就需要执行：<br><code>export PATH=/usr/local/apache/bin:$PATH</code><br>当然，这个只是一次性的，如果你不想下次用的话还需要翻阅你的浏览记录来查找这篇博客的话（尽管我很希望如此），那么就需要将这句话加入到全局配置文件中（或者在用用户目录下修改~/.bashrc用户配置文件）<br><code>vi /etc/profile </code><br>写入以下内容：<pre class="line-numbers language-none"><code class="language-none">export PATH="/usr/local/apache/bin:$PATH"我是event模式的 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>打开httpd的配置文件 （httpd.conf）<br>首先需要我们知道httpd的配置文件在哪里<pre class="line-numbers language-none"><code class="language-none">whereis apache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>进入到返回的路径中，可以发现有一个conf的文件夹，里面存放着我们需要的httpd.conf配置文件，用vi打开。<pre class="line-numbers language-none"><code class="language-none">vi httpd.conf//添加一下内容 ServerLimit 16 //最大子进程数量StartServers 2 //创建子进程的初始数量MaxRequestWorkers 150 //最大工作线程的数量MinSpareThreads 10 //最小空闲线程的数量MaxSpareThreads 30 //最大空闲线程的数量ThreadsPerChild 10 //每个子进程创建的线程数量MaxConnectionsPerChild 300 //每个子进程的最大连接数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>备份httpd.conf</li><li>重启服务<pre class="line-numbers language-none"><code class="language-none">systemctl restart httpd.service <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>大功告成！</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gcc链接 动态库静态库</title>
      <link href="gcc-lian-jie-dong-tai-ku-jing-tai-ku/"/>
      <url>gcc-lian-jie-dong-tai-ku-jing-tai-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>Linux下的库有两种：静态库和动态库（又称共享库），.a表示静态库，.os表示动态库<br>两者的区别为载入到代码的时刻不同。静态库的代码在编译过程中就已经载入到可执行程序中，类似于头文件加载一般，产生的程序体积较大。动态库的代码是在可执行程序在运行的时候才载入到内存中，在编译中仅做一个简单的引用，因此生成的体积较小<br>ldd命令可以查看一个可执行程序依赖的共享库， </p><pre class="line-numbers language-none"><code class="language-none">例如$ ldd /bin/lnlibc.so.6 =&gt; /lib/libc.so.6 (0×40021000)/lib/ld-linux.so.2 =&gt; /lib/ld- linux.so.2 (0×40000000) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到ln命令依赖于libc库和ld-linux库 </p><h4 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h4><ul><li>优点：生成程序体积小，方便更新，不同程序当调用同一个库时可以共享一个动态库，只要在内存中有</li><li>缺点：程序不稳定，动态库一旦丢失就无法启动，给其他人使用时需要对方有相应的动态库。<br>动态库链接时搜索的路径顺序</li></ul><ol><li>编译目标代码时指定的动态库搜索路径；</li><li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径；</li><li>配置文件/etc/ld.so.conf中指定的动态库搜索路径；</li><li>默认的动态库搜索路径/lib；</li><li>默认的动态库搜索路径/usr/lib。<h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4></li></ol><ul><li>优点：程序稳定，便于传播</li><li>缺点：生成程序体积大，且更新主程序时需要全部重新编译链接，耗费时间长。<br>静态库链接时搜索的路径顺序 </li></ul><ol><li>ld会去找GCC命令中的参数-L</li><li>再找gcc的环境变量LIBRARY_PATH</li><li>再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的</li></ol><h2 id="二、执行代码"><a href="#二、执行代码" class="headerlink" title="二、执行代码"></a>二、执行代码</h2><h3 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h3><ol><li><p>创建静态库</p><pre class="line-numbers language-none"><code class="language-none">$ar rcs libmyhello.a hello.o//ar rcs创建静态链接库命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>链接</p><pre class="line-numbers language-none"><code class="language-none">$gcc -o hello main.c -static -L. -lmyhello //hello 指的是生成的可执行文件名//-static 创建静态链接库参数// -L.  静态链接库的位置//-lmyhello   -l部分是调用链接库的参数，myhello指的是静态链接库名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h3></li><li><p>创建动态库</p><pre class="line-numbers language-none"><code class="language-none">$gcc -shared -fPIC -c hello.c$gcc -shared -fPIC -o libmyhello.so hello.o//“PIC”命令行标记告诉GCC产生的代码不要包含对函数和变量具体内存位置的引用，这是因为现在还无法知道使用该消息代码的应用程序会将它连接到哪一段内存地址空间。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>重定位动态链接库<br>如果直接执行第三步后运行程序会直接报错：<br>error while loading shared libraries: libmyhello.so: cannot open shared object file: No such file or directory<br>原因是因为程序运行时找不到动态库文件的位置。有三种解决方法：</p></li></ol><ul><li><code>$sudo mv libmyhello.so /usr/lib //放入用户动态库中</code></li><li><code>$export LD_LIBRARY_PATH=$(pwd) //修改环境变量（指示动态连接器可以装载动态库的路径）</code></li><li><code>$sudo ldconfig ~/testso //ldconfig</code>将制定目录下的动态链接库被系统共想起来 ，意即:在缓存文件/etc/ld.so.cache中追加进指定目录下的共享库.本例让系统共享了~/tests目录下的动态链接库。 </li></ul><ol start="3"><li>编译链接<pre class="line-numbers language-none"><code class="language-none">$ gcc -o hello main.c -L. -lmyhello//-lmyhello   告诉GCC驱动程序在连接阶段引用共享函数库libmyhello.so  //-L.  （网上都说是告诉GCC函数库可能位于当前目录，但是实际上并不是这样）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>本篇文章大部分内容摘自 牛顿的小脑，侵删 </p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于正则表达式的笔记</title>
      <link href="guan-yu-zheng-ze-biao-da-shi-de-bi-ji/"/>
      <url>guan-yu-zheng-ze-biao-da-shi-de-bi-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>用来记录一些正则表达式下的一些东西怕自己忘了<br>首先是一些常用的符号的意思</p></blockquote><ul><li>^：表示开头</li><li>$：表示结尾</li><li>*：表示任意字符或者无字符</li><li>.：表示单一字符    </li><li>（.*  这样连起来的应用就是至少要有一个字符字符）</li><li>[] ：表示字符集，意味着这里面的内容都可以被匹配到<br>下面是一些常用的字符集，也可以直接使用自己定义的字符集，如[# ]这个字符集里只有一个<br>[:alnum:] 数字字符    [:digit:] : 数字字符    [:punct:]  标点符号字符<br>[:alpha:]  字母字符    [:graph:]  非空格字符     [:space:]  空格字符<br>[:blank:] 空格与定位字符    [:lower:] 小写字母字符    [:upper:]  大写字母字符<br>[:cntrl:]  控制字符    [:print:] 可显示的字符    [:xdigit:]  16进制数字<br>  例子<br>  sed ‘/^[# ]/d’ file<br>  删除开头是# 的行<br>  sed ‘/^\s$/d’ file<br>  删除空行</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32嵌入式的内存管理</title>
      <link href="stm32-qian-ru-shi-de-nei-cun-guan-li/"/>
      <url>stm32-qian-ru-shi-de-nei-cun-guan-li/</url>
      
        <content type="html"><![CDATA[<ul><li>堆区：由于程序员自主分配的内存空间 <ul><li>生命周期：整个程序的运行阶段（直到主动释放） </li><li>作用域：取决于变量的位置，变量如果在局部的时候需要将数据的地址传递出来 </li><li>Notice:堆区是由低地址往上增长的，连续的。 </li></ul></li><li>栈区：由程序自动为变量所分配的内存空间<ul><li>声明周期：函数结束即自动消亡 </li><li>作用域：所处的函数段 </li><li>特点：LIFO，可用于保存和恢复现场，例如当一个中断发生时候，先将当前PC指针所指向的内存地址压栈（保护现场），再跳转到中断程序中执行中断函数，中断结束后出栈，根据出栈后的地址返回原现场。</li><li>Notice： 栈是由往下减少，连续的。 </li></ul></li></ul><hr><p>以上的内容都是在程序运行过程中，根据程序中的代码进行的动态内存分配，即都存储在SRAM中（断电消失）<br>code/text（代码段）:用于存储烧录进来的代码。 这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。  </p><ul><li>Bss段（ Block Started by Symbol ）<br>存放未初始化或初始化为0的全局变量，其中未初始化的全局变量会在开始运行时系统自动将其初始化为0。即此段存放的都是值为0的全局变量，即此段只是记录变量所需要的内存大小。在汇编中体现为一个占位符，有系统来进行初始化，其数据内容并不包含在生成的可执行文件中。</li><li>data段（数据段）<br>存放初始化不为0的全局变量。由程序在编译阶段为其初始化，并将其数据存储在可执行文件中。</li></ul><hr><p>接下来是MDK中下Code、Ro-data、Rw-data、ZI-data这几个段的划分</p><ul><li>code:存储程序代码</li><li>RO-data：存储const常量和汇编指令</li><li>RW-data:存储初始化值不为0的全局变量</li><li>ZI-data:存储初始化为0或未初始化的全局变量 （即BSS段中的内容，由系统为其初始化为0）</li><li>Flash=Code+RO-data-RW-data</li><li>SRAM=RW-data+ZI-data</li></ul><p>这些内容是MDK在编译后能得到的每个段的大带下，也就是能够得到在占用在相应的FLASH和SRAM的大小，但是堆和栈这两个数据段在程序运行阶段也会占用SRAM的大小（动态内存分配），具体堆栈的大小在只有在运行之后才能知道。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图文并茂 教你从零开始搭建ss梯子 实现科学上网</title>
      <link href="tu-wen-bing-mao-jiao-ni-cong-ling-kai-shi-da-jian-ss-ti-zi-shi-xian-ke-xue-shang-wang/"/>
      <url>tu-wen-bing-mao-jiao-ni-cong-ling-kai-shi-da-jian-ss-ti-zi-shi-xian-ke-xue-shang-wang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近朋友想要自己搭建一个梯子，让我帮忙给他个教程，我就写这里了，方便以后可以方便找到</p></blockquote><p>前段时间有看过各大VPS厂商的价格方案，综合考虑下来Vultr性价比最高，很多人用得搬瓦工其实也还不错，就是不能换IP，如果IP被墙了就很难受，Vultr每次换IP只要0.01美金（换成人民币也就1块钱不到应该没有谁不能接受的吧）。现在Vultr的活动没有以前多了，最便宜的主机也要$5/month ，服务器配置也还行，将就着用吧。</p><ol><li>首先打开vultr注册网址（我的推荐网址<a href="https://www.vultr.com/?ref=7556028~~%E9%80%9A%E8%BF%87%E8%BF%99%E4%B8%AA%E7%BD%91%E5%9D%80%E6%B3%A8%E5%86%8C%E4%B8%80%E6%AC%A1%E6%80%A7%E5%85%85%E5%80%BC50%E8%83%BD%E9%80%81%E6%8A%B5%E7%94%A8%E5%88%B8%EF%BC%8C%E5%85%B7%E4%BD%93%E5%A4%9A%E5%B0%91%E5%BF%98%E4%BA%86%EF%BC%89">https://www.vultr.com/?ref=7556028~~通过这个网址注册一次性充值50能送抵用券，具体多少忘了）</a><br><img src="https://banthink.com/usr/uploads/2019/12/177939606.png" alt="图1官网"></li><li>密码需要满足大写、小写、数字、大于10个字符这四个条件<br><img src="https://banthink.com/usr/uploads/2019/12/111447772.png" alt="图2注册"><br>注册就不具体说了，注册成功后会进入到后台管理界面，点击“+”创建新主机</li><li>后台管理界面<br><img src="https://banthink.com/usr/uploads/2019/12/3949157703.png" alt="图3后台管理界面.png"></li><li>Chose Server中选择第一个cloud computer<br>服务器所在地随便选一个，建议选择新加坡、日本、加拿大等地。<br><img src="https://banthink.com/usr/uploads/2019/12/3976604307.png" alt="图4选择服务器.png"></li><li>系统建议centOs，价格如果没有特殊需求仅做梯子使用选最便宜就够了<br><img src="https://banthink.com/usr/uploads/2019/12/3287230165.png" alt="图5系统选择.png"></li><li>这边的附加选项都不要打钩.购买后会有一段时间来进行安装系统部署环境。耐心等待就可以了。安装完成后点击服务器<br><img src="https://banthink.com/usr/uploads/2019/12/493758546.png" alt="图6服务器内容设置.png"></li><li>成功安装<br><img src="https://banthink.com/usr/uploads/2019/12/2560311523.png" alt="图7成功安装.png"></li><li>记住自己的服务器的用户名和密码，点击图上的箭头所示位置<br><img src="https://banthink.com/usr/uploads/2019/12/1849495633.png" alt="图8服务器信息.png"></li><li>弹出命令台<br>等待一段时间后会进入到上述界面，输入服务器的用户名和密码（密码是暗文，不会显示出来，自己注意输入正确即可，不能复制黏贴）<br><img src="https://banthink.com/usr/uploads/2019/12/2578842557.png" alt="图9命令台.png"></li></ol><hr><h3 id="下面部分是ss安装部分"><a href="#下面部分是ss安装部分" class="headerlink" title="下面部分是ss安装部分"></a>下面部分是ss安装部分</h3><p>（以centos系统为例）<br>进入服务器后，就可以运行SSR代码了，这里推荐秋水逸冰大大的（原文网址<a href="https://shadowsocks.be/9.html%EF%BC%89%EF%BC%8C%E5%BD%93%E7%84%B6%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%85%B6%E4%BB%96%E7%9A%84%EF%BC%8C%E7%BD%91%E4%B8%8A%E4%BB%A3%E7%A0%81%E5%BE%88%E5%A4%9A">https://shadowsocks.be/9.html），当然也可以用其他的，网上代码很多</a><br>运行下列命令（三条命令都需要执行完）：</p><pre class="line-numbers language-none"><code class="language-none">1. wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh2. chmod +x shadowsocks-all.sh3. ./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log执行后第一个提醒安装哪一个版本的ss，我是装了SSR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><p>运行后，会提示你设置端口（port）和密码（password），加密方式,协议,混淆,端口设为80</p><ul><li>提示<strong>Please enter password for ShadowsocksR</strong>:设置SSR连接密码：自己设定（如不设定，默认为 teddysun.com） </li><li>提示**Please enter a port for ShadowsocksR [1-65535]**设置你的服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成） </li><li>提示**Please select stream cipher for ShadowsocksR:**设置加密方式,输入序号回车选择：自己设定(建议chacha20)（如不设定，Python 和 libev 版默认为 aes-256-gcm，R 和 Go 版默认为 aes-256-cfb） </li><li>提示<strong>Please select protocol for ShadowsocksR</strong>:输入序号回车选择协议（protocol）：自己设定（如不设定，默认为 origin） </li><li>提示 <strong>Please select obfs for ShadowsocksR</strong>:输入序号回车选择混淆方式obfs,(免流请选择2:http_simple)（如不设定，默认为 plain）（仅限 ShadowsocksR 版）</li></ul><p>设置后直接回车，让代码自己运行，大概几分钟后运行结束，这时会出现红色字体的配置信息，请务必牢记，最好截图保存，以免遗忘<br> <img src="https://banthink.com/usr/uploads/2019/12/3997449569.png" alt="图10安装成功.png"><br>备注：脚本默认创建单用户配置文件，如需配置多用户，请手动修改相应的配置文件后重启即可。<br>本脚本安装完成后即已后台启动，且开机自动启动。<br>之后就需要下载Shadowsocks 将上述的配置依次填入之后启用就可以啦</p><hr><hr><p>注意:Vultr最新CentOS7需要开放端口或者关闭防火墙才能连接!!!!!!</p><hr><pre class="line-numbers language-none"><code class="language-none">停止防火墙请执行[回车]:systemctl stop firewalld重启防火墙[回车]:firewall–cmd —reload查看防火墙状态[回车] not running  表示已关闭:firewall–cmd —reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>防火墙其他高级设置,如单独开放端口等,可以参考以下文章:<br>Centos7 防火墙 firewalld 实用操作（<a href="https://www.cnblogs.com/yyxq/p/10551274.html%EF%BC%89">https://www.cnblogs.com/yyxq/p/10551274.html）</a><br>其他命令:<br>查看进程是否启动：运行：</p><pre class="line-numbers language-none"><code class="language-none">/etc/init.d/shadowsocks status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="最后再加上冰大的一键安装BBR脚本（不一定要装，根据自己服务器速度来定，不满意的话装了试试看）"><a href="#最后再加上冰大的一键安装BBR脚本（不一定要装，根据自己服务器速度来定，不满意的话装了试试看）" class="headerlink" title="最后再加上冰大的一键安装BBR脚本（不一定要装，根据自己服务器速度来定，不满意的话装了试试看）"></a>最后再加上冰大的一键安装BBR脚本（不一定要装，根据自己服务器速度来定，不满意的话装了试试看）</h3><p>以下是冰大的一键脚本</p><p>使用 root 用户登录，运行以下命令：</p><pre class="line-numbers language-none"><code class="language-none">1. wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh2. chmod +x bbr.sh3. ./bbr.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。<br>重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令：</p><p><code>uname -r</code><br>查看内核版本，含有 4.10 就表示 OK 了</p><p>查看 BBR 是否启用，输入以下命令：<br>lsmod | grep bbr<br>返回值有 tcp_bbr 模块即说明 bbr 已启动。</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一张图了解shell 编程</title>
      <link href="yi-zhang-tu-liao-jie-shell-bian-cheng/"/>
      <url>yi-zhang-tu-liao-jie-shell-bian-cheng/</url>
      
        <content type="html"><![CDATA[<p><img src="https://banthink.com/usr/uploads/2019/12/729402288.png" alt="shell基本编程-1024x1010.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
